<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>souffle: Util.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">souffle
   &#160;<span id="projectnumber">e23420a</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Util.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;array&gt;</code><br />
<code>#include &lt;atomic&gt;</code><br />
<code>#include &lt;chrono&gt;</code><br />
<code>#include &lt;condition_variable&gt;</code><br />
<code>#include &lt;cstdlib&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;mutex&gt;</code><br />
<code>#include &lt;ostream&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cctype&gt;</code><br />
<code>#include &lt;cerrno&gt;</code><br />
<code>#include &lt;climits&gt;</code><br />
<code>#include &lt;cstdarg&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;sys/stat.h&gt;</code><br />
<code>#include &lt;libgen.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Util.h:</div>
<div class="dyncontent">
<div class="center"><img src="_util_8h__incl.png" border="0" usemap="#_util_8h" alt=""/></div>
<map name="_util_8h" id="_util_8h">
<area shape="rect" id="node2" href="_ram_types_8h.html" title="RamTypes.h" alt="" coords="172,80,273,107"/>
</map>
</div>
</div>
<p><a href="_util_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_cache_access_counter.html">souffle::CacheAccessCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">cache hits/misses.  <a href="classsouffle_1_1_cache_access_counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1comp__deref.html">souffle::comp_deref&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor class supporting the values pointers are pointing to.  <a href="structsouffle_1_1comp__deref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1is__printable_3_01_t_00_01typename_01std_1_1conditional_3_01false_00_6524b7834a471e17ac26f0874b83b7af.html">souffle::detail::declval&lt; std::ostream &amp; &gt;()&lt;&lt; std::declval&lt; T &gt;()), void &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait to check whether a given type is printable.  <a href="structsouffle_1_1detail_1_1is__printable_3_01_t_00_01typename_01std_1_1conditional_3_01false_00_6524b7834a471e17ac26f0874b83b7af.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1deref.html">souffle::deref&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor dereferencing a given type.  <a href="structsouffle_1_1deref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1deref__less.html">souffle::deref_less&lt; T, C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor comparing the dereferenced value of a pointer type utilizing a given comparator.  <a href="structsouffle_1_1deref__less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1id.html">souffle::id&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor representing the identity function for a generic type T.  <a href="structsouffle_1_1id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1is__printable.html">souffle::detail::is_printable&lt; T, filter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait to check whether a given type is printable.  <a href="structsouffle_1_1detail_1_1is__printable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">souffle::detail::joined_sequence&lt; Iter, Printer &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A auxiliary class to be returned by the join function aggregating the information required to print a list of elements as well as the implementation of the printing itself.  <a href="classsouffle_1_1detail_1_1joined__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1lambda__traits.html">souffle::lambda_traits&lt; Lambda &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait enabling the deduction of type properties of lambdas.  <a href="structsouffle_1_1lambda__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1lambda__traits__helper.html">souffle::detail::lambda_traits_helper&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1lambda__traits__helper_3_01_r_07_a0_08_4.html">souffle::detail::lambda_traits_helper&lt; R(A0)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1lambda__traits__helper_3_01_r_07_a0_00_01_a1_08_4.html">souffle::detail::lambda_traits_helper&lt; R(A0, A1)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1lambda__traits__helper_3_01_r_07_args_8_8_8_08_4.html">souffle::detail::lambda_traits_helper&lt; R(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1lambda__traits__helper_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_01const_01_4.html">souffle::detail::lambda_traits_helper&lt; R(C::*)(Args...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1lambda__traits__helper_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_4.html">souffle::detail::lambda_traits_helper&lt; R(C::*)(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_l_r_u_cache.html">souffle::LRUCache&lt; T, size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Least-Recently-Used cache for arbitrary element types.  <a href="classsouffle_1_1_l_r_u_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_l_r_u_cache_3_01_t_00_010_01_4.html">souffle::LRUCache&lt; T, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_l_r_u_cache_3_01_t_00_011_01_4.html">souffle::LRUCache&lt; T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1multiplying__printer.html">souffle::detail::multiplying_printer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class required for the implementation of the times function.  <a href="structsouffle_1_1detail_1_1multiplying__printer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1print.html">souffle::detail::print&lt; Extractor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic element printer.  <a href="structsouffle_1_1detail_1_1print.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1print__deref.html">souffle::print_deref&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor printing elements after dereferencing it.  <a href="structsouffle_1_1print__deref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1range.html">souffle::range&lt; Iter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class enabling representation of ranges by pairing two iterator instances marking lower and upper boundaries.  <a href="structsouffle_1_1range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_temp_file_stream.html">souffle::TempFileStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesouffle"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html">souffle</a></td></tr>
<tr class="memdesc:namespacesouffle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Souffle - A Datalog Compiler Copyright (c) 2013, 2015, Oracle and/or its affiliates. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesouffle_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1detail.html">souffle::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacestd"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestd.html">std</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9eb29a1677ffbe44fe8663f881213f0e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9eb29a1677ffbe44fe8663f881213f0e">souffle::time_point</a> = std::chrono::high_resolution_clock::time_point</td></tr>
<tr class="separator:a9eb29a1677ffbe44fe8663f881213f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8a2c294e3ff514cd4ca29b466ff3cab3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8a2c294e3ff514cd4ca29b466ff3cab3">souffle::absPath</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a8a2c294e3ff514cd4ca29b466ff3cab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++-style realpath.  <a href="namespacesouffle.html#a8a2c294e3ff514cd4ca29b466ff3cab3">More...</a><br /></td></tr>
<tr class="separator:a8a2c294e3ff514cd4ca29b466ff3cab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b5f9eb9ec09c40e558b242e75de872"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a14b5f9eb9ec09c40e558b242e75de872"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">souffle::all_of</a> (const Container &amp;c, UnaryPredicate <a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:a14b5f9eb9ec09c40e558b242e75de872"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic test checking whether all elements within a container satisfy a certain predicate.  <a href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">More...</a><br /></td></tr>
<tr class="separator:a14b5f9eb9ec09c40e558b242e75de872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f8eecb81c090fca9e58d3357b63ed9"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a34f8eecb81c090fca9e58d3357b63ed9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">souffle::any_of</a> (const Container &amp;c, UnaryPredicate <a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:a34f8eecb81c090fca9e58d3357b63ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic test checking whether any elements within a container satisfy a certain predicate.  <a href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">More...</a><br /></td></tr>
<tr class="separator:a34f8eecb81c090fca9e58d3357b63ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbc2262a6164b62766f6fcb67f12ae4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4">souffle::baseName</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a9fbc2262a6164b62766f6fcb67f12ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785852c2fc649d79a481627605ffcf4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a785852c2fc649d79a481627605ffcf4f">souffle::canBeParsedAsRamFloat</a> (const std::string &amp;string)</td></tr>
<tr class="memdesc:a785852c2fc649d79a481627605ffcf4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can a string be parsed as RamFloat.  <a href="namespacesouffle.html#a785852c2fc649d79a481627605ffcf4f">More...</a><br /></td></tr>
<tr class="separator:a785852c2fc649d79a481627605ffcf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f207449b2332bf06ab28993dda09b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a89f207449b2332bf06ab28993dda09b9">souffle::canBeParsedAsRamSigned</a> (const std::string &amp;string)</td></tr>
<tr class="memdesc:a89f207449b2332bf06ab28993dda09b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can a string be parsed as RamSigned.  <a href="namespacesouffle.html#a89f207449b2332bf06ab28993dda09b9">More...</a><br /></td></tr>
<tr class="separator:a89f207449b2332bf06ab28993dda09b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3773094eb7aa42e20a209b40c9873aa4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3773094eb7aa42e20a209b40c9873aa4">souffle::canBeParsedAsRamUnsigned</a> (const std::string &amp;string)</td></tr>
<tr class="memdesc:a3773094eb7aa42e20a209b40c9873aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can a string be parsed as RamUnsigned.  <a href="namespacesouffle.html#a3773094eb7aa42e20a209b40c9873aa4">More...</a><br /></td></tr>
<tr class="separator:a3773094eb7aa42e20a209b40c9873aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa523350db005da7a3c79c845ebbb6aa7"><td class="memTemplParams" colspan="2">template&lt;typename toType , typename baseType &gt; </td></tr>
<tr class="memitem:aa523350db005da7a3c79c845ebbb6aa7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa523350db005da7a3c79c845ebbb6aa7">souffle::castEq</a> (const baseType *left, const baseType *right)</td></tr>
<tr class="memdesc:aa523350db005da7a3c79c845ebbb6aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the values, from baseType to toType and compare using ==.  <a href="namespacesouffle.html#aa523350db005da7a3c79c845ebbb6aa7">More...</a><br /></td></tr>
<tr class="separator:aa523350db005da7a3c79c845ebbb6aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018886d19f141b1cb565199a517c598f"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a018886d19f141b1cb565199a517c598f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f">souffle::clone</a> (const A *node)</td></tr>
<tr class="separator:a018886d19f141b1cb565199a517c598f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5539f3bdbac7d5cc7fc87434aa4adb"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:afd5539f3bdbac7d5cc7fc87434aa4adb"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#afd5539f3bdbac7d5cc7fc87434aa4adb">souffle::clone</a> (const std::unique_ptr&lt; A &gt; &amp;node)</td></tr>
<tr class="separator:afd5539f3bdbac7d5cc7fc87434aa4adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b945c962bb01844b4b2032a77e64564"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a7b945c962bb01844b4b2032a77e64564"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; A &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7b945c962bb01844b4b2032a77e64564">souffle::clone</a> (const std::vector&lt; std::unique_ptr&lt; A &gt;&gt; &amp;xs)</td></tr>
<tr class="separator:a7b945c962bb01844b4b2032a77e64564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3295dd83a588d612cf777e600beac4a"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:af3295dd83a588d612cf777e600beac4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af3295dd83a588d612cf777e600beac4a">souffle::contains</a> (const C &amp;container, const typename C::value_type &amp;element)</td></tr>
<tr class="memdesc:af3295dd83a588d612cf777e600beac4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility to check generically whether a given element is contained in a given container.  <a href="namespacesouffle.html#af3295dd83a588d612cf777e600beac4a">More...</a><br /></td></tr>
<tr class="separator:af3295dd83a588d612cf777e600beac4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2a6a041cccb09653b996dbeed7b4fd"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:aad2a6a041cccb09653b996dbeed7b4fd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aad2a6a041cccb09653b996dbeed7b4fd">souffle::contains</a> (const C &amp;container, const typename C::value_type::first_type &amp;element)</td></tr>
<tr class="memdesc:aad2a6a041cccb09653b996dbeed7b4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of contains specialized for maps.  <a href="namespacesouffle.html#aad2a6a041cccb09653b996dbeed7b4fd">More...</a><br /></td></tr>
<tr class="separator:aad2a6a041cccb09653b996dbeed7b4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e10d44624c80609e5c09b131ecf3fb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a72e10d44624c80609e5c09b131ecf3fb">souffle::dirName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a72e10d44624c80609e5c09b131ecf3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++-style dirname.  <a href="namespacesouffle.html#a72e10d44624c80609e5c09b131ecf3fb">More...</a><br /></td></tr>
<tr class="separator:a72e10d44624c80609e5c09b131ecf3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba27d2caf5a777268d89eaf5cbfed2a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8ba27d2caf5a777268d89eaf5cbfed2a">souffle::duration_in_ns</a> (const time_point &amp;start, const time_point &amp;end)</td></tr>
<tr class="separator:a8ba27d2caf5a777268d89eaf5cbfed2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3be713865e2b9922aa0eac1fb629041"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af3be713865e2b9922aa0eac1fb629041">souffle::duration_in_us</a> (const time_point &amp;start, const time_point &amp;end)</td></tr>
<tr class="separator:af3be713865e2b9922aa0eac1fb629041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e84ddff3bc168499fa141d3a3998494"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6e84ddff3bc168499fa141d3a3998494">souffle::endsWith</a> (const std::string &amp;value, const std::string &amp;ending)</td></tr>
<tr class="memdesc:a6e84ddff3bc168499fa141d3a3998494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given value string ends with the given end string.  <a href="namespacesouffle.html#a6e84ddff3bc168499fa141d3a3998494">More...</a><br /></td></tr>
<tr class="separator:a6e84ddff3bc168499fa141d3a3998494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab097fb451e787a08a185a449bacde2db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab097fb451e787a08a185a449bacde2db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab097fb451e787a08a185a449bacde2db">souffle::equal_ptr</a> (const T *a, const T *<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:ab097fb451e787a08a185a449bacde2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two values referenced by a pointer where the case where both pointers are null is also considered equivalent.  <a href="namespacesouffle.html#ab097fb451e787a08a185a449bacde2db">More...</a><br /></td></tr>
<tr class="separator:ab097fb451e787a08a185a449bacde2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b13dfdf28e89958f7adeaa43abbe34f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b13dfdf28e89958f7adeaa43abbe34f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9b13dfdf28e89958f7adeaa43abbe34f">souffle::equal_ptr</a> (const std::unique_ptr&lt; T &gt; &amp;a, const std::unique_ptr&lt; T &gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a9b13dfdf28e89958f7adeaa43abbe34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two values referenced by a pointer where the case where both pointers are null is also considered equivalent.  <a href="namespacesouffle.html#a9b13dfdf28e89958f7adeaa43abbe34f">More...</a><br /></td></tr>
<tr class="separator:a9b13dfdf28e89958f7adeaa43abbe34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16e133691dd9963d4234b61e3cc203f"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Comparator &gt; </td></tr>
<tr class="memitem:ae16e133691dd9963d4234b61e3cc203f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae16e133691dd9963d4234b61e3cc203f">souffle::equal_targets</a> (const Container &amp;a, const Container &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, const Comparator &amp;comp)</td></tr>
<tr class="memdesc:ae16e133691dd9963d4234b61e3cc203f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two containers are equal with the given Comparator.  <a href="namespacesouffle.html#ae16e133691dd9963d4234b61e3cc203f">More...</a><br /></td></tr>
<tr class="separator:ae16e133691dd9963d4234b61e3cc203f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb99b4f76eebd4491ad16473e4dda5b"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; typename... &gt; class Container&gt; </td></tr>
<tr class="memitem:accb99b4f76eebd4491ad16473e4dda5b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#accb99b4f76eebd4491ad16473e4dda5b">souffle::equal_targets</a> (const Container&lt; T *&gt; &amp;a, const Container&lt; T *&gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:accb99b4f76eebd4491ad16473e4dda5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two containers of pointers are referencing equivalent targets.  <a href="namespacesouffle.html#accb99b4f76eebd4491ad16473e4dda5b">More...</a><br /></td></tr>
<tr class="separator:accb99b4f76eebd4491ad16473e4dda5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87752f386ec8b0ab3a1f943d4f29896"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; typename... &gt; class Container&gt; </td></tr>
<tr class="memitem:af87752f386ec8b0ab3a1f943d4f29896"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af87752f386ec8b0ab3a1f943d4f29896">souffle::equal_targets</a> (const Container&lt; std::unique_ptr&lt; T &gt;&gt; &amp;a, const Container&lt; std::unique_ptr&lt; T &gt;&gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:af87752f386ec8b0ab3a1f943d4f29896"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two containers of unique pointers are referencing equivalent targets.  <a href="namespacesouffle.html#af87752f386ec8b0ab3a1f943d4f29896">More...</a><br /></td></tr>
<tr class="separator:af87752f386ec8b0ab3a1f943d4f29896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b97dba4d2f55282e3383098bbea3aee"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a0b97dba4d2f55282e3383098bbea3aee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a0b97dba4d2f55282e3383098bbea3aee">souffle::equal_targets</a> (const std::map&lt; Key, std::unique_ptr&lt; Value &gt;&gt; &amp;a, const std::map&lt; Key, std::unique_ptr&lt; Value &gt;&gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a0b97dba4d2f55282e3383098bbea3aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two maps of unique pointers are referencing to equivalent targets.  <a href="namespacesouffle.html#a0b97dba4d2f55282e3383098bbea3aee">More...</a><br /></td></tr>
<tr class="separator:a0b97dba4d2f55282e3383098bbea3aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad78346252bf890fbf93de92aa4a2f73"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aad78346252bf890fbf93de92aa4a2f73">souffle::escape</a> (const std::string &amp;inputString, const std::string &amp;needle, const std::string &amp;replacement)</td></tr>
<tr class="separator:aad78346252bf890fbf93de92aa4a2f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b2a40d0e298261a99b89c04424ed56"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a57b2a40d0e298261a99b89c04424ed56">souffle::escape</a> (const std::string &amp;inputString)</td></tr>
<tr class="separator:a57b2a40d0e298261a99b89c04424ed56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1056c0ab323cd2951500d84bea3c0aa1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1056c0ab323cd2951500d84bea3c0aa1">souffle::escapeJSONstring</a> (const std::string &amp;JSONstr)</td></tr>
<tr class="memdesc:a1056c0ab323cd2951500d84bea3c0aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape JSON string.  <a href="namespacesouffle.html#a1056c0ab323cd2951500d84bea3c0aa1">More...</a><br /></td></tr>
<tr class="separator:a1056c0ab323cd2951500d84bea3c0aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e22287be4345c05c5f70b1d37eaec77"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a5e22287be4345c05c5f70b1d37eaec77">souffle::execStdOut</a> (char const *cmd)</td></tr>
<tr class="separator:a5e22287be4345c05c5f70b1d37eaec77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720784b780e625da862d7f7f127f7afb"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a720784b780e625da862d7f7f127f7afb">souffle::execStdOut</a> (std::string const &amp;cmd)</td></tr>
<tr class="separator:a720784b780e625da862d7f7f127f7afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fa4170c4094bc943de6fa5acb5796e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a79fa4170c4094bc943de6fa5acb5796e">souffle::existDir</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a79fa4170c4094bc943de6fa5acb5796e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a directory exists in the file system.  <a href="namespacesouffle.html#a79fa4170c4094bc943de6fa5acb5796e">More...</a><br /></td></tr>
<tr class="separator:a79fa4170c4094bc943de6fa5acb5796e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69107e934a60222580ee8ba6882dc3d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">souffle::existFile</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a69107e934a60222580ee8ba6882dc3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a file exists in the file system.  <a href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">More...</a><br /></td></tr>
<tr class="separator:a69107e934a60222580ee8ba6882dc3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3419b4e4df09a580063d2f078a3774"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8e3419b4e4df09a580063d2f078a3774">souffle::fileExtension</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a8e3419b4e4df09a580063d2f078a3774"><td class="mdescLeft">&#160;</td><td class="mdescRight">File extension, with all else removed.  <a href="namespacesouffle.html#a8e3419b4e4df09a580063d2f078a3774">More...</a><br /></td></tr>
<tr class="separator:a8e3419b4e4df09a580063d2f078a3774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af944f0c474df29e5c8e45e4b7df60be5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af944f0c474df29e5c8e45e4b7df60be5">souffle::findTool</a> (const std::string &amp;tool, const std::string &amp;<a class="el" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a>, const std::string &amp;path)</td></tr>
<tr class="separator:af944f0c474df29e5c8e45e4b7df60be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f80c157a6a365d78a43592732a8efa"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a62f80c157a6a365d78a43592732a8efa"><td class="memTemplItemLeft" align="right" valign="top">C::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa">souffle::getIf</a> (const C &amp;container, std::function&lt; bool(const typename C::value_type)&gt; pred)</td></tr>
<tr class="memdesc:a62f80c157a6a365d78a43592732a8efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element in a container that satisfies a given predicate, nullptr otherwise.  <a href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa">More...</a><br /></td></tr>
<tr class="separator:a62f80c157a6a365d78a43592732a8efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48147c448827024d87c8fd8797470196"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a48147c448827024d87c8fd8797470196"><td class="memTemplItemLeft" align="right" valign="top">C::mapped_type const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a48147c448827024d87c8fd8797470196">souffle::getOr</a> (const C &amp;container, typename C::key_type key, const typename C::mapped_type &amp;defaultValue)</td></tr>
<tr class="memdesc:a48147c448827024d87c8fd8797470196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value for a given key; if not found, return default value.  <a href="namespacesouffle.html#a48147c448827024d87c8fd8797470196">More...</a><br /></td></tr>
<tr class="separator:a48147c448827024d87c8fd8797470196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e8debde5608979e041dd30e044612a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad0e8debde5608979e041dd30e044612a">souffle::identifier</a> (std::string id)</td></tr>
<tr class="memdesc:ad0e8debde5608979e041dd30e044612a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valid C++ identifier, note that this does not ensure the uniqueness of identifiers returned.  <a href="namespacesouffle.html#ad0e8debde5608979e041dd30e044612a">More...</a><br /></td></tr>
<tr class="separator:ad0e8debde5608979e041dd30e044612a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64753e143a37bb9414121fc75987cb14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">souffle::isExecutable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a64753e143a37bb9414121fc75987cb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a given file exists and it is an executable.  <a href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">More...</a><br /></td></tr>
<tr class="separator:a64753e143a37bb9414121fc75987cb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56909036ae0514924e306d0a1a180837"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a56909036ae0514924e306d0a1a180837">souffle::isNumber</a> (const char *<a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>)</td></tr>
<tr class="memdesc:a56909036ae0514924e306d0a1a180837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a string is a sequence of digits.  <a href="namespacesouffle.html#a56909036ae0514924e306d0a1a180837">More...</a><br /></td></tr>
<tr class="separator:a56909036ae0514924e306d0a1a180837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fd86fe230c58e924db2cf47e1ba5e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0">souffle::isPrefix</a> (const std::string &amp;prefix, const std::string &amp;element)</td></tr>
<tr class="memdesc:ab9fd86fe230c58e924db2cf47e1ba5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if one string is a prefix of another.  <a href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0">More...</a><br /></td></tr>
<tr class="separator:ab9fd86fe230c58e924db2cf47e1ba5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4e3f19879707216a2758b03f4e2deb"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename Printer &gt; </td></tr>
<tr class="memitem:abe4e3f19879707216a2758b03f4e2deb"><td class="memTemplItemLeft" align="right" valign="top">detail::joined_sequence&lt; Iter, Printer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">souffle::join</a> (const Iter &amp;a, const Iter &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, const std::string &amp;sep, const Printer &amp;<a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:abe4e3f19879707216a2758b03f4e2deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object to be forwarded to some output stream for printing sequences of elements interspersed by a given separator.  <a href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">More...</a><br /></td></tr>
<tr class="separator:abe4e3f19879707216a2758b03f4e2deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff8ab73e5403aebf8bc9e0cd8a17655"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename T  = typename Iter::value_type&gt; </td></tr>
<tr class="memitem:a2ff8ab73e5403aebf8bc9e0cd8a17655"><td class="memTemplItemLeft" align="right" valign="top">detail::joined_sequence&lt; Iter, detail::print&lt; id&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2ff8ab73e5403aebf8bc9e0cd8a17655">souffle::join</a> (const Iter &amp;a, const Iter &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, const std::string &amp;sep=&quot;,&quot;)</td></tr>
<tr class="memdesc:a2ff8ab73e5403aebf8bc9e0cd8a17655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object to be forwarded to some output stream for printing sequences of elements interspersed by a given separator.  <a href="namespacesouffle.html#a2ff8ab73e5403aebf8bc9e0cd8a17655">More...</a><br /></td></tr>
<tr class="separator:a2ff8ab73e5403aebf8bc9e0cd8a17655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5411f3812147edc8be88140d80308bd"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Printer , typename Iter  = typename Container::const_iterator&gt; </td></tr>
<tr class="memitem:af5411f3812147edc8be88140d80308bd"><td class="memTemplItemLeft" align="right" valign="top">detail::joined_sequence&lt; Iter, Printer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af5411f3812147edc8be88140d80308bd">souffle::join</a> (const Container &amp;c, const std::string &amp;sep, const Printer &amp;<a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:af5411f3812147edc8be88140d80308bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object to be forwarded to some output stream for printing the content of containers interspersed by a given separator.  <a href="namespacesouffle.html#af5411f3812147edc8be88140d80308bd">More...</a><br /></td></tr>
<tr class="separator:af5411f3812147edc8be88140d80308bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f126a2c7d2ee710ec8600b2af64da3"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Iter  = typename Container::const_iterator, typename T  = typename Iter::value_type&gt; </td></tr>
<tr class="memitem:af2f126a2c7d2ee710ec8600b2af64da3"><td class="memTemplItemLeft" align="right" valign="top">detail::joined_sequence&lt; Iter, detail::print&lt; id&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">souffle::join</a> (const Container &amp;c, const std::string &amp;sep=&quot;,&quot;)</td></tr>
<tr class="memdesc:af2f126a2c7d2ee710ec8600b2af64da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object to be forwarded to some output stream for printing the content of containers interspersed by a given separator.  <a href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">More...</a><br /></td></tr>
<tr class="separator:af2f126a2c7d2ee710ec8600b2af64da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea8a37cc1681f657054f3b30af55003"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:acea8a37cc1681f657054f3b30af55003"><td class="memTemplItemLeft" align="right" valign="top">range&lt; Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">souffle::make_range</a> (const Iter &amp;a, const Iter &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:acea8a37cc1681f657054f3b30af55003"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the construction of ranges without explicitly specifying the iterator type.  <a href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">More...</a><br /></td></tr>
<tr class="separator:acea8a37cc1681f657054f3b30af55003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ec690ba482fd3a9692b5e31f6ad347"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:af4ec690ba482fd3a9692b5e31f6ad347"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af4ec690ba482fd3a9692b5e31f6ad347">souffle::none_of</a> (const Container &amp;c, UnaryPredicate <a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:af4ec690ba482fd3a9692b5e31f6ad347"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic test checking whether all elements within a container satisfy a certain predicate.  <a href="namespacesouffle.html#af4ec690ba482fd3a9692b5e31f6ad347">More...</a><br /></td></tr>
<tr class="separator:af4ec690ba482fd3a9692b5e31f6ad347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c65551944c7ecf6f44ec851b49bdbb0"><td class="memItemLeft" align="right" valign="top">time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">souffle::now</a> ()</td></tr>
<tr class="separator:a1c65551944c7ecf6f44ec851b49bdbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6007ce16b81c3fdec0c880158b23724f"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a6007ce16b81c3fdec0c880158b23724f"><td class="memTemplItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestd.html#a6007ce16b81c3fdec0c880158b23724f">std::operator&lt;&lt;</a> (ostream &amp;out, const pair&lt; A, B &gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:a6007ce16b81c3fdec0c880158b23724f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduces support for printing pairs as long as their components can be printed.  <a href="namespacestd.html#a6007ce16b81c3fdec0c880158b23724f">More...</a><br /></td></tr>
<tr class="separator:a6007ce16b81c3fdec0c880158b23724f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d19261c7952cc862dfc6a3772c0f9af"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a3d19261c7952cc862dfc6a3772c0f9af"><td class="memTemplItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestd.html#a3d19261c7952cc862dfc6a3772c0f9af">std::operator&lt;&lt;</a> (ostream &amp;out, const vector&lt; T, A &gt; &amp;v)</td></tr>
<tr class="memdesc:a3d19261c7952cc862dfc6a3772c0f9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the generic printing of vectors assuming their element types are printable.  <a href="namespacestd.html#a3d19261c7952cc862dfc6a3772c0f9af">More...</a><br /></td></tr>
<tr class="separator:a3d19261c7952cc862dfc6a3772c0f9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f5c175f65d86392baae03362443f7b"><td class="memTemplParams" colspan="2">template&lt;typename K , typename C , typename A &gt; </td></tr>
<tr class="memitem:a24f5c175f65d86392baae03362443f7b"><td class="memTemplItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestd.html#a24f5c175f65d86392baae03362443f7b">std::operator&lt;&lt;</a> (ostream &amp;out, const set&lt; K, C, A &gt; &amp;s)</td></tr>
<tr class="memdesc:a24f5c175f65d86392baae03362443f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the generic printing of sets assuming their element types are printable.  <a href="namespacestd.html#a24f5c175f65d86392baae03362443f7b">More...</a><br /></td></tr>
<tr class="separator:a24f5c175f65d86392baae03362443f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02df97e37b3af7690816a8097e6f4740"><td class="memTemplParams" colspan="2">template&lt;typename K , typename T , typename C , typename A &gt; </td></tr>
<tr class="memitem:a02df97e37b3af7690816a8097e6f4740"><td class="memTemplItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestd.html#a02df97e37b3af7690816a8097e6f4740">std::operator&lt;&lt;</a> (ostream &amp;out, const map&lt; K, T, C, A &gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a9e77e016b2928d7dcb493b89a0c9dc32">m</a>)</td></tr>
<tr class="memdesc:a02df97e37b3af7690816a8097e6f4740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the generic printing of maps assuming their element types are printable.  <a href="namespacestd.html#a02df97e37b3af7690816a8097e6f4740">More...</a><br /></td></tr>
<tr class="separator:a02df97e37b3af7690816a8097e6f4740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfb7f5671f38232db9a50606d07fe04"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned size&gt; </td></tr>
<tr class="memitem:a9dfb7f5671f38232db9a50606d07fe04"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9dfb7f5671f38232db9a50606d07fe04">souffle::operator&lt;&lt;</a> (std::ostream &amp;out, const LRUCache&lt; T, size &gt; &amp;cache)</td></tr>
<tr class="separator:a9dfb7f5671f38232db9a50606d07fe04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168e2fae5a34ddc5215c94d27893a7ff"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a168e2fae5a34ddc5215c94d27893a7ff">souffle::pathJoin</a> (const std::string &amp;first, const std::string &amp;second)</td></tr>
<tr class="memdesc:a168e2fae5a34ddc5215c94d27893a7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join two paths together; note that this does not resolve overlaps or relative paths.  <a href="namespacesouffle.html#a168e2fae5a34ddc5215c94d27893a7ff">More...</a><br /></td></tr>
<tr class="separator:a168e2fae5a34ddc5215c94d27893a7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f50e44c16d45c78e4a37b005ac94c9"><td class="memItemLeft" align="right" valign="top">RamFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a42f50e44c16d45c78e4a37b005ac94c9">souffle::RamFloatFromString</a> (const std::string &amp;<a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, std::size_t *position=nullptr)</td></tr>
<tr class="memdesc:a42f50e44c16d45c78e4a37b005ac94c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to a RamFloat.  <a href="namespacesouffle.html#a42f50e44c16d45c78e4a37b005ac94c9">More...</a><br /></td></tr>
<tr class="separator:a42f50e44c16d45c78e4a37b005ac94c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad354d1210c639429c093f92ba2966a75"><td class="memItemLeft" align="right" valign="top">RamSigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad354d1210c639429c093f92ba2966a75">souffle::RamSignedFromString</a> (const std::string &amp;<a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, std::size_t *position=nullptr, const int <a class="el" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a>=10)</td></tr>
<tr class="memdesc:ad354d1210c639429c093f92ba2966a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to a RamSigned.  <a href="namespacesouffle.html#ad354d1210c639429c093f92ba2966a75">More...</a><br /></td></tr>
<tr class="separator:ad354d1210c639429c093f92ba2966a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084bbb9535fee35e4682c948ce88bddb"><td class="memItemLeft" align="right" valign="top">RamUnsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a084bbb9535fee35e4682c948ce88bddb">souffle::RamUnsignedFromString</a> (const std::string &amp;<a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, std::size_t *position=nullptr, const int <a class="el" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a>=10)</td></tr>
<tr class="memdesc:a084bbb9535fee35e4682c948ce88bddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to a RamUnsigned.  <a href="namespacesouffle.html#a084bbb9535fee35e4682c948ce88bddb">More...</a><br /></td></tr>
<tr class="separator:a084bbb9535fee35e4682c948ce88bddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31e06999eb72da2f6d9a85bdd3dda59"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab31e06999eb72da2f6d9a85bdd3dda59">souffle::simpleName</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:ab31e06999eb72da2f6d9a85bdd3dda59"><td class="mdescLeft">&#160;</td><td class="mdescRight">File name, with extension removed.  <a href="namespacesouffle.html#ab31e06999eb72da2f6d9a85bdd3dda59">More...</a><br /></td></tr>
<tr class="separator:ab31e06999eb72da2f6d9a85bdd3dda59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673608e9453179d30f6607384f54463a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a673608e9453179d30f6607384f54463a">souffle::splitString</a> (const std::string &amp;<a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, char delimiter)</td></tr>
<tr class="memdesc:a673608e9453179d30f6607384f54463a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string given a delimiter.  <a href="namespacesouffle.html#a673608e9453179d30f6607384f54463a">More...</a><br /></td></tr>
<tr class="separator:a673608e9453179d30f6607384f54463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f428910159c119c1dcdcab76ab7dfa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a06f428910159c119c1dcdcab76ab7dfa">souffle::stringify</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:a06f428910159c119c1dcdcab76ab7dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stringify a string using escapes for newline, tab, double-quotes and semicolons.  <a href="namespacesouffle.html#a06f428910159c119c1dcdcab76ab7dfa">More...</a><br /></td></tr>
<tr class="separator:a06f428910159c119c1dcdcab76ab7dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2122cfa5acdee4846ecda0855f0beee4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2122cfa5acdee4846ecda0855f0beee4">souffle::tempFile</a> ()</td></tr>
<tr class="memdesc:a2122cfa5acdee4846ecda0855f0beee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate temporary file.  <a href="namespacesouffle.html#a2122cfa5acdee4846ecda0855f0beee4">More...</a><br /></td></tr>
<tr class="separator:a2122cfa5acdee4846ecda0855f0beee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fff2be077dd5d1105f3a6e718339f2f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0fff2be077dd5d1105f3a6e718339f2f"><td class="memTemplItemLeft" align="right" valign="top">detail::multiplying_printer&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f">souffle::times</a> (const T &amp;value, unsigned num)</td></tr>
<tr class="memdesc:a0fff2be077dd5d1105f3a6e718339f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility printing a given value multiple times.  <a href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f">More...</a><br /></td></tr>
<tr class="separator:a0fff2be077dd5d1105f3a6e718339f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62d4e824a9d74c7462da546a21780fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad62d4e824a9d74c7462da546a21780fe"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe">souffle::toPtrVector</a> (const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:ad62d4e824a9d74c7462da546a21780fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a vector of pointers.  <a href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe">More...</a><br /></td></tr>
<tr class="separator:ad62d4e824a9d74c7462da546a21780fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc08c83ad9634fc515b7aa094702949"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">souffle::toString</a> (const std::string &amp;<a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>)</td></tr>
<tr class="memdesc:aecc08c83ad9634fc515b7aa094702949"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic function converting strings into strings (trivial case).  <a href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">More...</a><br /></td></tr>
<tr class="separator:aecc08c83ad9634fc515b7aa094702949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f01b6b803d03b90d7f33df9351ade"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aac0f01b6b803d03b90d7f33df9351ade"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; detail::is_printable&lt; T &gt;::value, std::string &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aac0f01b6b803d03b90d7f33df9351ade">souffle::toString</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aac0f01b6b803d03b90d7f33df9351ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic function converting arbitrary objects to strings by utilizing their print capability.  <a href="namespacesouffle.html#aac0f01b6b803d03b90d7f33df9351ade">More...</a><br /></td></tr>
<tr class="separator:aac0f01b6b803d03b90d7f33df9351ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde2b7fb9746dae19cf74319c353aa52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afde2b7fb9746dae19cf74319c353aa52"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!detail::is_printable&lt; T &gt;::value, std::string &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#afde2b7fb9746dae19cf74319c353aa52">souffle::toString</a> (const T &amp;)</td></tr>
<tr class="memdesc:afde2b7fb9746dae19cf74319c353aa52"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fallback for the to-string function in case an unprintable object is supposed to be printed.  <a href="namespacesouffle.html#afde2b7fb9746dae19cf74319c353aa52">More...</a><br /></td></tr>
<tr class="separator:afde2b7fb9746dae19cf74319c353aa52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2822ded4e7fd1466479b3fd6a1345a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2822ded4e7fd1466479b3fd6a1345a0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab2822ded4e7fd1466479b3fd6a1345a0">souffle::toVector</a> ()</td></tr>
<tr class="memdesc:ab2822ded4e7fd1466479b3fd6a1345a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a vector with a fixed set of elements within a single expression.  <a href="namespacesouffle.html#ab2822ded4e7fd1466479b3fd6a1345a0">More...</a><br /></td></tr>
<tr class="separator:ab2822ded4e7fd1466479b3fd6a1345a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae771492463067508eb07c2113550097e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... R&gt; </td></tr>
<tr class="memitem:ae771492463067508eb07c2113550097e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae771492463067508eb07c2113550097e">souffle::toVector</a> (const T &amp;first, const R &amp;... rest)</td></tr>
<tr class="memdesc:ae771492463067508eb07c2113550097e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a vector with a fixed set of elements within a single expression.  <a href="namespacesouffle.html#ae771492463067508eb07c2113550097e">More...</a><br /></td></tr>
<tr class="separator:ae771492463067508eb07c2113550097e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b370fe6877c2777646f7fad4aad0cb2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6b370fe6877c2777646f7fad4aad0cb2">souffle::unescape</a> (const std::string &amp;inputString, const std::string &amp;needle, const std::string &amp;replacement)</td></tr>
<tr class="separator:a6b370fe6877c2777646f7fad4aad0cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20932ae365326d8c0d9bd06f6ea09781"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a20932ae365326d8c0d9bd06f6ea09781">souffle::unescape</a> (const std::string &amp;inputString)</td></tr>
<tr class="separator:a20932ae365326d8c0d9bd06f6ea09781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9757564e85959db8b14a9be7d544e1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6e9757564e85959db8b14a9be7d544e1">souffle::which</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a6e9757564e85959db8b14a9be7d544e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple implementation of a which tool.  <a href="namespacesouffle.html#a6e9757564e85959db8b14a9be7d544e1">More...</a><br /></td></tr>
<tr class="separator:a6e9757564e85959db8b14a9be7d544e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
