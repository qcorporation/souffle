<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>souffle: souffle Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">souffle
   &#160;<span id="projectnumber">e23420a</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">souffle Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Souffle - A Datalog Compiler Copyright (c) 2013, 2015, Oracle and/or its affiliates.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesouffle_1_1column__utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1column__utils.html">column_utils</a></td></tr>
<tr class="memdesc:namespacesouffle_1_1column__utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace enclosing template-meta-programming utilities for handling parameter lists for templates. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesouffle_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesouffle_1_1gzfstream"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1gzfstream.html">gzfstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesouffle_1_1index__utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1index__utils.html">index_utils</a></td></tr>
<tr class="memdesc:namespacesouffle_1_1index__utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace enclosing utilities required by indices. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesouffle_1_1profile"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1profile.html">profile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_adorned_clause.html">AdornedClause</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_adorned_predicate.html">AdornedPredicate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_adornment.html">Adornment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_assignment.html">Assignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An assignment maps a list of variables to values of their respective property space.  <a href="classsouffle_1_1_assignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1ast__visitor__tag.html">ast_visitor_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag type required for the is_ast_visitor type trait to identify AstVisitors.  <a href="structsouffle_1_1ast__visitor__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_aggregator.html">AstAggregator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An argument aggregating a value from a sub-query.  <a href="classsouffle_1_1_ast_aggregator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_analysis.html">AstAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for a AST Analysis.  <a href="classsouffle_1_1_ast_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument.  <a href="classsouffle_1_1_ast_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of Literal that represents the use of a relation either in the head or in the body of a Clause, e.g., parent(x,y).  <a href="classsouffle_1_1_ast_atom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_attribute.html">AstAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate representation of an attribute which stores the name and the type of an attribute.  <a href="classsouffle_1_1_ast_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_binary_constraint.html">AstBinaryConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of <a class="el" href="classsouffle_1_1_constraint.html" title="A generic base class for constraints on variables. ">Constraint</a> that represents a binary constraint e.g., x = y.  <a href="classsouffle_1_1_ast_binary_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_boolean_constraint.html">AstBooleanConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean <a class="el" href="classsouffle_1_1_constraint.html" title="A generic base class for constraints on variables. ">Constraint</a>.  <a href="classsouffle_1_1_ast_boolean_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate representation of a datalog clause.  <a href="classsouffle_1_1_ast_clause.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_component.html">AstComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A AST node describing a component within the input program.  <a href="classsouffle_1_1_ast_component.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_component_checker.html">AstComponentChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_component_init.html">AstComponentInit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component intialization.  <a href="classsouffle_1_1_ast_component_init.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_component_type.html">AstComponentType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component type is.  <a href="classsouffle_1_1_ast_component_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_constant.html">AstConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract Constant.  <a href="classsouffle_1_1_ast_constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_constraint.html">AstConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical constraint.  <a href="classsouffle_1_1_ast_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_counter.html">AstCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter.  <a href="classsouffle_1_1_ast_counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_execution_order.html">AstExecutionOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An execution order for atoms within a clause.  <a href="classsouffle_1_1_ast_execution_order.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_execution_plan.html">AstExecutionPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class utilized to model user-defined execution plans for various versions of clauses.  <a href="classsouffle_1_1_ast_execution_plan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_execution_plan_checker.html">AstExecutionPlanChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_functor.html">AstFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor class.  <a href="classsouffle_1_1_ast_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_functor_declaration.html">AstFunctorDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_ast_functor_declaration.html" title="AstFunctorDeclaration. ">AstFunctorDeclaration</a>.  <a href="classsouffle_1_1_ast_functor_declaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_intrinsic_functor.html">AstIntrinsicFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic Functor.  <a href="classsouffle_1_1_ast_intrinsic_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_i_o.html">AstIO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O operation has a type (input/output/printsize), qualified relation name, and I/O directives.  <a href="classsouffle_1_1_ast_i_o.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Literal e.g.  <a href="classsouffle_1_1_ast_literal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_ast_name_comparison.html">AstNameComparison</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical order for <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> using the qualified name as an ordering criteria.  <a href="structsouffle_1_1_ast_name_comparison.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_negation.html">AstNegation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of Literal that represents a negated atom, * e.g., !parent(x,y).  <a href="classsouffle_1_1_ast_negation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_nil_constant.html">AstNilConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nil Constant.  <a href="classsouffle_1_1_ast_nil_constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for syntactic elements in a Datalog program.  <a href="classsouffle_1_1_ast_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_node_mapper.html">AstNodeMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class for manipulating AST Nodes by substitution.  <a href="classsouffle_1_1_ast_node_mapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_numeric_constant.html">AstNumericConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numeric Constant.  <a href="classsouffle_1_1_ast_numeric_constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_pragma.html">AstPragma</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a global option.  <a href="classsouffle_1_1_ast_pragma.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_pragma_checker.html">AstPragmaChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_profile_use.html">AstProfileUse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_ast_analysis.html" title="Abstract class for a AST Analysis. ">AstAnalysis</a> that loads profile data and has a profile query interface.  <a href="classsouffle_1_1_ast_profile_use.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate representation of a datalog program that consists of relations, clauses and types.  <a href="classsouffle_1_1_ast_program.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_provenance_negation.html">AstProvenanceNegation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of Literal that represents a negated atom, * e.g., !parent(x,y).  <a href="classsouffle_1_1_ast_provenance_negation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Qualified Name class for fully/partially qualified names to identify objects in components.  <a href="classsouffle_1_1_ast_qualified_name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_record_init.html">AstRecordInit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record.  <a href="classsouffle_1_1_ast_record_init.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_record_type.html">AstRecordType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A record type aggregates a list of fields into a new type.  <a href="classsouffle_1_1_ast_record_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_semantic_checker.html">AstSemanticChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_string_constant.html">AstStringConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String Constant.  <a href="classsouffle_1_1_ast_string_constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_subroutine_argument.html">AstSubroutineArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subroutine Argument.  <a href="classsouffle_1_1_ast_subroutine_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_subset_type.html">AstSubsetType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A subset type is named type that can either be a sub-type of the predefined types (float/unsigned/number/symbol).  <a href="classsouffle_1_1_ast_subset_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_term.html">AstTerm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract Term.  <a href="classsouffle_1_1_ast_term.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_transformer.html">AstTransformer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_translation_unit.html">AstTranslationUnit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_ast_translation_unit.html" title="AstTranslationUnit class. ">AstTranslationUnit</a> class.  <a href="classsouffle_1_1_ast_translation_unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_translator.html">AstTranslator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main class for AST Translator.  <a href="classsouffle_1_1_ast_translator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_type.html">AstType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_type_cast.html">AstTypeCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An argument capable of casting a value of one type into another.  <a href="classsouffle_1_1_ast_type_cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_union_type.html">AstUnionType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A union type combines multiple types into a new super type.  <a href="classsouffle_1_1_ast_union_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_unnamed_variable.html">AstUnnamedVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unnamed <a class="el" href="structsouffle_1_1_variable.html" title="A variable to be utilized within constraints to be handled by the constraint solver. ">Variable</a>.  <a href="classsouffle_1_1_ast_unnamed_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_user_defined_functor.html">AstUserDefinedFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-Defined Functor.  <a href="classsouffle_1_1_ast_user_defined_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_user_defined_functors_transformer.html">AstUserDefinedFunctorsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation that passes the type information from user functors declaration to functors instances.  <a href="classsouffle_1_1_ast_user_defined_functors_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ast_variable.html">AstVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Named <a class="el" href="structsouffle_1_1_variable.html" title="A variable to be utilized within constraints to be handled by the constraint solver. ">Variable</a>.  <a href="classsouffle_1_1_ast_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_ast_visitor.html">AstVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic base type of all AstVisitors realizing the dispatching of visitor calls.  <a href="structsouffle_1_1_ast_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_auxiliary_arity.html">AuxiliaryArity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the auxiliary arity for relations.  <a href="classsouffle_1_1_auxiliary_arity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_base_table.html">BaseTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_brie_index.html">BrieIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A index adapter for Bries, using the generic index adapter.  <a href="classsouffle_1_1_brie_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1btree__multiset.html">btree_multiset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A b-tree based multi-set implementation.  <a href="classsouffle_1_1btree__multiset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1btree__set.html">btree_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A b-tree based set implementation.  <a href="classsouffle_1_1btree__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_b_tree_index.html">BTreeIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A index adapter for B-trees, using the generic index adapter.  <a href="classsouffle_1_1_b_tree_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_b_tree_provenance_index.html">BTreeProvenanceIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Btree index for provenance relation.  <a href="classsouffle_1_1_b_tree_provenance_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_cache_access_counter.html">CacheAccessCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">cache hits/misses.  <a href="classsouffle_1_1_cache_access_counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_choice_conversion_transformer.html">ChoiceConversionTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert (Scan/If)/(IndexScan/If) operaitons to (Choice)/(IndexChoice) operations.  <a href="classsouffle_1_1_choice_conversion_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_cmd_options.html">CmdOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for parsing command line arguments within generated query programs.  <a href="classsouffle_1_1_cmd_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_collapse_filters_transformer.html">CollapseFiltersTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms consecutive filters into a single filter containing a conjunction.  <a href="classsouffle_1_1_collapse_filters_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1comp__deref.html">comp_deref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor class supporting the values pointers are pointing to.  <a href="structsouffle_1_1comp__deref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_component_instantiation_transformer.html">ComponentInstantiationTransformer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_component_lookup.html">ComponentLookup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_conditional_transformer.html">ConditionalTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformer that executes a sub-transformer iff a condition holds.  <a href="classsouffle_1_1_conditional_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_const_constraint.html">ConstConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant constraints for values in query command.  <a href="classsouffle_1_1_const_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_constraint.html">Constraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic base class for constraints on variables.  <a href="classsouffle_1_1_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_debug_report.html">DebugReport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a HTML report, consisting of a list of sections.  <a href="classsouffle_1_1_debug_report.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_debug_reporter.html">DebugReporter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass which wraps another transformation pass and generates a debug report section for the stage after applying the wrapped transformer, and adds it to the translation unit's debug report.  <a href="classsouffle_1_1_debug_reporter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_debug_report_section.html">DebugReportSection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a section of a HTML report.  <a href="classsouffle_1_1_debug_report_section.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1deref.html">deref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor dereferencing a given type.  <a href="structsouffle_1_1deref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1deref__less.html">deref_less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor comparing the dereferenced value of a pointer type utilizing a given comparator.  <a href="structsouffle_1_1deref__less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_diagnostic.html">Diagnostic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_diagnostic_message.html">DiagnosticMessage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_disjoint_set.html">DisjointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that emulates a Disjoint Set, i.e.  <a href="classsouffle_1_1_disjoint_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_dyn_tuple.html">DynTuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A construction-time sized tuple instance easing tuple handling in non-compiled contexts.  <a href="classsouffle_1_1_dyn_tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_eliminate_duplicates_transformer.html">EliminateDuplicatesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates duplicated conjunctive terms.  <a href="classsouffle_1_1_eliminate_duplicates_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_eqrel_index.html">EqrelIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A index adapter for <a class="el" href="classsouffle_1_1_equivalence_relation.html">EquivalenceRelation</a>, using the generic index adapter.  <a href="classsouffle_1_1_eqrel_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_eqrel_map_comparator.html">EqrelMapComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence.html">Equivalence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_equivalence.html" title="Equivalence class for variables in query command. ">Equivalence</a> class for variables in query command.  <a href="classsouffle_1_1_equivalence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_equivalence_relation.html">EquivalenceRelation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_error_report.html">ErrorReport</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_expand_filter_transformer.html">ExpandFilterTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms RamConjunctions into consecutive filter operations.  <a href="classsouffle_1_1_expand_filter_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_explain.html">Explain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_explain_config.html">ExplainConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_explain_provenance.html">ExplainProvenance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_explain_provenance_impl.html">ExplainProvenanceImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_fixpoint_transformer.html">FixpointTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformer that repeatedly executes a sub-transformer until no changes are made.  <a href="classsouffle_1_1_fixpoint_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_fold_anonymous_records.html">FoldAnonymousRecords</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass that removes (binary) constraints on the anonymous records.  <a href="classsouffle_1_1_fold_anonymous_records.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_generic_index.html">GenericIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic data structure index adapter handling the boundary level order conversion as well as iteration through nested data structures.  <a href="classsouffle_1_1_generic_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_global.html">Global</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple graph structure for graph-based operations.  <a href="classsouffle_1_1_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_hoist_aggregate_transformer.html">HoistAggregateTransformer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_hoist_conditions_transformer.html">HoistConditionsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hosts conditions in a loop-nest to the most-outer/semantically-correct loop.  <a href="classsouffle_1_1_hoist_conditions_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1id.html">id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor representing the identity function for a generic type T.  <a href="structsouffle_1_1id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_if_conversion_transformer.html">IfConversionTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert IndexScan operations to Filter/Existence Checks.  <a href="classsouffle_1_1_if_conversion_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1index.html">index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index class is utilized as a template-meta-programming structure to specify and realize indices.  <a href="structsouffle_1_1index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_index_view.html">IndexView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A view on a relation caching local access patterns (not thread safe!).  <a href="classsouffle_1_1_index_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_indirect_index.html">IndirectIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_inline_relations_transformer.html">InlineRelationsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to inline marked relations.  <a href="classsouffle_1_1_inline_relations_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_inner_node.html">InnerNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_context.html">InterpreterContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation context for Interpreter operations.  <a href="classsouffle_1_1_interpreter_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_engine.html">InterpreterEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class translate the RAM Program into executable format and interpreter it.  <a href="classsouffle_1_1_interpreter_engine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_eq_relation.html">InterpreterEqRelation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpreter <a class="el" href="classsouffle_1_1_equivalence.html" title="Equivalence class for variables in query command. ">Equivalence</a> <a class="el" href="classsouffle_1_1_relation.html" title="Object-oriented wrapper class for Souffle&#39;s templatized relations. ">Relation</a>.  <a href="classsouffle_1_1_interpreter_eq_relation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_index.html">InterpreterIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An index is an abstraction of a data structure.  <a href="classsouffle_1_1_interpreter_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_indirect_relation.html">InterpreterIndirectRelation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpreter Indirect <a class="el" href="classsouffle_1_1_relation.html" title="Object-oriented wrapper class for Souffle&#39;s templatized relations. ">Relation</a>.  <a href="classsouffle_1_1_interpreter_indirect_relation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_node.html">InterpreterNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a shadow node for a <a class="el" href="classsouffle_1_1_ram_node.html" title="RamNode is a superclass for all RAM IR classes. ">RamNode</a> that is enriched for with local information so that the interpreter is executing quickly.  <a href="classsouffle_1_1_interpreter_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_preamble.html">InterpreterPreamble</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains information for views (Hints) creation for <a class="el" href="classsouffle_1_1_ram_query.html" title="A relational algebra query. ">RamQuery</a> and <a class="el" href="classsouffle_1_1_ram_parallel.html" title="Parallel block of statements. ">RamParallel</a> operation.  <a href="classsouffle_1_1_interpreter_preamble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_prog_interface.html">InterpreterProgInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="classsouffle_1_1_souffle_program.html" title="Abstract base class for generated Datalog programs. ">SouffleProgram</a> interface for an interpreter instance.  <a href="classsouffle_1_1_interpreter_prog_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_interpreter_provenance_updater.html">InterpreterProvenanceUpdater</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_relation.html">InterpreterRelation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A relation, composed of a collection of indexes.  <a href="classsouffle_1_1_interpreter_relation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_interpreter_rel_interface.html">InterpreterRelInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for interpreter relations.  <a href="classsouffle_1_1_interpreter_rel_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_i_o_system.html">IOSystem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_i_o_type.html">IOType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_iter_deref_wrapper.html">IterDerefWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for an iterator obtaining pointers of a certain type, dereferencing values before forwarding them to the consumer.  <a href="structsouffle_1_1_iter_deref_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1lambda__traits.html">lambda_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait enabling the deduction of type properties of lambdas.  <a href="structsouffle_1_1lambda__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_lambda_b_tree_set.html">LambdaBTreeSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A b-tree based set implementation.  <a href="classsouffle_1_1_lambda_b_tree_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_lambda_ram_node_mapper.html">LambdaRamNodeMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special <a class="el" href="classsouffle_1_1_ram_node_mapper.html" title="An abstract class for manipulating RAM Nodes by substitution. ">RamNodeMapper</a> wrapping a lambda conducting node transformations.  <a href="classsouffle_1_1_lambda_ram_node_mapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_leaf_node.html">LeafNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_lock.html">Lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small utility class for implementing simple locks.  <a href="structsouffle_1_1_lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class utilized to times for the souffle profiling tool.  <a href="classsouffle_1_1_logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_log_statement.html">LogStatement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_l_r_u_cache.html">LRUCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Least-Recently-Used cache for arbitrary element types.  <a href="classsouffle_1_1_l_r_u_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_l_r_u_cache_3_01_t_00_010_01_4.html">LRUCache&lt; T, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_l_r_u_cache_3_01_t_00_011_01_4.html">LRUCache&lt; T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_magic_set_transformer.html">MagicSetTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic Set Transformation.  <a href="classsouffle_1_1_magic_set_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_main_config.html">MainConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_main_option.html">MainOption</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_make_index_transformer.html">MakeIndexTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make indexable operations to indexed operations.  <a href="classsouffle_1_1_make_index_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_materialize_aggregation_queries_transformer.html">MaterializeAggregationQueriesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to create artificial relations for bodies of aggregation functions consisting of more than a single atom.  <a href="classsouffle_1_1_materialize_aggregation_queries_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_max_matching.html">MaxMatching</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a maximum matching with Hopcroft-Karp algorithm  <a href="classsouffle_1_1_max_matching.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_meta_transformer.html">MetaTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformer that coordinates other sub-transformations.  <a href="classsouffle_1_1_meta_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_minimise_program_transformer.html">MinimiseProgramTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove equivalent rules.  <a href="classsouffle_1_1_minimise_program_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_min_index_selection.html">MinIndexSelection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the minimal index cover for a relation in a RAM Program.  <a href="classsouffle_1_1_min_index_selection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_name_unnamed_variables_transformer.html">NameUnnamedVariablesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to replace unnamed variables with singletons.  <a href="classsouffle_1_1_name_unnamed_variables_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_node_generator.html">NodeGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_normalise_constraints_transformer.html">NormaliseConstraintsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to normalise constraints.  <a href="classsouffle_1_1_normalise_constraints_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_nullary_index.html">NullaryIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An index wrapper for nullary indexes.  <a href="classsouffle_1_1_nullary_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_null_transformer.html">NullTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformer that does absolutely nothing.  <a href="classsouffle_1_1_null_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_optimistic_read_write_lock.html">OptimisticReadWriteLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 'sequential' non-locking implementation for an optimistic r/w lock.  <a href="classsouffle_1_1_optimistic_read_write_lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_order.html">Order</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An order to be enforced for storing tuples within indexes.  <a href="classsouffle_1_1_order.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_parallel_transformer.html">ParallelTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms Choice/IndexChoice/IndexScan/Scan into parallel versions.  <a href="classsouffle_1_1_parallel_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_parser_driver.html">ParserDriver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_partition_body_literals_transformer.html">PartitionBodyLiteralsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to move literals into new clauses if they are independent of remaining literals.  <a href="classsouffle_1_1_partition_body_literals_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_partitioned_stream.html">PartitionedStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partitioned stream is a list of streams each covering a disjoint subset of a specific range.  <a href="classsouffle_1_1_partitioned_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_piggy_list.html">PiggyList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_pipeline_transformer.html">PipelineTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformer that holds an arbitrary number of sub-transformations.  <a href="classsouffle_1_1_pipeline_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_polymorphic_objects_transformer.html">PolymorphicObjectsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to determine instances of polymorphic object objects = Functors (plus, minus...) ∪ binary constraints (&gt;, ≥ ...) ∪ aggregation ∪ numeric constants.  <a href="classsouffle_1_1_polymorphic_objects_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_precedence_graph.html">PrecedenceGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analysis pass computing the precedence graph of the relations of the datalog progam.  <a href="classsouffle_1_1_precedence_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_predefined_type.html">PredefinedType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsouffle_1_1_predefined_type.html" title="PredefinedType = Number/Unsigned/Float/Symbol. ">PredefinedType</a> = Number/Unsigned/Float/Symbol.  <a href="structsouffle_1_1_predefined_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1print__deref.html">print_deref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor printing elements after dereferencing it.  <a href="structsouffle_1_1print__deref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_problem.html">Problem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A problem is a list of constraints for which a solution is desired.  <a href="classsouffle_1_1_problem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_profile_event_singleton.html">ProfileEventSingleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Profile Event Singleton.  <a href="classsouffle_1_1_profile_event_singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_program_factory.html">ProgramFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract program factory class.  <a href="classsouffle_1_1_program_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1property__space.html">property_space</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A MPL type for defining a property space.  <a href="structsouffle_1_1property__space.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_provenance_transformer.html">ProvenanceTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to add provenance information.  <a href="classsouffle_1_1_provenance_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1ram__visitor__tag.html">ram_visitor_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag type required for the is_ram_visitor type trait to identify RamVisitors.  <a href="structsouffle_1_1ram__visitor__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_abstract_aggregate.html">RamAbstractAggregate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for aggregation.  <a href="classsouffle_1_1_ram_abstract_aggregate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_abstract_choice.html">RamAbstractChoice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for a choice operation.  <a href="classsouffle_1_1_ram_abstract_choice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_abstract_conditional.html">RamAbstractConditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract conditional statement.  <a href="classsouffle_1_1_ram_abstract_conditional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_abstract_existence_check.html">RamAbstractExistenceCheck</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract existence check for a tuple in a relation.  <a href="classsouffle_1_1_ram_abstract_existence_check.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_abstract_log.html">RamAbstractLog</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for logging.  <a href="classsouffle_1_1_ram_abstract_log.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_abstract_operator.html">RamAbstractOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for an operator/functor.  <a href="classsouffle_1_1_ram_abstract_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_abstract_parallel.html">RamAbstractParallel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for parallel operation.  <a href="classsouffle_1_1_ram_abstract_parallel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_aggregate.html">RamAggregate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregation function applied on some relation.  <a href="classsouffle_1_1_ram_aggregate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_analysis.html">RamAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for a RAM Analysis.  <a href="classsouffle_1_1_ram_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_auto_increment.html">RamAutoIncrement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment a counter and return its value.  <a href="classsouffle_1_1_ram_auto_increment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_bin_relation_statement.html">RamBinRelationStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for a binary relation.  <a href="classsouffle_1_1_ram_bin_relation_statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_break.html">RamBreak</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks out of the loop if a condition holds.  <a href="classsouffle_1_1_ram_break.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_choice.html">RamChoice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a tuple in a relation such that a given condition holds.  <a href="classsouffle_1_1_ram_choice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_clear.html">RamClear</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete tuples of a relation.  <a href="classsouffle_1_1_ram_clear.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_complexity_analysis.html">RamComplexityAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Ram Analysis for determining the number of relational operations in a condition / expression.  <a href="classsouffle_1_1_ram_complexity_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_condition.html">RamCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for conditions and boolean values in RAM.  <a href="classsouffle_1_1_ram_condition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_conditional_transformer.html">RamConditionalTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_ram_conditional_transformer.html" title="RamConditionalTransformer  Composite conditional transformer ">RamConditionalTransformer</a>  Composite conditional transformer  <a href="classsouffle_1_1_ram_conditional_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_conjunction.html">RamConjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A conjunction of conditions.  <a href="classsouffle_1_1_ram_conjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_constant.html">RamConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a Ram Constant.  <a href="classsouffle_1_1_ram_constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_constraint.html">RamConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a binary constraint with respect to two RamExpressions.  <a href="classsouffle_1_1_ram_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_debug_info.html">RamDebugInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug statement.  <a href="classsouffle_1_1_ram_debug_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_emptiness_check.html">RamEmptinessCheck</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emptiness check for a relation.  <a href="classsouffle_1_1_ram_emptiness_check.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_existence_check.html">RamExistenceCheck</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Existence check for a tuple(-pattern) in a relation.  <a href="classsouffle_1_1_ram_existence_check.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_exit.html">RamExit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit statement for a loop.  <a href="classsouffle_1_1_ram_exit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_expression.html">RamExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for describing scalar values in RAM.  <a href="classsouffle_1_1_ram_expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_extend.html">RamExtend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend equivalence relation.  <a href="classsouffle_1_1_ram_extend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_false.html">RamFalse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_filter.html">RamFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a given condition holds.  <a href="classsouffle_1_1_ram_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_float_constant.html">RamFloatConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a float constant.  <a href="classsouffle_1_1_ram_float_constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_index_aggregate.html">RamIndexAggregate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed aggregation on a relation.  <a href="classsouffle_1_1_ram_index_aggregate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_index_analysis.html">RamIndexAnalysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_index_choice.html">RamIndexChoice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use an index to find a tuple in a relation such that a given condition holds.  <a href="classsouffle_1_1_ram_index_choice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_index_operation.html">RamIndexOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_index_scan.html">RamIndexScan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for tuples of a relation matching a criteria.  <a href="classsouffle_1_1_ram_index_scan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_intrinsic_operator.html">RamIntrinsicOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator that represents an intrinsic (built-in) functor.  <a href="classsouffle_1_1_ram_intrinsic_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_i_o.html">RamIO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O statement for a relation.  <a href="classsouffle_1_1_ram_i_o.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_level_analysis.html">RamLevelAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Ram Analysis for determining the level of a expression/condition.  <a href="classsouffle_1_1_ram_level_analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_list_statement.html">RamListStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for a list of RAM statements.  <a href="classsouffle_1_1_ram_list_statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_log_relation_timer.html">RamLogRelationTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution time logger for a statement.  <a href="classsouffle_1_1_ram_log_relation_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_log_size.html">RamLogSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log relation size and a logging message.  <a href="classsouffle_1_1_ram_log_size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_log_timer.html">RamLogTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution time logger for a statement.  <a href="classsouffle_1_1_ram_log_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_loop.html">RamLoop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute statement until statement terminates loop via an exit statement.  <a href="classsouffle_1_1_ram_loop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_loop_transformer.html">RamLoopTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_ram_loop_transformer.html" title="RamLoopTransformer  Composite loop transformer ">RamLoopTransformer</a>  Composite loop transformer  <a href="classsouffle_1_1_ram_loop_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_meta_transformer.html">RamMetaTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_ram_meta_transformer.html" title="RamMetaTransformer  Abstract class to identifier meta transformer ">RamMetaTransformer</a>  Abstract class to identifier meta transformer  <a href="classsouffle_1_1_ram_meta_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_negation.html">RamNegation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates a given condition.  <a href="classsouffle_1_1_ram_negation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_nested_operation.html">RamNestedOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for a nesting operations in a loop-nest.  <a href="classsouffle_1_1_ram_nested_operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_node.html">RamNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_ram_node.html" title="RamNode is a superclass for all RAM IR classes. ">RamNode</a> is a superclass for all RAM IR classes.  <a href="classsouffle_1_1_ram_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_node_mapper.html">RamNodeMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class for manipulating RAM Nodes by substitution.  <a href="classsouffle_1_1_ram_node_mapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_operation.html">RamOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for a relational algebra operation.  <a href="classsouffle_1_1_ram_operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_pack_record.html">RamPackRecord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs a record's arguments into a reference.  <a href="classsouffle_1_1_ram_pack_record.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_parallel.html">RamParallel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel block of statements.  <a href="classsouffle_1_1_ram_parallel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_parallel_choice.html">RamParallelChoice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_parallel_index_choice.html">RamParallelIndexChoice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use an index to find a tuple in a relation such that a given condition holds in parallel.  <a href="classsouffle_1_1_ram_parallel_index_choice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_parallel_index_scan.html">RamParallelIndexScan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for tuples of a relation matching a criteria.  <a href="classsouffle_1_1_ram_parallel_index_scan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_parallel_scan.html">RamParallelScan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate all tuples of a relation in parallel.  <a href="classsouffle_1_1_ram_parallel_scan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_program.html">RamProgram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAM program relation declaration and functions.  <a href="classsouffle_1_1_ram_program.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_project.html">RamProject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a result into the target relation.  <a href="classsouffle_1_1_ram_project.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_provenance_existence_check.html">RamProvenanceExistenceCheck</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provenance Existence check for a relation.  <a href="classsouffle_1_1_ram_provenance_existence_check.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_query.html">RamQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A relational algebra query.  <a href="classsouffle_1_1_ram_query.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_relation.html">RamRelation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RAM <a class="el" href="classsouffle_1_1_relation.html" title="Object-oriented wrapper class for Souffle&#39;s templatized relations. ">Relation</a> in the RAM intermediate representation.  <a href="classsouffle_1_1_ram_relation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_relation_operation.html">RamRelationOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for operations on relations.  <a href="classsouffle_1_1_ram_relation_operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_relation_reference.html">RamRelationReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RAM <a class="el" href="classsouffle_1_1_relation.html" title="Object-oriented wrapper class for Souffle&#39;s templatized relations. ">Relation</a> in the RAM intermediate representation.  <a href="classsouffle_1_1_ram_relation_reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_relation_statement.html">RamRelationStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAM Statements with a single relation.  <a href="classsouffle_1_1_ram_relation_statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_scan.html">RamScan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate all tuples of a relation.  <a href="classsouffle_1_1_ram_scan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_sequence.html">RamSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence of RAM statements.  <a href="classsouffle_1_1_ram_sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_signed_constant.html">RamSignedConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a signed constant.  <a href="classsouffle_1_1_ram_signed_constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_statement.html">RamStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for RAM statements.  <a href="classsouffle_1_1_ram_statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_subroutine_argument.html">RamSubroutineArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access argument of a subroutine.  <a href="classsouffle_1_1_ram_subroutine_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_subroutine_return_value.html">RamSubroutineReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A statement for returning from a ram subroutine.  <a href="classsouffle_1_1_ram_subroutine_return_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_swap.html">RamSwap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap operation with respect to two relations.  <a href="classsouffle_1_1_ram_swap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_transformer.html">RamTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_ram_transformer.html" title="RamTransformer  abstract transformer class for a translation unit ">RamTransformer</a>  abstract transformer class for a translation unit  <a href="classsouffle_1_1_ram_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_transformer_sequence.html">RamTransformerSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_ram_transformer_sequence.html" title="RamTransformerSequence  Composite sequence transformer ">RamTransformerSequence</a>  Composite sequence transformer  <a href="classsouffle_1_1_ram_transformer_sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_translation_unit.html">RamTranslationUnit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translating a RAM program.  <a href="classsouffle_1_1_ram_translation_unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_true.html">RamTrue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">True value condition.  <a href="classsouffle_1_1_ram_true.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_tuple_element.html">RamTupleElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element from the current tuple in a tuple environment.  <a href="classsouffle_1_1_ram_tuple_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_tuple_operation.html">RamTupleOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for relation searches and lookups.  <a href="classsouffle_1_1_ram_tuple_operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_undef_value.html">RamUndefValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An undefined expression.  <a href="classsouffle_1_1_ram_undef_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_unpack_record.html">RamUnpackRecord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record lookup.  <a href="classsouffle_1_1_ram_unpack_record.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_unsigned_constant.html">RamUnsignedConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a unsigned constant.  <a href="classsouffle_1_1_ram_unsigned_constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_ram_user_defined_operator.html">RamUserDefinedOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator that represents an extrinsic (user-defined) functor.  <a href="classsouffle_1_1_ram_user_defined_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_ram_visitor.html">RamVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic base type of all RamVisitors realizing the dispatching of visitor calls.  <a href="structsouffle_1_1_ram_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_random_insert_piggy_list.html">RandomInsertPiggyList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classsouffle_1_1_piggy_list.html">PiggyList</a> that allows insertAt functionality.  <a href="classsouffle_1_1_random_insert_piggy_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1range.html">range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class enabling representation of ranges by pairing two iterator instances marking lower and upper boundaries.  <a href="structsouffle_1_1range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_cin_c_s_v_factory.html">ReadCinCSVFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_file_c_s_v.html">ReadFileCSV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_file_c_s_v_factory.html">ReadFileCSVFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_s_q_lite_factory.html">ReadSQLiteFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_stream.html">ReadStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_stream_c_s_v.html">ReadStreamCSV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_stream_factory.html">ReadStreamFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_stream_s_q_lite.html">ReadStreamSQLite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_read_write_lock.html">ReadWriteLock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_record_map.html">RecordMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional mappping between records and record references.  <a href="classsouffle_1_1_record_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_record_table.html">RecordTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_record_type.html">RecordType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A record type combining a list of fields into a new, aggregated type.  <a href="structsouffle_1_1_record_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_recursive_clauses.html">RecursiveClauses</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analysis pass identifying clauses which are recursive.  <a href="classsouffle_1_1_recursive_clauses.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_reduce_existentials_transformer.html">ReduceExistentialsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to reduce unnecessary computation for relations that only appear in the form A(_,...,_).  <a href="classsouffle_1_1_reduce_existentials_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_redundant_relations.html">RedundantRelations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analysis pass identifying relations which do not contribute to the computation of the output relations.  <a href="classsouffle_1_1_redundant_relations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_relation.html">Relation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object-oriented wrapper class for Souffle's templatized relations.  <a href="classsouffle_1_1_relation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_relation_detail_cache.html">RelationDetailCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analysis pass mapping identifiers with relations and clauses.  <a href="classsouffle_1_1_relation_detail_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_relation_schedule.html">RelationSchedule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analysis pass computing a schedule for computing relations.  <a href="classsouffle_1_1_relation_schedule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_relation_schedule_step.html">RelationScheduleStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single step in a relation schedule, consisting of the relations computed in the step and the relations that are no longer required at that step.  <a href="classsouffle_1_1_relation_schedule_step.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_relation_wrapper.html">RelationWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_relation.html" title="Object-oriented wrapper class for Souffle&#39;s templatized relations. ">Relation</a> wrapper used internally in the generated Datalog program.  <a href="classsouffle_1_1_relation_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_remove_boolean_constraints_transformer.html">RemoveBooleanConstraintsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove constant boolean constraints Should be called after any transformation that may generate boolean constraints.  <a href="classsouffle_1_1_remove_boolean_constraints_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_remove_empty_relations_transformer.html">RemoveEmptyRelationsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove all empty relations and rules that use empty relations.  <a href="classsouffle_1_1_remove_empty_relations_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_remove_redundant_relations_transformer.html">RemoveRedundantRelationsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove relations which are redundant (do not contribute to output).  <a href="classsouffle_1_1_remove_redundant_relations_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_remove_redundant_sums_transformer.html">RemoveRedundantSumsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to remove expressions of the form sum k : { ...  <a href="classsouffle_1_1_remove_redundant_sums_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_remove_relation_copies_transformer.html">RemoveRelationCopiesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to replaces copy of relations by their origin.  <a href="classsouffle_1_1_remove_relation_copies_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_remove_typecasts_transformer.html">RemoveTypecastsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation to remove typecasts.  <a href="classsouffle_1_1_remove_typecasts_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_reorder_conditions_transformer.html">ReorderConditionsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders conjunctive terms depending on cost, i.e., cheap terms should be executed first.  <a href="classsouffle_1_1_reorder_conditions_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_reorder_filter_break.html">ReorderFilterBreak</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_reorder_literals_transformer.html">ReorderLiteralsTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to reorder body literals.  <a href="classsouffle_1_1_reorder_literals_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_replace_singleton_variables_transformer.html">ReplaceSingletonVariablesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to replace singleton variables with unnamed variables.  <a href="classsouffle_1_1_replace_singleton_variables_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_report_index_transformer.html">ReportIndexTransformer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_resolve_aliases_transformer.html">ResolveAliasesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to eliminate grounded aliases.  <a href="classsouffle_1_1_resolve_aliases_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_resolve_anonymous_records_aliases.html">ResolveAnonymousRecordsAliases</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformer resolving aliases for anonymous records.  <a href="classsouffle_1_1_resolve_anonymous_records_aliases.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_rule_body.html">RuleBody</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1scanner__data.html">scanner_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_s_c_c_graph.html">SCCGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analysis pass computing the strongly connected component (SCC) graph for the datalog program.  <a href="classsouffle_1_1_s_c_c_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_screen_buffer.html">ScreenBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1set__property__space.html">set_property_space</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A property space for set-based properties based on sub-set lattices.  <a href="structsouffle_1_1set__property__space.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_signal_handler.html">SignalHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classsouffle_1_1_signal_handler.html" title="Class SignalHandler captures signals and reports the context where the signal occurs. ">SignalHandler</a> captures signals and reports the context where the signal occurs.  <a href="classsouffle_1_1_signal_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_single_value_iterator.html">SingleValueIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator to be utilized if there is only a single element to iterate over.  <a href="classsouffle_1_1_single_value_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_souffle_program.html">SouffleProgram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for generated Datalog programs.  <a href="classsouffle_1_1_souffle_program.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_sparse_array.html">SparseArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse array simulates an array associating to every element of uint32_t an element of a generic type T.  <a href="classsouffle_1_1_sparse_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_sparse_bit_map.html">SparseBitMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse bit-map is a bit map virtually assigning a bit value to every value if the uint32_t domain.  <a href="classsouffle_1_1_sparse_bit_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_sparse_disjoint_set.html">SparseDisjointSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_spin_lock.html">SpinLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 'sequential' non-locking implementation for a spin lock.  <a href="classsouffle_1_1_spin_lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_src_location.html">SrcLocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class describing a range in an input file.  <a href="classsouffle_1_1_src_location.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_stream.html">Stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract perspective on a data range.  <a href="classsouffle_1_1_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_subset_type.html">SubsetType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A primitive type.  <a href="classsouffle_1_1_subset_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_symbol_table.html">SymbolTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsouffle_1_1_global.html">Global</a> pool of re-usable strings.  <a href="classsouffle_1_1_symbol_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_synthesiser.html">Synthesiser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RAM synthesiser: synthesises a C++ program from a RAM program.  <a href="classsouffle_1_1_synthesiser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_synthesiser_brie_relation.html">SynthesiserBrieRelation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_synthesiser_direct_relation.html">SynthesiserDirectRelation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_synthesiser_eqrel_relation.html">SynthesiserEqrelRelation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_synthesiser_indirect_relation.html">SynthesiserIndirectRelation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_synthesiser_info_relation.html">SynthesiserInfoRelation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_synthesiser_nullary_relation.html">SynthesiserNullaryRelation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_synthesiser_relation.html">SynthesiserRelation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1t__info.html">t_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">info relations  <a href="classsouffle_1_1t__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1t__nullaries.html">t_nullaries</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullary relations.  <a href="classsouffle_1_1t__nullaries.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_table.html">Table</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_temp_file_stream.html">TempFileStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_topologically_sorted_s_c_c_graph.html">TopologicallySortedSCCGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analysis pass computing a topologically sorted strongly connected component (SCC) graph.  <a href="classsouffle_1_1_topologically_sorted_s_c_c_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_tree_node.html">TreeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_trie.html">Trie</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most generic implementation of a <a class="el" href="classsouffle_1_1_trie.html" title="The most generic implementation of a Trie forming the top-level of any Trie storing tuples of arity &gt;...">Trie</a> forming the top-level of any <a class="el" href="classsouffle_1_1_trie.html" title="The most generic implementation of a Trie forming the top-level of any Trie storing tuples of arity &gt;...">Trie</a> storing tuples of arity &gt; 1.  <a href="classsouffle_1_1_trie.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_trie_3_011u_01_4.html">Trie&lt; 1u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template specialization for tries representing a set.  <a href="classsouffle_1_1_trie_3_011u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_tuple.html">Tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of object stored within relations representing the actual tuple value.  <a href="structsouffle_1_1_tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1tuple.html">tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a tuple for the OO interface such that relations with varying columns can be accessed.  <a href="classsouffle_1_1tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_tuple_id_transformer.html">TupleIdTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordering tupleIds in <a class="el" href="classsouffle_1_1_ram_tuple_operation.html" title="Abstract class for relation searches and lookups. ">RamTupleOperation</a> operations correctly.  <a href="classsouffle_1_1_tuple_id_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_tuple_ref.html">TupleRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-erased reference to tuples.  <a href="classsouffle_1_1_tuple_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract base class for types to be covered within a type environment.  <a href="classsouffle_1_1_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_type_analysis.html">TypeAnalysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_type_binding.html">TypeBinding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that encapsulates std::map of types binding that comes from .init c = Comp&lt;MyType&gt; <a class="el" href="classsouffle_1_1_type.html" title="An abstract base class for types to be covered within a type environment. ">Type</a> binding in this example would be T-&gt;MyType if the component code is .comp Comp&lt;T&gt; ...  <a href="classsouffle_1_1_type_binding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_type_environment.html">TypeEnvironment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type environment is a set of types.  <a href="classsouffle_1_1_type_environment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_type_environment_analysis.html">TypeEnvironmentAnalysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection to represent sets of types.  <a href="structsouffle_1_1_type_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_union_type.html">UnionType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A union type combining a list of types into a new, aggregated type.  <a href="classsouffle_1_1_union_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_unique_aggregation_variables_transformer.html">UniqueAggregationVariablesTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation pass to rename aggregation variables to make them unique.  <a href="classsouffle_1_1_unique_aggregation_variables_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable to be utilized within constraints to be handled by the constraint solver.  <a href="structsouffle_1_1_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_while_transformer.html">WhileTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformer that repeatedly executes a sub-transformer while a condition is met.  <a href="classsouffle_1_1_while_transformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_cout_c_s_v.html">WriteCoutCSV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_cout_c_s_v_factory.html">WriteCoutCSVFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_cout_print_size.html">WriteCoutPrintSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_cout_print_size_factory.html">WriteCoutPrintSizeFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_file_c_s_v.html">WriteFileCSV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_file_c_s_v_factory.html">WriteFileCSVFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_s_q_lite_factory.html">WriteSQLiteFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_stream.html">WriteStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_stream_c_s_v.html">WriteStreamCSV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_stream_factory.html">WriteStreamFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_write_stream_s_q_lite.html">WriteStreamSQLite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a851652d425321cd735fbe321f392fe85"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a851652d425321cd735fbe321f392fe85">AstRelationSet</a> = std::set&lt; const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *, <a class="el" href="structsouffle_1_1_ast_name_comparison.html">AstNameComparison</a> &gt;</td></tr>
<tr class="separator:a851652d425321cd735fbe321f392fe85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f22adc58415a0ceecac60f7456f7d3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a86f22adc58415a0ceecac60f7456f7d3">block_t</a> = uint64_t</td></tr>
<tr class="separator:a86f22adc58415a0ceecac60f7456f7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7d41d263a3aaacb9bbfc62c6becd56"><td class="memTemplParams" colspan="2">template&lt;std::size_t Arity&gt; </td></tr>
<tr class="memitem:aae7d41d263a3aaacb9bbfc62c6becd56"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aae7d41d263a3aaacb9bbfc62c6becd56">comparator</a> = typename <a class="el" href="structsouffle_1_1index__utils_1_1get__full__index.html">index_utils::get_full_index</a>&lt; Arity &gt;::type::comparator</td></tr>
<tr class="separator:aae7d41d263a3aaacb9bbfc62c6becd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3014e8a5f6aab584f9749e0128b84327"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3014e8a5f6aab584f9749e0128b84327">IndexFactory</a> = std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_interpreter_index.html">InterpreterIndex</a> &gt;(*)(const <a class="el" href="classsouffle_1_1_order.html">Order</a> &amp;)</td></tr>
<tr class="separator:a3014e8a5f6aab584f9749e0128b84327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ed8d79242399e8c145385667df783c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a88ed8d79242399e8c145385667df783c">IndexViewPtr</a> = std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_index_view.html">IndexView</a> &gt;</td></tr>
<tr class="separator:a88ed8d79242399e8c145385667df783c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cd00ed671edea5d1ddf34bf8260388"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa5cd00ed671edea5d1ddf34bf8260388">parent_t</a> = uint64_t</td></tr>
<tr class="separator:aa5cd00ed671edea5d1ddf34bf8260388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d8dbe49d3251e572172b31023b1ce9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa9d8dbe49d3251e572172b31023b1ce9">RamDomain</a> = int32_t</td></tr>
<tr class="separator:aa9d8dbe49d3251e572172b31023b1ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ed4e379ed3ad06b9d02a4fc8470646"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a71ed4e379ed3ad06b9d02a4fc8470646">RamFloat</a> = float</td></tr>
<tr class="separator:a71ed4e379ed3ad06b9d02a4fc8470646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506d6a56200708498577b6e4d3a83ae3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a506d6a56200708498577b6e4d3a83ae3">RamSigned</a> = <a class="el" href="namespacesouffle.html#aa9d8dbe49d3251e572172b31023b1ce9">RamDomain</a></td></tr>
<tr class="separator:a506d6a56200708498577b6e4d3a83ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaab74f4511cf7a2da6afe0e001be9c6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#afaab74f4511cf7a2da6afe0e001be9c6">RamUnsigned</a> = uint32_t</td></tr>
<tr class="separator:afaab74f4511cf7a2da6afe0e001be9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5046648056218d9001c24f049c12c19a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a5046648056218d9001c24f049c12c19a">rank_t</a> = uint8_t</td></tr>
<tr class="separator:a5046648056218d9001c24f049c12c19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf42249e9320e05cbb320528f299fb15"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aaf42249e9320e05cbb320528f299fb15">SearchSignature</a> = uint64_t</td></tr>
<tr class="memdesc:aaf42249e9320e05cbb320528f299fb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">search signature of a RAM operation; each bit represents an attribute of a relation.  <a href="#aaf42249e9320e05cbb320528f299fb15">More...</a><br /></td></tr>
<tr class="separator:aaf42249e9320e05cbb320528f299fb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dcec7b78fdde7450cb55df1fece164"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad0dcec7b78fdde7450cb55df1fece164">sips_t</a> = std::function&lt; unsigned int(std::vector&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> * &gt;, const std::set&lt; std::string &gt; &amp;)&gt;</td></tr>
<tr class="separator:ad0dcec7b78fdde7450cb55df1fece164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954e259daffe7c9e04cfeb83ea0c5742"><td class="memTemplParams" colspan="2">template&lt;std::size_t Arity&gt; </td></tr>
<tr class="memitem:a954e259daffe7c9e04cfeb83ea0c5742"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a954e259daffe7c9e04cfeb83ea0c5742">t_tuple</a> = typename <a class="el" href="structsouffle_1_1_tuple.html">souffle::Tuple</a>&lt; <a class="el" href="namespacesouffle.html#aa9d8dbe49d3251e572172b31023b1ce9">RamDomain</a>, Arity &gt;</td></tr>
<tr class="separator:a954e259daffe7c9e04cfeb83ea0c5742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb29a1677ffbe44fe8663f881213f0e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9eb29a1677ffbe44fe8663f881213f0e">time_point</a> = std::chrono::high_resolution_clock::time_point</td></tr>
<tr class="separator:a9eb29a1677ffbe44fe8663f881213f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47203d0502442fd4785dbaeffc4acc0f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a47203d0502442fd4785dbaeffc4acc0f">yyscan_t</a> = void *</td></tr>
<tr class="separator:a47203d0502442fd4785dbaeffc4acc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa26a7e6147aca5568158e38f08ffcf21"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">AggregateOp</a> { <br />
&#160;&#160;<a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">AggregateOp::MAX</a>, 
<a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">AggregateOp::MIN</a>, 
<a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a6970bdc2201030b9c03fbdcf3973858a">AggregateOp::SUM</a>, 
<a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1">AggregateOp::FMAX</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6">AggregateOp::FMIN</a>, 
<a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a0645fcc11b74dbdbf2d7501942fa6f6f">AggregateOp::FSUM</a>, 
<a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a4ea6d1161ea24d7599365f574aff6610">AggregateOp::MEAN</a>, 
<a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059">AggregateOp::UMAX</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb">AggregateOp::UMIN</a>, 
<a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ae6246115490f016a4ecb2604ba5fc2ed">AggregateOp::USUM</a>, 
<a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a4905ac9d6a22bdfc1ae096094ce6248d">AggregateOp::COUNT</a>
<br />
 }<tr class="memdesc:aa26a7e6147aca5568158e38f08ffcf21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of aggregation functions.  <a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa26a7e6147aca5568158e38f08ffcf21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac460f7c8b5ab0da53316d6bb32a19f49"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> { <br />
&#160;&#160;<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">BinaryConstraintOp::EQ</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa123e958001611b441dab45ff11ba98a">BinaryConstraintOp::FEQ</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">BinaryConstraintOp::NE</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a90dc357130ab3c37ef770e959ab49b9c">BinaryConstraintOp::FNE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">BinaryConstraintOp::LT</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2b4652512a6c88f5a39c3288081b6e13">BinaryConstraintOp::ULT</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a1cc288bb3360b602513d8ffe37a874f9">BinaryConstraintOp::FLT</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac71563c4ae48cc1bbd2e7913366cdf7e">BinaryConstraintOp::SLT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">BinaryConstraintOp::LE</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ae29e365fd3b5e59c86218486a0c1c7c1">BinaryConstraintOp::ULE</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a56267eaefed8c4c5255779a597a72363">BinaryConstraintOp::FLE</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a0a1d07df9a43688c7128eefbe3d41b08">BinaryConstraintOp::SLE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">BinaryConstraintOp::GT</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7efc25ec6c881b13261c1a6d88762483">BinaryConstraintOp::UGT</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa302b6b103aca34c46209564002a8252">BinaryConstraintOp::FGT</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a53acb49d0534e8912fec8569e845400f">BinaryConstraintOp::SGT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">BinaryConstraintOp::GE</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ada0d6078de3703b5680eb9361f2d68fd">BinaryConstraintOp::UGE</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa1d7888b08b54d43aeadc58136fa0907">BinaryConstraintOp::FGE</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49add25db0709d4c7c05b057f311208f753">BinaryConstraintOp::SGE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a">BinaryConstraintOp::MATCH</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b">BinaryConstraintOp::CONTAINS</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01">BinaryConstraintOp::NOT_MATCH</a>, 
<a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0">BinaryConstraintOp::NOT_CONTAINS</a>
<br />
 }<tr class="memdesc:ac460f7c8b5ab0da53316d6bb32a19f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary Constraint Operators.  <a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac460f7c8b5ab0da53316d6bb32a19f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ddd8269d2a01a6041800d3b2e3fad9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a> { <br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac23431d0209648a6b31fa837dd56d681">FunctorOp::ORD</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc37711c3936f2459ef27e1dbe4f6480">FunctorOp::STRLEN</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a5dd68b1a7db42a1cce4dce09dbaa179e">FunctorOp::NEG</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a36da8d8fdce0e080abfcab7af41066c6">FunctorOp::FNEG</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0fd78279a775c262180e0cfbad6fa9eb">FunctorOp::BNOT</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac2fc8ad7a275c06c870529f9f9f07caa">FunctorOp::UBNOT</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a81145009eec44ad2c399c9459a01d8f0">FunctorOp::LNOT</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a7fdc4b2848234d42fe9a22b78fd68910">FunctorOp::ULNOT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aae9c007a17eb01f69e2dba22cf15cf30">FunctorOp::TONUMBER</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a91b8cf1c9769ddb9cb64191c89becc1b">FunctorOp::TOSTRING</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4c0f1a4930775ab571de3e85aedc623e">FunctorOp::ITOU</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac059c9401f1af0e831f9f180f3c6bfef">FunctorOp::UTOI</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc526b23b5b6d76a12984c29bf63c4a3">FunctorOp::ITOF</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a81bf488d5db54d36a738384aaf845fdf">FunctorOp::FTOI</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9d0ef69432b16260e9622b4f614bc9c5">FunctorOp::UTOF</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a89aa92cb66549459a7d407094aacbcef">FunctorOp::FTOU</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9eeb52badb613229884838847294b90d">FunctorOp::ADD</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a241dd841abade20fcb27b8a9f494e1eb">FunctorOp::SUB</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2cdf52a55876063ec93b7d18bc741f6c">FunctorOp::MUL</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a29bbf66f7f8529ec47e394fb5a36c646">FunctorOp::DIV</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a8c670f8c37b95e1ed14a0ce414b049c7">FunctorOp::EXP</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a26a4b44a837bf97b972628509912b4a5">FunctorOp::MAX</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ace31e2a082d17e038fcc6e3006166653">FunctorOp::MIN</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac5a28f4b35a2884fa3277150ac5d0967">FunctorOp::MOD</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aa8a5bbeedca093b94b7f0d3f185b98f7">FunctorOp::BAND</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0adf6aac232504c55ea4202e09498bfd">FunctorOp::BOR</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a21506bac4ecfbfe4272b9bf8185446b6">FunctorOp::BXOR</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a88d973d6a866ababf2fb28a6112f8d46">FunctorOp::BSHIFT_L</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9e74511ce5c138f374559a76abb6e209">FunctorOp::BSHIFT_R</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3fdb4dd3e2677523449a3747923d4401">FunctorOp::BSHIFT_R_UNSIGNED</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a479a809c0b6eaaefd3b1df16f976df06">FunctorOp::LAND</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ad3335c358811cfc353257e21b1d38229">FunctorOp::LOR</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a1f0002abde2c29615d914ab0228c68d3">FunctorOp::UADD</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9af8aba91736be4bad67181a8cce032337">FunctorOp::USUB</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ae89690f1278cca1400678daaa4a6a3b7">FunctorOp::UMUL</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a56d5c96c848631ef14e1f2a6e0f15d49">FunctorOp::UDIV</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a59407eef1229dea3aac5dc8d77d06c92">FunctorOp::UEXP</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9adf23c745cc30333029ae3a73cd87c059">FunctorOp::UMAX</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a925d976d8f961af767954de9f62f40cb">FunctorOp::UMIN</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4bbe00e945b01d43cb7edecf51b0de5c">FunctorOp::UMOD</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ab5755f546c5f5ca6a3f1720ef8e642ef">FunctorOp::UBAND</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4803dabeb7190f48195a26654eafaa42">FunctorOp::UBOR</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a70f4367aed9601f37bfbdd4586b327df">FunctorOp::UBXOR</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a653789f2eb8bfa402c5f60ceceac247b">FunctorOp::UBSHIFT_L</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aab623d5679ac1cc907cb363e2d51eb14">FunctorOp::UBSHIFT_R</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a07da89f09f961f63a15696ac57bbc1c3">FunctorOp::UBSHIFT_R_UNSIGNED</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3d0f34d8e784f8a48332424dd598a27a">FunctorOp::ULAND</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9addb2113545b6bd7fbe64ed7bff507964">FunctorOp::ULOR</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc2cbacfa7c4ef9bc72773ebdd9fe166">FunctorOp::FADD</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a06be1058e817f781f4e0f0641f436247">FunctorOp::FSUB</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a26a83f923754f1e7aa12640b8bcca29a">FunctorOp::FMUL</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9abccb2b7436e0cbfb334fe07304fe28a6">FunctorOp::FDIV</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a107c7a3cc48a0fe27d435e82c8679ef0">FunctorOp::FEXP</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a1e692622d3020e12589d7fb475de73b1">FunctorOp::FMAX</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aa188dc14c6a8fb8a3e7204027a3f16e6">FunctorOp::FMIN</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a00e365acdc6de6b62421116e865bd420">FunctorOp::SMAX</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2d9174ad446fde0fc750265f9e075977">FunctorOp::SMIN</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac01ae1a5f122f25ce5675f86028b536a">FunctorOp::CAT</a>, 
<a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0f85e58dd75e7025beb47ee590ff7669">FunctorOp::SUBSTR</a>
<br />
 }</td></tr>
<tr class="separator:a28ddd8269d2a01a6041800d3b2e3fad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a982dd15c24b8dde9e7a5ac00b5b30f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30f">InterpreterNodeType</a> { <br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa427709f25dfaec2407c10c9acfb29fc1">I_Constant</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fac92994264e0a187b6defbf6f364da782">I_TupleElement</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa18ddb6d3d81cb16a6c3489b37e5ee167">I_AutoIncrement</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa019c55f9affc926925c4c36910049fb2">I_IntrinsicOperator</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fad61d7a9c5957b7f79e795384ba68e123">I_UserDefinedOperator</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa05d6d1a89ac8c1d89b8ff21e30d49e7b">I_PackRecord</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fae81168f8a3ef22c641dc84dac0d720a9">I_SubroutineArgument</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa44dac3d2b3026a02d7277cdffd46f11d">I_True</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa21b15245b84482da42ffb795c5a4b5c8">I_False</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa2688791f9d813a0d0c699f4bacc95f43">I_Conjunction</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa4ba0eed2143398a27afdde13d2837bc0">I_Negation</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa427cb5b0ad39f494e2056de4e95f0644">I_EmptinessCheck</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fabe804a8e5d5c1cdfb6eba142561d69b3">I_ExistenceCheck</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30faee48292648ec90d6eb37bbd383c7a563">I_ProvenanceExistenceCheck</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa9005af466e695943d45ba34b31c9bf12">I_Constraint</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa66599d3d6e8e19465056b381eb0105c4">I_TupleOperation</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa876c07f2b24b9ab223b4565ae093124d">I_Scan</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fae636d7e8327c812ef8172c3eb3e89657">I_ParallelScan</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa23eced32caa666668f20e6e0343ab437">I_IndexScan</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa1867a6e2452da99f86c42ebd87eeaf42">I_ParallelIndexScan</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa88751c991b488d81696a70a293fd9711">I_Choice</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa65b0b98e373aec0bd7edb4bfd2e8fb8e">I_ParallelChoice</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fae6b9cd4ad39504b9885812f58c4700b3">I_IndexChoice</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa5fceaa961a0c162fffe84264363cf869">I_ParallelIndexChoice</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30faa1abe444b1239d86342ac4e124115c42">I_UnpackRecord</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30faf33b6910e7880fbe58d36a1f45ac7b0d">I_Aggregate</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30faea369dd742cd6fa7a1200f674a5e45c2">I_IndexAggregate</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa1a02359e5055f1a1d410c29f864f86a1">I_Break</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa4bcb0f1476b4b863444d05bacae113e6">I_Filter</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fada3099d1691d5164c3588bf09dc9fd58">I_Project</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa93a488c1abddd355249a81a2cb5deee3">I_SubroutineReturnValue</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa156c90460962f8fee52d3601e0bd3fd4">I_Sequence</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fac15228c7d4078e04d726338accd45b72">I_Parallel</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa46c56fc81947741623f054fcf82ed40c">I_Loop</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fac9c0ab0f1f28d6e133218d9b42a24880">I_Exit</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30faa1e98030617e3521637f68f67c13dc90">I_LogRelationTimer</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa0ffa990468b1fb6b3115d71dd2c3cf4c">I_LogTimer</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa4ab85e660bda5d95a2cbafb72cd63376">I_DebugInfo</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fadc64bb855d60d3bac55d2ca021a179e4">I_Clear</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fad7b2c34b2a01495041e9a1c51c22fdb7">I_LogSize</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa0cb26ea1213a532241245a45d45a7c50">I_IO</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa3941b34b02226e95f067b9d71fc3d90e">I_Query</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa44906683c26840580ed237141e02f9e4">I_Extend</a>, 
<a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa4d2247a5773c7fa7d1bde10982877ec2">I_Swap</a>
<br />
 }</td></tr>
<tr class="separator:a2a982dd15c24b8dde9e7a5ac00b5b30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1111156440d898474b3cd9cd43a276"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a4d1111156440d898474b3cd9cd43a276">RelationQualifier</a> { <br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a4d1111156440d898474b3cd9cd43a276aa84cc046d48610b05c21fd3670d0c829">RelationQualifier::INPUT</a>, 
<a class="el" href="namespacesouffle.html#a4d1111156440d898474b3cd9cd43a276a50a87f0d71f7221582dad4bf507a0f34">RelationQualifier::OUTPUT</a>, 
<a class="el" href="namespacesouffle.html#a4d1111156440d898474b3cd9cd43a276a412e14f57c2f0eeb02d2475ca63bf38c">RelationQualifier::PRINTSIZE</a>, 
<a class="el" href="namespacesouffle.html#a4d1111156440d898474b3cd9cd43a276ac9572efed22489a0eb4ab9dcd8132d4b">RelationQualifier::OVERRIDABLE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a4d1111156440d898474b3cd9cd43a276acfbac07c6ae3e73f0e10ca60ad916bef">RelationQualifier::INLINE</a>, 
<a class="el" href="namespacesouffle.html#a4d1111156440d898474b3cd9cd43a276a749f7196d531a918508ddc75af68469d">RelationQualifier::SUPPRESSED</a>
<br />
 }<tr class="memdesc:a4d1111156440d898474b3cd9cd43a276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space of qualifiers that a relation can have.  <a href="namespacesouffle.html#a4d1111156440d898474b3cd9cd43a276">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a4d1111156440d898474b3cd9cd43a276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6309f0948137356de74c7d16ffbf2d9e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9e">RelationRepresentation</a> { <br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9ea5b39c8b553c821e7cddc6da64b5bd2ee">RelationRepresentation::DEFAULT</a>, 
<a class="el" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9eade0f2c62e46b76fe07b1033a2af15a28">RelationRepresentation::BRIE</a>, 
<a class="el" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9ea26daa90bc6e4e7baf2b5781caef22940">RelationRepresentation::BTREE</a>, 
<a class="el" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9ea06a35dca93aeafc1b0f548410517223a">RelationRepresentation::EQREL</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9ea551b723eafd6a31d444fcb2f5920fbd3">RelationRepresentation::INFO</a>
<br />
 }<tr class="memdesc:a6309f0948137356de74c7d16ffbf2d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space of internal representations that a relation can have.  <a href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6309f0948137356de74c7d16ffbf2d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d04bccb8804e1ace183494574e4529f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529f">RelationTag</a> { <br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529faa84cc046d48610b05c21fd3670d0c829">RelationTag::INPUT</a>, 
<a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa50a87f0d71f7221582dad4bf507a0f34">RelationTag::OUTPUT</a>, 
<a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa412e14f57c2f0eeb02d2475ca63bf38c">RelationTag::PRINTSIZE</a>, 
<a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fac9572efed22489a0eb4ab9dcd8132d4b">RelationTag::OVERRIDABLE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">RelationTag::INLINE</a>, 
<a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa749f7196d531a918508ddc75af68469d">RelationTag::SUPPRESSED</a>, 
<a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fade0f2c62e46b76fe07b1033a2af15a28">RelationTag::BRIE</a>, 
<a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa26daa90bc6e4e7baf2b5781caef22940">RelationTag::BTREE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa06a35dca93aeafc1b0f548410517223a">RelationTag::EQREL</a>
<br />
 }<tr class="memdesc:a8d04bccb8804e1ace183494574e4529f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space of user-chosen tags that a relation can have.  <a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a8d04bccb8804e1ace183494574e4529f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5361aa1e84030b37d7c8df1bf45e1c0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> { <br />
&#160;&#160;<a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a02c86eb2792f3262c21d030a87e19793">TypeAttribute::Symbol</a>, 
<a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379">TypeAttribute::Signed</a>, 
<a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0aa1a914735b205424ba6c40b85528d78a">TypeAttribute::Unsigned</a>, 
<a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a22ae0e2b89e5e3d477f988cc36d3272b">TypeAttribute::Float</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a6a0d9eaee314c567fd72fb97ee707a36">TypeAttribute::Record</a>
<br />
 }</td></tr>
<tr class="separator:af5361aa1e84030b37d7c8df1bf45e1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8a2c294e3ff514cd4ca29b466ff3cab3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8a2c294e3ff514cd4ca29b466ff3cab3">absPath</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a8a2c294e3ff514cd4ca29b466ff3cab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++-style realpath.  <a href="#a8a2c294e3ff514cd4ca29b466ff3cab3">More...</a><br /></td></tr>
<tr class="separator:a8a2c294e3ff514cd4ca29b466ff3cab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad121faea3dab6bbecd66db7757b89e5d"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad121faea3dab6bbecd66db7757b89e5d">addAggregators</a> (<a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *clause, std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt; ignoredNames)</td></tr>
<tr class="separator:ad121faea3dab6bbecd66db7757b89e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef96dcee06ebf23b793c3fd5a9fe111"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1ef96dcee06ebf23b793c3fd5a9fe111">addBackwardDependencies</a> (const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program, std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt; <a class="el" href="_component_instantiation_transformer_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a>)</td></tr>
<tr class="separator:a1ef96dcee06ebf23b793c3fd5a9fe111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54eec417845f7cc5e1b5a47a3dbcf599"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a54eec417845f7cc5e1b5a47a3dbcf599">addForwardDependencies</a> (const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program, std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt; <a class="el" href="_component_instantiation_transformer_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a>)</td></tr>
<tr class="separator:a54eec417845f7cc5e1b5a47a3dbcf599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe97eb10ce6551c9e957bb3950c68eb"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6fe97eb10ce6551c9e957bb3950c68eb">addIgnoredRelations</a> (const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program, std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt; <a class="el" href="_component_instantiation_transformer_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a>)</td></tr>
<tr class="separator:a6fe97eb10ce6551c9e957bb3950c68eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b5f9eb9ec09c40e558b242e75de872"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a14b5f9eb9ec09c40e558b242e75de872"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">all_of</a> (const Container &amp;c, UnaryPredicate <a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:a14b5f9eb9ec09c40e558b242e75de872"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic test checking whether all elements within a container satisfy a certain predicate.  <a href="#a14b5f9eb9ec09c40e558b242e75de872">More...</a><br /></td></tr>
<tr class="separator:a14b5f9eb9ec09c40e558b242e75de872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f8eecb81c090fca9e58d3357b63ed9"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a34f8eecb81c090fca9e58d3357b63ed9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a> (const Container &amp;c, UnaryPredicate <a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:a34f8eecb81c090fca9e58d3357b63ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic test checking whether any elements within a container satisfy a certain predicate.  <a href="#a34f8eecb81c090fca9e58d3357b63ed9">More...</a><br /></td></tr>
<tr class="separator:a34f8eecb81c090fca9e58d3357b63ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58307d673d31e66b4f26149089d7758d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a58307d673d31e66b4f26149089d7758d">appendStmt</a> (std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ram_statement.html">RamStatement</a> &gt;&gt; &amp;stmtList, std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ram_statement.html">RamStatement</a> &gt; stmt)</td></tr>
<tr class="memdesc:a58307d673d31e66b4f26149089d7758d"><td class="mdescLeft">&#160;</td><td class="mdescRight">append statement to a list of statements  <a href="#a58307d673d31e66b4f26149089d7758d">More...</a><br /></td></tr>
<tr class="separator:a58307d673d31e66b4f26149089d7758d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0654c08409f66fdca60d0cc668de83a5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a0654c08409f66fdca60d0cc668de83a5">applySips</a> (<a class="el" href="namespacesouffle.html#ad0dcec7b78fdde7450cb55df1fece164">sips_t</a> sipsFunction, std::vector&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&gt; atoms)</td></tr>
<tr class="memdesc:a0654c08409f66fdca60d0cc668de83a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the new ordering of a vector of atoms after the given SIPS is applied.  <a href="#a0654c08409f66fdca60d0cc668de83a5">More...</a><br /></td></tr>
<tr class="separator:a0654c08409f66fdca60d0cc668de83a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979f111a08bcb653771f92ec4c8c3e16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a979f111a08bcb653771f92ec4c8c3e16">areBijectivelyEquivalent</a> (const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *left, const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *right)</td></tr>
<tr class="memdesc:a979f111a08bcb653771f92ec4c8c3e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two clauses are bijectively equivalent.  <a href="#a979f111a08bcb653771f92ec4c8c3e16">More...</a><br /></td></tr>
<tr class="separator:a979f111a08bcb653771f92ec4c8c3e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac810dd526309dc398254f53e18edf50a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac810dd526309dc398254f53e18edf50a">areSubtypesOf</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;s, const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:ac810dd526309dc398254f53e18edf50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all types in s are subtypes of type b.  <a href="#ac810dd526309dc398254f53e18edf50a">More...</a><br /></td></tr>
<tr class="separator:ac810dd526309dc398254f53e18edf50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbc2262a6164b62766f6fcb67f12ae4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4">baseName</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a9fbc2262a6164b62766f6fcb67f12ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cc6d2beab208ecbf25ddabd458256e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, std::set&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a90cc6d2beab208ecbf25ddabd458256e">bindArguments</a> (<a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *currAtom, std::set&lt; std::string &gt; boundArgs, <a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;compositeBindings)</td></tr>
<tr class="separator:a90cc6d2beab208ecbf25ddabd458256e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6308ee8b92e79229e01daec1d68d6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a5c6308ee8b92e79229e01daec1d68d6a">bindComposites</a> (const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program)</td></tr>
<tr class="separator:a5c6308ee8b92e79229e01daec1d68d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785852c2fc649d79a481627605ffcf4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a785852c2fc649d79a481627605ffcf4f">canBeParsedAsRamFloat</a> (const std::string &amp;string)</td></tr>
<tr class="memdesc:a785852c2fc649d79a481627605ffcf4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can a string be parsed as RamFloat.  <a href="#a785852c2fc649d79a481627605ffcf4f">More...</a><br /></td></tr>
<tr class="separator:a785852c2fc649d79a481627605ffcf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f207449b2332bf06ab28993dda09b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a89f207449b2332bf06ab28993dda09b9">canBeParsedAsRamSigned</a> (const std::string &amp;string)</td></tr>
<tr class="memdesc:a89f207449b2332bf06ab28993dda09b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can a string be parsed as RamSigned.  <a href="#a89f207449b2332bf06ab28993dda09b9">More...</a><br /></td></tr>
<tr class="separator:a89f207449b2332bf06ab28993dda09b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3773094eb7aa42e20a209b40c9873aa4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3773094eb7aa42e20a209b40c9873aa4">canBeParsedAsRamUnsigned</a> (const std::string &amp;string)</td></tr>
<tr class="memdesc:a3773094eb7aa42e20a209b40c9873aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can a string be parsed as RamUnsigned.  <a href="#a3773094eb7aa42e20a209b40c9873aa4">More...</a><br /></td></tr>
<tr class="separator:a3773094eb7aa42e20a209b40c9873aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa523350db005da7a3c79c845ebbb6aa7"><td class="memTemplParams" colspan="2">template&lt;typename toType , typename baseType &gt; </td></tr>
<tr class="memitem:aa523350db005da7a3c79c845ebbb6aa7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa523350db005da7a3c79c845ebbb6aa7">castEq</a> (const baseType *left, const baseType *right)</td></tr>
<tr class="memdesc:aa523350db005da7a3c79c845ebbb6aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the values, from baseType to toType and compare using ==.  <a href="#aa523350db005da7a3c79c845ebbb6aa7">More...</a><br /></td></tr>
<tr class="separator:aa523350db005da7a3c79c845ebbb6aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018886d19f141b1cb565199a517c598f"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a018886d19f141b1cb565199a517c598f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f">clone</a> (const A *node)</td></tr>
<tr class="separator:a018886d19f141b1cb565199a517c598f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5539f3bdbac7d5cc7fc87434aa4adb"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:afd5539f3bdbac7d5cc7fc87434aa4adb"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#afd5539f3bdbac7d5cc7fc87434aa4adb">clone</a> (const std::unique_ptr&lt; A &gt; &amp;node)</td></tr>
<tr class="separator:afd5539f3bdbac7d5cc7fc87434aa4adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b945c962bb01844b4b2032a77e64564"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a7b945c962bb01844b4b2032a77e64564"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; A &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7b945c962bb01844b4b2032a77e64564">clone</a> (const std::vector&lt; std::unique_ptr&lt; A &gt;&gt; &amp;xs)</td></tr>
<tr class="separator:a7b945c962bb01844b4b2032a77e64564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa6d61f4a71ddbb2458d23ce24dbced"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6aa6d61f4a71ddbb2458d23ce24dbced">cloneHead</a> (const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *clause)</td></tr>
<tr class="memdesc:a6aa6d61f4a71ddbb2458d23ce24dbced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a clause which contains head of the given clause.  <a href="#a6aa6d61f4a71ddbb2458d23ce24dbced">More...</a><br /></td></tr>
<tr class="separator:a6aa6d61f4a71ddbb2458d23ce24dbced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c2f399b871f8fe7f0ba652812e2db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a42c2f399b871f8fe7f0ba652812e2db5">combineAggregators</a> (std::vector&lt; <a class="el" href="classsouffle_1_1_ast_aggregator.html">AstAggregator</a> *&gt; aggrs, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a> fun)</td></tr>
<tr class="separator:a42c2f399b871f8fe7f0ba652812e2db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3e2145b6ac09dba3c7ba2e5535935f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a0e3e2145b6ac09dba3c7ba2e5535935f">combineNegatedLiterals</a> (std::vector&lt; std::vector&lt; <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *&gt;&gt; litGroups)</td></tr>
<tr class="memdesc:a0e3e2145b6ac09dba3c7ba2e5535935f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negated version of a disjunction of conjunctions.  <a href="#a0e3e2145b6ac09dba3c7ba2e5535935f">More...</a><br /></td></tr>
<tr class="separator:a0e3e2145b6ac09dba3c7ba2e5535935f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d640155c037c468924198354aae2ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a97d640155c037c468924198354aae2ea">compileToBinary</a> (std::string compileCmd, const std::string &amp;sourceFilename)</td></tr>
<tr class="memdesc:a97d640155c037c468924198354aae2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles the given source file to a binary file.  <a href="#a97d640155c037c468924198354aae2ea">More...</a><br /></td></tr>
<tr class="separator:a97d640155c037c468924198354aae2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a825f62e860ca448e7e16ab1a3a4333"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">contains</a> (std::set&lt; <a class="el" href="classsouffle_1_1_adorned_predicate.html">AdornedPredicate</a> &gt; adornedPredicates, const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;atomName, const std::string &amp;atomAdornment)</td></tr>
<tr class="separator:a8a825f62e860ca448e7e16ab1a3a4333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3295dd83a588d612cf777e600beac4a"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:af3295dd83a588d612cf777e600beac4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af3295dd83a588d612cf777e600beac4a">contains</a> (const C &amp;container, const typename C::value_type &amp;element)</td></tr>
<tr class="memdesc:af3295dd83a588d612cf777e600beac4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility to check generically whether a given element is contained in a given container.  <a href="#af3295dd83a588d612cf777e600beac4a">More...</a><br /></td></tr>
<tr class="separator:af3295dd83a588d612cf777e600beac4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2a6a041cccb09653b996dbeed7b4fd"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:aad2a6a041cccb09653b996dbeed7b4fd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aad2a6a041cccb09653b996dbeed7b4fd">contains</a> (const C &amp;container, const typename C::value_type::first_type &amp;element)</td></tr>
<tr class="memdesc:aad2a6a041cccb09653b996dbeed7b4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of contains specialized for maps.  <a href="#aad2a6a041cccb09653b996dbeed7b4fd">More...</a><br /></td></tr>
<tr class="separator:aad2a6a041cccb09653b996dbeed7b4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb4465d8c07d802fb161440e0399ee1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aeeb4465d8c07d802fb161440e0399ee1">containsAggregators</a> (<a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *clause)</td></tr>
<tr class="separator:aeeb4465d8c07d802fb161440e0399ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48d6e1a779132e5412105fc9cfb85ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af48d6e1a779132e5412105fc9cfb85ed">containsInlinedAtom</a> (const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;clause)</td></tr>
<tr class="memdesc:af48d6e1a779132e5412105fc9cfb85ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given clause contains an atom that should be inlined.  <a href="#af48d6e1a779132e5412105fc9cfb85ed">More...</a><br /></td></tr>
<tr class="separator:af48d6e1a779132e5412105fc9cfb85ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d035bffae77e02ed7a0cc029653e64d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">AggregateOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2d035bffae77e02ed7a0cc029653e64d">convertOverloadedAggregator</a> (const <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">AggregateOp</a> op, const <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> type)</td></tr>
<tr class="memdesc:a2d035bffae77e02ed7a0cc029653e64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert aggregator to a give type.  <a href="#a2d035bffae77e02ed7a0cc029653e64d">More...</a><br /></td></tr>
<tr class="separator:a2d035bffae77e02ed7a0cc029653e64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55155cf1bff3a08e76b26290a08c9d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab55155cf1bff3a08e76b26290a08c9d3">convertOverloadedConstraint</a> (const <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> constraintOp, const <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> toType)</td></tr>
<tr class="memdesc:ab55155cf1bff3a08e76b26290a08c9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <a class="el" href="classsouffle_1_1_constraint.html" title="A generic base class for constraints on variables. ">Constraint</a> to work with requested type.  <a href="#ab55155cf1bff3a08e76b26290a08c9d3">More...</a><br /></td></tr>
<tr class="separator:ab55155cf1bff3a08e76b26290a08c9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbbaeea6848aa8448ccc59a7e404aeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a5fbbaeea6848aa8448ccc59a7e404aeb">convertOverloadedFunctor</a> (const <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a> functor, const <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> toType)</td></tr>
<tr class="memdesc:a5fbbaeea6848aa8448ccc59a7e404aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an overloaded functor, so that it works with the requested type.  <a href="#a5fbbaeea6848aa8448ccc59a7e404aeb">More...</a><br /></td></tr>
<tr class="separator:a5fbbaeea6848aa8448ccc59a7e404aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b1cbb15ab5fafb19d94e2ad5199973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a63b1cbb15ab5fafb19d94e2ad5199973">createAdornedIdentifier</a> (const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;relationName, const std::string &amp;adornment)</td></tr>
<tr class="separator:a63b1cbb15ab5fafb19d94e2ad5199973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42eef65f1512c8189dc19ae26f200acc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a42eef65f1512c8189dc19ae26f200acc">createAnnotatedClause</a> (const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *clause, const std::map&lt; const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *, <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &gt; argumentTypes)</td></tr>
<tr class="separator:a42eef65f1512c8189dc19ae26f200acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f225657563da71823b14982922fcc8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_interpreter_index.html">InterpreterIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a35f225657563da71823b14982922fcc8">createBrieIndex</a> (const <a class="el" href="classsouffle_1_1_order.html">Order</a> &amp;order)</td></tr>
<tr class="separator:a35f225657563da71823b14982922fcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8909e0b79f3b2870f5fc76eb1b23d12"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_interpreter_index.html">InterpreterIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac8909e0b79f3b2870f5fc76eb1b23d12">createBTreeIndex</a> (const <a class="el" href="classsouffle_1_1_order.html">Order</a> &amp;order)</td></tr>
<tr class="separator:ac8909e0b79f3b2870f5fc76eb1b23d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9ba22f7f5dfc45efc499c6d9932b50"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_interpreter_index.html">InterpreterIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#acd9ba22f7f5dfc45efc499c6d9932b50">createBTreeProvenanceIndex</a> (const <a class="el" href="classsouffle_1_1_order.html">Order</a> &amp;order)</td></tr>
<tr class="separator:acd9ba22f7f5dfc45efc499c6d9932b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fab0957729cf0e7759095605a9b099"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_interpreter_index.html">InterpreterIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af5fab0957729cf0e7759095605a9b099">createEqrelIndex</a> (const <a class="el" href="classsouffle_1_1_order.html">Order</a> &amp;order)</td></tr>
<tr class="separator:af5fab0957729cf0e7759095605a9b099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f7b12aa9381c990b2355a126a5eb84"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_interpreter_index.html">InterpreterIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a19f7b12aa9381c990b2355a126a5eb84">createIndirectIndex</a> (const <a class="el" href="classsouffle_1_1_order.html">Order</a> &amp;order)</td></tr>
<tr class="separator:a19f7b12aa9381c990b2355a126a5eb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2012cac577506e366ebdd0791b73ab28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2012cac577506e366ebdd0791b73ab28">createMagicIdentifier</a> (const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;relationName, size_t outputNumber)</td></tr>
<tr class="separator:a2012cac577506e366ebdd0791b73ab28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4b601829be88a59d12c4acc9f3a87f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8a4b601829be88a59d12c4acc9f3a87f">createMagicRelation</a> (<a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *original, const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;magicPredName)</td></tr>
<tr class="separator:a8a4b601829be88a59d12c4acc9f3a87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9327b98da5d4ad231903d0bb9205bbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac9327b98da5d4ad231903d0bb9205bbc">createNewRelation</a> (<a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *original, const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;newName)</td></tr>
<tr class="separator:ac9327b98da5d4ad231903d0bb9205bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55dc44cfd26c10c45a0546e88bf7787"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af55dc44cfd26c10c45a0546e88bf7787">createSubIdentifier</a> (const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;relationName, size_t start, size_t length)</td></tr>
<tr class="separator:af55dc44cfd26c10c45a0546e88bf7787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb411c7585f438a75ef3de5b6ae2abc5"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:aeb411c7585f438a75ef3de5b6ae2abc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_iter_deref_wrapper.html">IterDerefWrapper</a>&lt; Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aeb411c7585f438a75ef3de5b6ae2abc5">derefIter</a> (const Iter &amp;iter)</td></tr>
<tr class="memdesc:aeb411c7585f438a75ef3de5b6ae2abc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory function enabling the construction of a dereferencing iterator utilizing the automated deduction of template parameters.  <a href="#aeb411c7585f438a75ef3de5b6ae2abc5">More...</a><br /></td></tr>
<tr class="separator:aeb411c7585f438a75ef3de5b6ae2abc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e10d44624c80609e5c09b131ecf3fb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a72e10d44624c80609e5c09b131ecf3fb">dirName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a72e10d44624c80609e5c09b131ecf3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++-style dirname.  <a href="#a72e10d44624c80609e5c09b131ecf3fb">More...</a><br /></td></tr>
<tr class="separator:a72e10d44624c80609e5c09b131ecf3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba27d2caf5a777268d89eaf5cbfed2a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8ba27d2caf5a777268d89eaf5cbfed2a">duration_in_ns</a> (const <a class="el" href="namespacesouffle.html#a9eb29a1677ffbe44fe8663f881213f0e">time_point</a> &amp;start, const <a class="el" href="namespacesouffle.html#a9eb29a1677ffbe44fe8663f881213f0e">time_point</a> &amp;end)</td></tr>
<tr class="separator:a8ba27d2caf5a777268d89eaf5cbfed2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3be713865e2b9922aa0eac1fb629041"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af3be713865e2b9922aa0eac1fb629041">duration_in_us</a> (const <a class="el" href="namespacesouffle.html#a9eb29a1677ffbe44fe8663f881213f0e">time_point</a> &amp;start, const <a class="el" href="namespacesouffle.html#a9eb29a1677ffbe44fe8663f881213f0e">time_point</a> &amp;end)</td></tr>
<tr class="separator:af3be713865e2b9922aa0eac1fb629041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e84ddff3bc168499fa141d3a3998494"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6e84ddff3bc168499fa141d3a3998494">endsWith</a> (const std::string &amp;value, const std::string &amp;ending)</td></tr>
<tr class="memdesc:a6e84ddff3bc168499fa141d3a3998494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given value string ends with the given end string.  <a href="#a6e84ddff3bc168499fa141d3a3998494">More...</a><br /></td></tr>
<tr class="separator:a6e84ddff3bc168499fa141d3a3998494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50022778409a94e92bcdc6e27f146161"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50022778409a94e92bcdc6e27f146161"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a50022778409a94e92bcdc6e27f146161">eqTypeTypeAttribute</a> (const <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> ramType, const T &amp;type)</td></tr>
<tr class="memdesc:a50022778409a94e92bcdc6e27f146161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a type analysis' result is equivalent to the given TypeAttribute.  <a href="#a50022778409a94e92bcdc6e27f146161">More...</a><br /></td></tr>
<tr class="separator:a50022778409a94e92bcdc6e27f146161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab097fb451e787a08a185a449bacde2db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab097fb451e787a08a185a449bacde2db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab097fb451e787a08a185a449bacde2db">equal_ptr</a> (const T *a, const T *<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:ab097fb451e787a08a185a449bacde2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two values referenced by a pointer where the case where both pointers are null is also considered equivalent.  <a href="#ab097fb451e787a08a185a449bacde2db">More...</a><br /></td></tr>
<tr class="separator:ab097fb451e787a08a185a449bacde2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b13dfdf28e89958f7adeaa43abbe34f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b13dfdf28e89958f7adeaa43abbe34f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9b13dfdf28e89958f7adeaa43abbe34f">equal_ptr</a> (const std::unique_ptr&lt; T &gt; &amp;a, const std::unique_ptr&lt; T &gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a9b13dfdf28e89958f7adeaa43abbe34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two values referenced by a pointer where the case where both pointers are null is also considered equivalent.  <a href="#a9b13dfdf28e89958f7adeaa43abbe34f">More...</a><br /></td></tr>
<tr class="separator:a9b13dfdf28e89958f7adeaa43abbe34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16e133691dd9963d4234b61e3cc203f"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Comparator &gt; </td></tr>
<tr class="memitem:ae16e133691dd9963d4234b61e3cc203f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae16e133691dd9963d4234b61e3cc203f">equal_targets</a> (const Container &amp;a, const Container &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, const Comparator &amp;comp)</td></tr>
<tr class="memdesc:ae16e133691dd9963d4234b61e3cc203f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two containers are equal with the given Comparator.  <a href="#ae16e133691dd9963d4234b61e3cc203f">More...</a><br /></td></tr>
<tr class="separator:ae16e133691dd9963d4234b61e3cc203f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb99b4f76eebd4491ad16473e4dda5b"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; typename... &gt; class Container&gt; </td></tr>
<tr class="memitem:accb99b4f76eebd4491ad16473e4dda5b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#accb99b4f76eebd4491ad16473e4dda5b">equal_targets</a> (const Container&lt; T *&gt; &amp;a, const Container&lt; T *&gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:accb99b4f76eebd4491ad16473e4dda5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two containers of pointers are referencing equivalent targets.  <a href="#accb99b4f76eebd4491ad16473e4dda5b">More...</a><br /></td></tr>
<tr class="separator:accb99b4f76eebd4491ad16473e4dda5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87752f386ec8b0ab3a1f943d4f29896"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; typename... &gt; class Container&gt; </td></tr>
<tr class="memitem:af87752f386ec8b0ab3a1f943d4f29896"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af87752f386ec8b0ab3a1f943d4f29896">equal_targets</a> (const Container&lt; std::unique_ptr&lt; T &gt;&gt; &amp;a, const Container&lt; std::unique_ptr&lt; T &gt;&gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:af87752f386ec8b0ab3a1f943d4f29896"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two containers of unique pointers are referencing equivalent targets.  <a href="#af87752f386ec8b0ab3a1f943d4f29896">More...</a><br /></td></tr>
<tr class="separator:af87752f386ec8b0ab3a1f943d4f29896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b97dba4d2f55282e3383098bbea3aee"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:a0b97dba4d2f55282e3383098bbea3aee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a0b97dba4d2f55282e3383098bbea3aee">equal_targets</a> (const std::map&lt; Key, std::unique_ptr&lt; Value &gt;&gt; &amp;a, const std::map&lt; Key, std::unique_ptr&lt; Value &gt;&gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a0b97dba4d2f55282e3383098bbea3aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two maps of unique pointers are referencing to equivalent targets.  <a href="#a0b97dba4d2f55282e3383098bbea3aee">More...</a><br /></td></tr>
<tr class="separator:a0b97dba4d2f55282e3383098bbea3aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad78346252bf890fbf93de92aa4a2f73"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aad78346252bf890fbf93de92aa4a2f73">escape</a> (const std::string &amp;inputString, const std::string &amp;needle, const std::string &amp;replacement)</td></tr>
<tr class="separator:aad78346252bf890fbf93de92aa4a2f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b2a40d0e298261a99b89c04424ed56"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a57b2a40d0e298261a99b89c04424ed56">escape</a> (const std::string &amp;inputString)</td></tr>
<tr class="separator:a57b2a40d0e298261a99b89c04424ed56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1056c0ab323cd2951500d84bea3c0aa1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1056c0ab323cd2951500d84bea3c0aa1">escapeJSONstring</a> (const std::string &amp;JSONstr)</td></tr>
<tr class="memdesc:a1056c0ab323cd2951500d84bea3c0aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape JSON string.  <a href="#a1056c0ab323cd2951500d84bea3c0aa1">More...</a><br /></td></tr>
<tr class="separator:a1056c0ab323cd2951500d84bea3c0aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e22287be4345c05c5f70b1d37eaec77"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a5e22287be4345c05c5f70b1d37eaec77">execStdOut</a> (char const *cmd)</td></tr>
<tr class="separator:a5e22287be4345c05c5f70b1d37eaec77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720784b780e625da862d7f7f127f7afb"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a720784b780e625da862d7f7f127f7afb">execStdOut</a> (std::string const &amp;cmd)</td></tr>
<tr class="separator:a720784b780e625da862d7f7f127f7afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1752bf432062837ed19ae6ac73ab177c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1752bf432062837ed19ae6ac73ab177c">executeBinary</a> (const std::string &amp;binaryFilename)</td></tr>
<tr class="memdesc:a1752bf432062837ed19ae6ac73ab177c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a binary file.  <a href="#a1752bf432062837ed19ae6ac73ab177c">More...</a><br /></td></tr>
<tr class="separator:a1752bf432062837ed19ae6ac73ab177c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fa4170c4094bc943de6fa5acb5796e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a79fa4170c4094bc943de6fa5acb5796e">existDir</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a79fa4170c4094bc943de6fa5acb5796e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a directory exists in the file system.  <a href="#a79fa4170c4094bc943de6fa5acb5796e">More...</a><br /></td></tr>
<tr class="separator:a79fa4170c4094bc943de6fa5acb5796e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69107e934a60222580ee8ba6882dc3d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">existFile</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a69107e934a60222580ee8ba6882dc3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a file exists in the file system.  <a href="#a69107e934a60222580ee8ba6882dc3d3">More...</a><br /></td></tr>
<tr class="separator:a69107e934a60222580ee8ba6882dc3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c20b82d0becb6b4e3b780c2c87cc62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab5c20b82d0becb6b4e3b780c2c87cc62">explain</a> (<a class="el" href="classsouffle_1_1_souffle_program.html">SouffleProgram</a> &amp;prog, bool ncurses, bool useSubtreelevels)</td></tr>
<tr class="separator:ab5c20b82d0becb6b4e3b780c2c87cc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014bc04f4629bd77f3a54c26fe9ea53d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a014bc04f4629bd77f3a54c26fe9ea53d">extractAdornment</a> (const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;magicRelationName)</td></tr>
<tr class="separator:a014bc04f4629bd77f3a54c26fe9ea53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9432bd085b7e03ea3e138804915e3b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af9432bd085b7e03ea3e138804915e3b4">extractConstant</a> (const std::string &amp;normalisedConstant)</td></tr>
<tr class="separator:af9432bd085b7e03ea3e138804915e3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b103a79e1c9886c80cff614ba6ef93"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a63b103a79e1c9886c80cff614ba6ef93">extractPermutations</a> (const std::vector&lt; std::vector&lt; unsigned int &gt;&gt; &amp;permutationMatrix)</td></tr>
<tr class="memdesc:a63b103a79e1c9886c80cff614ba6ef93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract valid permutations from a given permutation matrix of valid moves.  <a href="#a63b103a79e1c9886c80cff614ba6ef93">More...</a><br /></td></tr>
<tr class="separator:a63b103a79e1c9886c80cff614ba6ef93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3419b4e4df09a580063d2f078a3774"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8e3419b4e4df09a580063d2f078a3774">fileExtension</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a8e3419b4e4df09a580063d2f078a3774"><td class="mdescLeft">&#160;</td><td class="mdescRight">File extension, with all else removed.  <a href="#a8e3419b4e4df09a580063d2f078a3774">More...</a><br /></td></tr>
<tr class="separator:a8e3419b4e4df09a580063d2f078a3774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51824bd98651cf614b712d360070e97"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab51824bd98651cf614b712d360070e97">findInlineCycle</a> (const <a class="el" href="classsouffle_1_1_precedence_graph.html">PrecedenceGraph</a> &amp;precedenceGraph, std::map&lt; const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *, const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&gt; &amp;origins, const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *current, <a class="el" href="namespacesouffle.html#a851652d425321cd735fbe321f392fe85">AstRelationSet</a> &amp;unvisited, <a class="el" href="namespacesouffle.html#a851652d425321cd735fbe321f392fe85">AstRelationSet</a> &amp;visiting, <a class="el" href="namespacesouffle.html#a851652d425321cd735fbe321f392fe85">AstRelationSet</a> &amp;visited)</td></tr>
<tr class="memdesc:ab51824bd98651cf614b712d360070e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a cycle consisting entirely of inlined relations.  <a href="#ab51824bd98651cf614b712d360070e97">More...</a><br /></td></tr>
<tr class="separator:ab51824bd98651cf614b712d360070e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af944f0c474df29e5c8e45e4b7df60be5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af944f0c474df29e5c8e45e4b7df60be5">findTool</a> (const std::string &amp;tool, const std::string &amp;<a class="el" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a>, const std::string &amp;path)</td></tr>
<tr class="separator:af944f0c474df29e5c8e45e4b7df60be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857e90591811f5da8f9f86461c2f697c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_debug_report_section.html">DebugReportSection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a857e90591811f5da8f9f86461c2f697c">formatCodeSection</a> (const std::string &amp;<a class="el" href="structsouffle_1_1id.html">id</a>, const std::string &amp;title, std::string code)</td></tr>
<tr class="separator:a857e90591811f5da8f9f86461c2f697c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5ef82376f71d4d7ebfcfa64437d540"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2e5ef82376f71d4d7ebfcfa64437d540">formNegatedLiterals</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *atom)</td></tr>
<tr class="memdesc:a2e5ef82376f71d4d7ebfcfa64437d540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the bodies that will replace the negation of a given inlined atom.  <a href="#a2e5ef82376f71d4d7ebfcfa64437d540">More...</a><br /></td></tr>
<tr class="separator:a2e5ef82376f71d4d7ebfcfa64437d540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100b2775490c4c9f1d565290237ee51a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a100b2775490c4c9f1d565290237ee51a">functorOpArgType</a> (const size_t arg, const <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a> op)</td></tr>
<tr class="memdesc:a100b2775490c4c9f1d565290237ee51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the type of argument indicated by arg (0-indexed) of a functor op.  <a href="#a100b2775490c4c9f1d565290237ee51a">More...</a><br /></td></tr>
<tr class="separator:a100b2775490c4c9f1d565290237ee51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924f2efd1cd04ea4336ba44b6aa18e72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a924f2efd1cd04ea4336ba44b6aa18e72">functorReturnType</a> (const <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a> op)</td></tr>
<tr class="memdesc:a924f2efd1cd04ea4336ba44b6aa18e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a functor's return type (codomain).  <a href="#a924f2efd1cd04ea4336ba44b6aa18e72">More...</a><br /></td></tr>
<tr class="separator:a924f2efd1cd04ea4336ba44b6aa18e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8dc819c0300aaaafa4ef9c7cdd84d4d"><td class="memItemLeft" align="right" valign="top">std::stringstream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae8dc819c0300aaaafa4ef9c7cdd84d4d">genJsonRules</a> (std::stringstream &amp;ss, const std::string &amp;name, size_t maxRows)</td></tr>
<tr class="separator:ae8dc819c0300aaaafa4ef9c7cdd84d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18cbb3adc2ab328de0db30a3fddf7e0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">getAtomRelation</a> (const <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *atom, const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program)</td></tr>
<tr class="memdesc:ab18cbb3adc2ab328de0db30a3fddf7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relation referenced by the given atom.  <a href="#ab18cbb3adc2ab328de0db30a3fddf7e0">More...</a><br /></td></tr>
<tr class="separator:ab18cbb3adc2ab328de0db30a3fddf7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805c988064a360bd5c8bdbc84ae541ae"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a805c988064a360bd5c8bdbc84ae541ae">getBinaryConstraintTypes</a> (const <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> op)</td></tr>
<tr class="memdesc:a805c988064a360bd5c8bdbc84ae541ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type binary constraint operates on.  <a href="#a805c988064a360bd5c8bdbc84ae541ae">More...</a><br /></td></tr>
<tr class="separator:a805c988064a360bd5c8bdbc84ae541ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c0ee8e7896baeb355bd776229e1142"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C &gt; </td></tr>
<tr class="memitem:a96c0ee8e7896baeb355bd776229e1142"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a96c0ee8e7896baeb355bd776229e1142">getBodyLiterals</a> (const C &amp;clause)</td></tr>
<tr class="memdesc:a96c0ee8e7896baeb355bd776229e1142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns literals of a particular type in the body of a clause.  <a href="#a96c0ee8e7896baeb355bd776229e1142">More...</a><br /></td></tr>
<tr class="separator:a96c0ee8e7896baeb355bd776229e1142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598a4ed07c31abae549ab7461fb9b7ee"><td class="memItemLeft" align="right" valign="top">std::set&lt; const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a598a4ed07c31abae549ab7461fb9b7ee">getBodyRelations</a> (const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *clause, const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program)</td></tr>
<tr class="memdesc:a598a4ed07c31abae549ab7461fb9b7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relations referenced in the body of the given clause.  <a href="#a598a4ed07c31abae549ab7461fb9b7ee">More...</a><br /></td></tr>
<tr class="separator:a598a4ed07c31abae549ab7461fb9b7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f78efaeb4338f70e2dcab6bd0638d2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac4f78efaeb4338f70e2dcab6bd0638d2">getClauseNum</a> (const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program, const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *clause)</td></tr>
<tr class="memdesc:ac4f78efaeb4338f70e2dcab6bd0638d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of a clause within its relation, ignoring facts.  <a href="#ac4f78efaeb4338f70e2dcab6bd0638d2">More...</a><br /></td></tr>
<tr class="separator:ac4f78efaeb4338f70e2dcab6bd0638d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9e53888640a9abfd7ea7c43715152a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">getClauses</a> (const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;relationName)</td></tr>
<tr class="memdesc:a4d9e53888640a9abfd7ea7c43715152a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of clauses in the program describing the relation with the given name.  <a href="#a4d9e53888640a9abfd7ea7c43715152a">More...</a><br /></td></tr>
<tr class="separator:a4d9e53888640a9abfd7ea7c43715152a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca5420316b1f3e64bc8f87a26a0c05c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a4ca5420316b1f3e64bc8f87a26a0c05c">getClauses</a> (const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> &amp;rel)</td></tr>
<tr class="memdesc:a4ca5420316b1f3e64bc8f87a26a0c05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of clauses in the program describing the given relation.  <a href="#a4ca5420316b1f3e64bc8f87a26a0c05c">More...</a><br /></td></tr>
<tr class="separator:a4ca5420316b1f3e64bc8f87a26a0c05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefdc21106bf028c4de1db83d933d0b4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aaefdc21106bf028c4de1db83d933d0b4">getCurrentFilename</a> (const std::vector&lt; std::string &gt; &amp;filenames)</td></tr>
<tr class="separator:aaefdc21106bf028c4de1db83d933d0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620dc7687473311acaa752a76b5c9470"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a620dc7687473311acaa752a76b5c9470">getEndpoint</a> (std::string mainName)</td></tr>
<tr class="separator:a620dc7687473311acaa752a76b5c9470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ec038f787c926d16d63206d73d4724"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsouffle_1_1_ast_functor_declaration.html">AstFunctorDeclaration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a68ec038f787c926d16d63206d73d4724">getFunctorDeclaration</a> (const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, const std::string &amp;name)</td></tr>
<tr class="memdesc:a68ec038f787c926d16d63206d73d4724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the functor declaration with the given name in the program.  <a href="#a68ec038f787c926d16d63206d73d4724">More...</a><br /></td></tr>
<tr class="separator:a68ec038f787c926d16d63206d73d4724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb20659f25b4513908b813cfdbf43e23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#abb20659f25b4513908b813cfdbf43e23">getGreatestCommonSubtypes</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;a, const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:abb20659f25b4513908b813cfdbf43e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common sub types of the two given types.  <a href="#abb20659f25b4513908b813cfdbf43e23">More...</a><br /></td></tr>
<tr class="separator:abb20659f25b4513908b813cfdbf43e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2a47b9395910d9fc183cf16ec0ed38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3c2a47b9395910d9fc183cf16ec0ed38">getGreatestCommonSubtypes</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;set)</td></tr>
<tr class="memdesc:a3c2a47b9395910d9fc183cf16ec0ed38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common sub types of all the types in the given set.  <a href="#a3c2a47b9395910d9fc183cf16ec0ed38">More...</a><br /></td></tr>
<tr class="separator:a3c2a47b9395910d9fc183cf16ec0ed38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5ab68f123baedeb78d6c94920deb5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aed5ab68f123baedeb78d6c94920deb5d">getGreatestCommonSubtypes</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;a, const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:aed5ab68f123baedeb78d6c94920deb5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of pair-wise greatest common sub types of the types in the two given sets.  <a href="#aed5ab68f123baedeb78d6c94920deb5d">More...</a><br /></td></tr>
<tr class="separator:aed5ab68f123baedeb78d6c94920deb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae842d250436dbed4b6479bf915fcf363"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ae842d250436dbed4b6479bf915fcf363"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae842d250436dbed4b6479bf915fcf363">getGreatestCommonSubtypes</a> (const Types &amp;... <a class="el" href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>)</td></tr>
<tr class="memdesc:ae842d250436dbed4b6479bf915fcf363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common sub types of the given types.  <a href="#ae842d250436dbed4b6479bf915fcf363">More...</a><br /></td></tr>
<tr class="separator:ae842d250436dbed4b6479bf915fcf363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247fd46943465169ffe79f25628e5dad"><td class="memItemLeft" align="right" valign="top">std::map&lt; const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a247fd46943465169ffe79f25628e5dad">getGroundedTerms</a> (const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;clause)</td></tr>
<tr class="memdesc:a247fd46943465169ffe79f25628e5dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyse the given clause and computes for each contained argument whether it is a grounded value or not.  <a href="#a247fd46943465169ffe79f25628e5dad">More...</a><br /></td></tr>
<tr class="separator:a247fd46943465169ffe79f25628e5dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5266d9360a88847a65d1c581f778d89"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae5266d9360a88847a65d1c581f778d89">getHeadRelation</a> (const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *clause, const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program)</td></tr>
<tr class="memdesc:ae5266d9360a88847a65d1c581f778d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relation referenced by the head of the given clause.  <a href="#ae5266d9360a88847a65d1c581f778d89">More...</a><br /></td></tr>
<tr class="separator:ae5266d9360a88847a65d1c581f778d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f80c157a6a365d78a43592732a8efa"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a62f80c157a6a365d78a43592732a8efa"><td class="memTemplItemLeft" align="right" valign="top">C::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa">getIf</a> (const C &amp;container, std::function&lt; bool(const typename C::value_type)&gt; pred)</td></tr>
<tr class="memdesc:a62f80c157a6a365d78a43592732a8efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element in a container that satisfies a given predicate, nullptr otherwise.  <a href="#a62f80c157a6a365d78a43592732a8efa">More...</a><br /></td></tr>
<tr class="separator:a62f80c157a6a365d78a43592732a8efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddc699418d426e1ffcb965e37ccb3a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt; <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *arg)</td></tr>
<tr class="memdesc:aeddc699418d426e1ffcb965e37ccb3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of arguments that should replace the given argument after one step of inlining.  <a href="#aeddc699418d426e1ffcb965e37ccb3a2">More...</a><br /></td></tr>
<tr class="separator:aeddc699418d426e1ffcb965e37ccb3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae2dc0fd43bd8abb26027c3f2f448d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1">getInlinedAtom</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> &amp;atom)</td></tr>
<tr class="memdesc:a8ae2dc0fd43bd8abb26027c3f2f448d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of atoms that should replace the given atom after one step of inlining.  <a href="#a8ae2dc0fd43bd8abb26027c3f2f448d1">More...</a><br /></td></tr>
<tr class="separator:a8ae2dc0fd43bd8abb26027c3f2f448d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4639aeb42a36253468c45df580e18bf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac4639aeb42a36253468c45df580e18bf">getInlinedClause</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;clause)</td></tr>
<tr class="memdesc:ac4639aeb42a36253468c45df580e18bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of clauses that should replace the given clause after one step of inlining.  <a href="#ac4639aeb42a36253468c45df580e18bf">More...</a><br /></td></tr>
<tr class="separator:ac4639aeb42a36253468c45df580e18bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b07f1c5efea50145140a31f755e0d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt; std::vector&lt; <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1">getInlinedLiteral</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *lit)</td></tr>
<tr class="memdesc:a25b07f1c5efea50145140a31f755e0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to perform a single step of inlining on the given literal.  <a href="#a25b07f1c5efea50145140a31f755e0d1">More...</a><br /></td></tr>
<tr class="separator:a25b07f1c5efea50145140a31f755e0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7814a3034094392e5744454c68463cc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_souffle_program.html">souffle::SouffleProgram</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7814a3034094392e5744454c68463cc5">getInstance</a> (const char *<a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="separator:a7814a3034094392e5744454c68463cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aecaefb22443dc01bb4c208cb6aabdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8aecaefb22443dc01bb4c208cb6aabdf">getLeastCommonSupertypes</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;a, const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a8aecaefb22443dc01bb4c208cb6aabdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the least common super types of the two given types.  <a href="#a8aecaefb22443dc01bb4c208cb6aabdf">More...</a><br /></td></tr>
<tr class="separator:a8aecaefb22443dc01bb4c208cb6aabdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e40a76eef0a150ef9c20743b95f589e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3e40a76eef0a150ef9c20743b95f589e">getLeastCommonSupertypes</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;set)</td></tr>
<tr class="memdesc:a3e40a76eef0a150ef9c20743b95f589e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the least common super types of all the types in the given set.  <a href="#a3e40a76eef0a150ef9c20743b95f589e">More...</a><br /></td></tr>
<tr class="separator:a3e40a76eef0a150ef9c20743b95f589e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5fe6f4fe0781dfc619f8640a1631d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8e5fe6f4fe0781dfc619f8640a1631d3">getLeastCommonSupertypes</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;a, const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a8e5fe6f4fe0781dfc619f8640a1631d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of pair-wise least common super types of the types in the two given sets.  <a href="#a8e5fe6f4fe0781dfc619f8640a1631d3">More...</a><br /></td></tr>
<tr class="separator:a8e5fe6f4fe0781dfc619f8640a1631d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172efe6c434b6ded80903a16f2535cae"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a172efe6c434b6ded80903a16f2535cae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a172efe6c434b6ded80903a16f2535cae">getLeastCommonSupertypes</a> (const Types &amp;... <a class="el" href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>)</td></tr>
<tr class="memdesc:a172efe6c434b6ded80903a16f2535cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the least common super types of the given types.  <a href="#a172efe6c434b6ded80903a16f2535cae">More...</a><br /></td></tr>
<tr class="separator:a172efe6c434b6ded80903a16f2535cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4221a3f8bea9103ac8244e7709fbf1bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a4221a3f8bea9103ac8244e7709fbf1bc">getNextAtomMaxBoundSIPS</a> (std::vector&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&gt; &amp;atoms, const std::set&lt; std::string &gt; &amp;boundArgs, const std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt; &amp;edb, <a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;compositeBindings)</td></tr>
<tr class="separator:a4221a3f8bea9103ac8244e7709fbf1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa310599bd78295747a8d56b3dd6cd1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3aa310599bd78295747a8d56b3dd6cd1">getNextAtomMaxRatioSIPS</a> (std::vector&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&gt; &amp;atoms, const std::set&lt; std::string &gt; &amp;boundArgs, const std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt; &amp;, <a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;compositeBindings)</td></tr>
<tr class="separator:a3aa310599bd78295747a8d56b3dd6cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96942dfde31987eafed7489366283f66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a96942dfde31987eafed7489366283f66">getNextAtomNaiveSIPS</a> (std::vector&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&gt; atoms, const std::set&lt; std::string &gt; &amp;boundArgs, const std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt; &amp;edb, <a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;compositeBindings)</td></tr>
<tr class="separator:a96942dfde31987eafed7489366283f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d63e6f1d133be7f1d35c3f2a331c0e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae1d63e6f1d133be7f1d35c3f2a331c0e">getNextAtomSIPS</a> (std::vector&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&gt; &amp;atoms, std::set&lt; std::string &gt; boundArgs, std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt; edb, <a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;compositeBindings)</td></tr>
<tr class="separator:ae1d63e6f1d133be7f1d35c3f2a331c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb526d569fc848583a59613102f660d3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aeb526d569fc848583a59613102f660d3">getNextEdbName</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program)</td></tr>
<tr class="separator:aeb526d569fc848583a59613102f660d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48147c448827024d87c8fd8797470196"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a48147c448827024d87c8fd8797470196"><td class="memTemplItemLeft" align="right" valign="top">C::mapped_type const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a48147c448827024d87c8fd8797470196">getOr</a> (const C &amp;container, typename C::key_type key, const typename C::mapped_type &amp;defaultValue)</td></tr>
<tr class="memdesc:a48147c448827024d87c8fd8797470196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value for a given key; if not found, return default value.  <a href="#a48147c448827024d87c8fd8797470196">More...</a><br /></td></tr>
<tr class="separator:a48147c448827024d87c8fd8797470196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3d2bbfbcd58c76463920d43a29b3d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1_lock.html">Lock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1f3d2bbfbcd58c76463920d43a29b3d0">getOutputLock</a> ()</td></tr>
<tr class="memdesc:a1f3d2bbfbcd58c76463920d43a29b3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a reference to the lock synchronizing output operations.  <a href="#a1f3d2bbfbcd58c76463920d43a29b3d0">More...</a><br /></td></tr>
<tr class="separator:a1f3d2bbfbcd58c76463920d43a29b3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9726f0afbc98fa9807f0ba3bff93ba56"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classsouffle_1_1_ast_record_init.html">AstRecordInit</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9726f0afbc98fa9807f0ba3bff93ba56">getRecords</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root)</td></tr>
<tr class="memdesc:a9726f0afbc98fa9807f0ba3bff93ba56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a list of all records referenced within the AST rooted by the given root node.  <a href="#a9726f0afbc98fa9807f0ba3bff93ba56">More...</a><br /></td></tr>
<tr class="separator:a9726f0afbc98fa9807f0ba3bff93ba56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada252aa15afbf7d703a11b000dfd4048"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">getRelation</a> (const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;name)</td></tr>
<tr class="memdesc:ada252aa15afbf7d703a11b000dfd4048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relation with the given name in the program.  <a href="#ada252aa15afbf7d703a11b000dfd4048">More...</a><br /></td></tr>
<tr class="separator:ada252aa15afbf7d703a11b000dfd4048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3060fa0568d3ce72ce5ac14941af29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#a4d1111156440d898474b3cd9cd43a276">RelationQualifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#acb3060fa0568d3ce72ce5ac14941af29">getRelationQualifierFromTag</a> (const <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529f">RelationTag</a> &amp;tag)</td></tr>
<tr class="memdesc:acb3060fa0568d3ce72ce5ac14941af29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the corresponding RelationQualifier for a valid RelationTag.  <a href="#acb3060fa0568d3ce72ce5ac14941af29">More...</a><br /></td></tr>
<tr class="separator:acb3060fa0568d3ce72ce5ac14941af29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276d79bb2f106919b0baeb7fcf7d838c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9e">RelationRepresentation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a276d79bb2f106919b0baeb7fcf7d838c">getRelationRepresentationFromTag</a> (const <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529f">RelationTag</a> &amp;tag)</td></tr>
<tr class="memdesc:a276d79bb2f106919b0baeb7fcf7d838c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the corresponding RelationRepresentation for a valid RelationTag.  <a href="#a276d79bb2f106919b0baeb7fcf7d838c">More...</a><br /></td></tr>
<tr class="separator:a276d79bb2f106919b0baeb7fcf7d838c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34387241fab1e3ecc054fed02cee2d0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#ad0dcec7b78fdde7450cb55df1fece164">sips_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a34387241fab1e3ecc054fed02cee2d0d">getSipsFunction</a> (const std::string &amp;sipsChosen)</td></tr>
<tr class="memdesc:a34387241fab1e3ecc054fed02cee2d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a SIPS function based on the SIPS option provided.  <a href="#a34387241fab1e3ecc054fed02cee2d0d">More...</a><br /></td></tr>
<tr class="separator:a34387241fab1e3ecc054fed02cee2d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c9919e28ef370c84f30355144ccb81"><td class="memItemLeft" align="right" valign="top">ss&lt;&lt; R&quot;_(&quot;code&quot;: [)_&quot;;bool firstCol=true;while(getline(source_file, <a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>)) { comma(firstCol, &quot;,\&quot;);ss&lt;&lt; '&quot;' &lt;&lt; Tools::cleanJsonOut(<a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>) &lt;&lt; '&quot;';} ss&lt;&lt; &quot;],\&quot;;source_file.close();} auto usages=getUsageStats(100);auto beginTime=run-&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa8c9919e28ef370c84f30355144ccb81">getStarttime</a> ()</td></tr>
<tr class="separator:aa8c9919e28ef370c84f30355144ccb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526256b2f4d593cceb8b73068e7de882"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a526256b2f4d593cceb8b73068e7de882">getString</a> (const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *arg)</td></tr>
<tr class="separator:a526256b2f4d593cceb8b73068e7de882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5684d03fd4d404219e054226b94c19"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9d5684d03fd4d404219e054226b94c19">getSymbolForFunctorOp</a> (const <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a> op)</td></tr>
<tr class="memdesc:a9d5684d03fd4d404219e054226b94c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string representation of a functor.  <a href="#a9d5684d03fd4d404219e054226b94c19">More...</a><br /></td></tr>
<tr class="separator:a9d5684d03fd4d404219e054226b94c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df5320dfcc5fe6ad9bbda0edc5876bc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsouffle_1_1_ast_type.html">AstType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc">getType</a> (const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;name)</td></tr>
<tr class="memdesc:a0df5320dfcc5fe6ad9bbda0edc5876bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type with the given name in the program.  <a href="#a0df5320dfcc5fe6ad9bbda0edc5876bc">More...</a><br /></td></tr>
<tr class="separator:a0df5320dfcc5fe6ad9bbda0edc5876bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2ff9f374555126a532203710149346"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe2ff9f374555126a532203710149346"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#afe2ff9f374555126a532203710149346">getTypeAttribute</a> (const T &amp;type)</td></tr>
<tr class="memdesc:afe2ff9f374555126a532203710149346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a type analysis' type/set of type to the the TypeAttribute.  <a href="#afe2ff9f374555126a532203710149346">More...</a><br /></td></tr>
<tr class="separator:afe2ff9f374555126a532203710149346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ad723d37a06f19c0789053f63a3e6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab9ad723d37a06f19c0789053f63a3e6b">getTypeAttributeAggregate</a> (const <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">AggregateOp</a> op)</td></tr>
<tr class="memdesc:ab9ad723d37a06f19c0789053f63a3e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get return type of the aggregate.  <a href="#ab9ad723d37a06f19c0789053f63a3e6b">More...</a><br /></td></tr>
<tr class="separator:ab9ad723d37a06f19c0789053f63a3e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6fe661fa54da7de4dccc65c8f82834"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a0d6fe661fa54da7de4dccc65c8f82834">getTypeQualifier</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:a0d6fe661fa54da7de4dccc65c8f82834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns full type qualifier for a given type.  <a href="#a0d6fe661fa54da7de4dccc65c8f82834">More...</a><br /></td></tr>
<tr class="separator:a0d6fe661fa54da7de4dccc65c8f82834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd078c141c96076832b98038f39e4d48"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classsouffle_1_1_ast_variable.html">AstVariable</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#acd078c141c96076832b98038f39e4d48">getVariables</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root)</td></tr>
<tr class="memdesc:acd078c141c96076832b98038f39e4d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a list of all variables referenced within the AST rooted by the given root node.  <a href="#acd078c141c96076832b98038f39e4d48">More...</a><br /></td></tr>
<tr class="separator:acd078c141c96076832b98038f39e4d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1c5f7d59161b1c204ead73986cc0cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2c1c5f7d59161b1c204ead73986cc0cf">hasBoundArgument</a> (<a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *atom, const std::set&lt; std::string &gt; &amp;boundArgs, <a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;compositeBindings)</td></tr>
<tr class="separator:a2c1c5f7d59161b1c204ead73986cc0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae039656df27f6089ef34a0a4455dce5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aae039656df27f6089ef34a0a4455dce5">hasClauseWithAggregatedRelation</a> (const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *<a class="el" href="_reader_8h.html#abd6f77243e31b9c48f104efeed27c546">relation</a>, const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *aggRelation, const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program, const <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *&amp;foundLiteral)</td></tr>
<tr class="memdesc:aae039656df27f6089ef34a0a4455dce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given relation has any clauses which contain an aggregation over of a specific relation.  <a href="#aae039656df27f6089ef34a0a4455dce5">More...</a><br /></td></tr>
<tr class="separator:aae039656df27f6089ef34a0a4455dce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93b9d78c10c77c6d4ab227d5f9b389a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab93b9d78c10c77c6d4ab227d5f9b389a">hasClauseWithNegatedRelation</a> (const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *<a class="el" href="_reader_8h.html#abd6f77243e31b9c48f104efeed27c546">relation</a>, const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *negRelation, const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program, const <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *&amp;foundLiteral)</td></tr>
<tr class="memdesc:ab93b9d78c10c77c6d4ab227d5f9b389a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given relation has any clauses which contain a negation of a specific relation.  <a href="#ab93b9d78c10c77c6d4ab227d5f9b389a">More...</a><br /></td></tr>
<tr class="separator:ab93b9d78c10c77c6d4ab227d5f9b389a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732d351e2af0d4c5578be62e979a8a32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a732d351e2af0d4c5578be62e979a8a32">hasFloatType</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;<a class="el" href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>)</td></tr>
<tr class="memdesc:a732d351e2af0d4c5578be62e979a8a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is any value in the set float.  <a href="#a732d351e2af0d4c5578be62e979a8a32">More...</a><br /></td></tr>
<tr class="separator:a732d351e2af0d4c5578be62e979a8a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c80a38e0b1c4617f373aba8d2c7198"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198">hasPrefix</a> (const std::string &amp;<a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, const std::string &amp;prefix)</td></tr>
<tr class="separator:ae0c80a38e0b1c4617f373aba8d2c7198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bb9767056b00fd49a4097b59cb07d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a31bb9767056b00fd49a4097b59cb07d9">hasSignedType</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;<a class="el" href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>)</td></tr>
<tr class="memdesc:a31bb9767056b00fd49a4097b59cb07d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is any value in the set signed.  <a href="#a31bb9767056b00fd49a4097b59cb07d9">More...</a><br /></td></tr>
<tr class="separator:a31bb9767056b00fd49a4097b59cb07d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c77d8cc2a9414cd6aeb5d02c74e162d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2c77d8cc2a9414cd6aeb5d02c74e162d">hasUnnamedVariable</a> (const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *arg)</td></tr>
<tr class="separator:a2c77d8cc2a9414cd6aeb5d02c74e162d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb328ce61aedddf363f53be8e445a8e0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a> (const <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *lit)</td></tr>
<tr class="separator:abb328ce61aedddf363f53be8e445a8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40316bc7e86831e18498b814b5af7fbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a40316bc7e86831e18498b814b5af7fbc">hasUnsignedType</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;<a class="el" href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>)</td></tr>
<tr class="memdesc:a40316bc7e86831e18498b814b5af7fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is any value in the set unsigned.  <a href="#a40316bc7e86831e18498b814b5af7fbc">More...</a><br /></td></tr>
<tr class="separator:a40316bc7e86831e18498b814b5af7fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e8debde5608979e041dd30e044612a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad0e8debde5608979e041dd30e044612a">identifier</a> (std::string <a class="el" href="structsouffle_1_1id.html">id</a>)</td></tr>
<tr class="memdesc:ad0e8debde5608979e041dd30e044612a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valid C++ identifier, note that this does not ensure the uniqueness of identifiers returned.  <a href="#ad0e8debde5608979e041dd30e044612a">More...</a><br /></td></tr>
<tr class="separator:ad0e8debde5608979e041dd30e044612a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6cb3ac93eb86027865121aff551fde"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3c6cb3ac93eb86027865121aff551fde">identifierToString</a> (const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;name)</td></tr>
<tr class="memdesc:a3c6cb3ac93eb86027865121aff551fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions.  <a href="#a3c6cb3ac93eb86027865121aff551fde">More...</a><br /></td></tr>
<tr class="separator:a3c6cb3ac93eb86027865121aff551fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfca9e9addfda4f3e1ee38cbef0d7c0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt; <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> * &gt;, std::vector&lt; <a class="el" href="classsouffle_1_1_ast_binary_constraint.html">AstBinaryConstraint</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7dfca9e9addfda4f3e1ee38cbef0d7c0">inlineBodyLiterals</a> (<a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *atom, <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *atomInlineClause)</td></tr>
<tr class="memdesc:a7dfca9e9addfda4f3e1ee38cbef0d7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlines the given atom based on a given clause.  <a href="#a7dfca9e9addfda4f3e1ee38cbef0d7c0">More...</a><br /></td></tr>
<tr class="separator:a7dfca9e9addfda4f3e1ee38cbef0d7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79a8035af8360fb110ee30292d9280d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac79a8035af8360fb110ee30292d9280d">isAggRel</a> (const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;rel)</td></tr>
<tr class="separator:ac79a8035af8360fb110ee30292d9280d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f8bfe9b5546db6b9c75d4c5b968d74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a01f8bfe9b5546db6b9c75d4c5b968d74">isBindingConstraint</a> (<a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *<a class="el" href="_resolve_aliases_transformer_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>, <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *<a class="el" href="_resolve_aliases_transformer_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a>, std::set&lt; std::string &gt; boundArgs)</td></tr>
<tr class="separator:a01f8bfe9b5546db6b9c75d4c5b968d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5048549cddd623327a828a4cc90fe746"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a5048549cddd623327a828a4cc90fe746">isBoundArgument</a> (<a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *arg, const std::set&lt; std::string &gt; &amp;boundArgs, <a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;compositeBindings)</td></tr>
<tr class="separator:a5048549cddd623327a828a4cc90fe746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2a34e7c27740b381cf558eeebb28e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a4d2a34e7c27740b381cf558eeebb28e4">isBoundComposite</a> (const <a class="el" href="classsouffle_1_1_ast_variable.html">AstVariable</a> *compositeVariable, const std::set&lt; std::string &gt; &amp;boundArgs, <a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;compositeBindings)</td></tr>
<tr class="separator:a4d2a34e7c27740b381cf558eeebb28e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d324369b5fc672d6cde86cb6c20e304"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2d324369b5fc672d6cde86cb6c20e304">isConstantArithExpr</a> (const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> &amp;argument)</td></tr>
<tr class="separator:a2d324369b5fc672d6cde86cb6c20e304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6befeedfd76433e1bd51a1f6cd42afec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6befeedfd76433e1bd51a1f6cd42afec">isEqConstraint</a> (const <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> constraintOp)</td></tr>
<tr class="separator:a6befeedfd76433e1bd51a1f6cd42afec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae135d2382a133fa5b036296fbd7f60a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aae135d2382a133fa5b036296fbd7f60a">isEqualAdornment</a> (const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;pred1, const std::string &amp;adorn1, const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;pred2, const std::string &amp;adorn2)</td></tr>
<tr class="separator:aae135d2382a133fa5b036296fbd7f60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64753e143a37bb9414121fc75987cb14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">isExecutable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a64753e143a37bb9414121fc75987cb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a given file exists and it is an executable.  <a href="#a64753e143a37bb9414121fc75987cb14">More...</a><br /></td></tr>
<tr class="separator:a64753e143a37bb9414121fc75987cb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b6e248ec714e64f38ce032caf5f477"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae4b6e248ec714e64f38ce032caf5f477">isFact</a> (const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;clause)</td></tr>
<tr class="memdesc:ae4b6e248ec714e64f38ce032caf5f477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given clause is a fact.  <a href="#ae4b6e248ec714e64f38ce032caf5f477">More...</a><br /></td></tr>
<tr class="separator:ae4b6e248ec714e64f38ce032caf5f477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7d8cb2f6a29f825e650a7c98487718"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1a7d8cb2f6a29f825e650a7c98487718">isFloatType</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:a1a7d8cb2f6a29f825e650a7c98487718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a float type.  <a href="#a1a7d8cb2f6a29f825e650a7c98487718">More...</a><br /></td></tr>
<tr class="separator:a1a7d8cb2f6a29f825e650a7c98487718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f74749ac26b7299879fe633fcdc105b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2f74749ac26b7299879fe633fcdc105b">isFloatType</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;s)</td></tr>
<tr class="memdesc:a2f74749ac26b7299879fe633fcdc105b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the types in the given set are float types.  <a href="#a2f74749ac26b7299879fe633fcdc105b">More...</a><br /></td></tr>
<tr class="separator:a2f74749ac26b7299879fe633fcdc105b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1d652d2d52b327b057b11fd0eb1331"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8b1d652d2d52b327b057b11fd0eb1331">isInfixFunctorOp</a> (const <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a> op)</td></tr>
<tr class="memdesc:a8b1d652d2d52b327b057b11fd0eb1331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a functor should be written using infix notation (e.g.  <a href="#a8b1d652d2d52b327b057b11fd0eb1331">More...</a><br /></td></tr>
<tr class="separator:a8b1d652d2d52b327b057b11fd0eb1331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56909036ae0514924e306d0a1a180837"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a56909036ae0514924e306d0a1a180837">isNumber</a> (const char *<a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>)</td></tr>
<tr class="memdesc:a56909036ae0514924e306d0a1a180837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a string is a sequence of digits.  <a href="#a56909036ae0514924e306d0a1a180837">More...</a><br /></td></tr>
<tr class="separator:a56909036ae0514924e306d0a1a180837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e502e6abb9a3e9a8e4c1168dbf23743"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743">isNumberType</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:a4e502e6abb9a3e9a8e4c1168dbf23743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a number type.  <a href="#a4e502e6abb9a3e9a8e4c1168dbf23743">More...</a><br /></td></tr>
<tr class="separator:a4e502e6abb9a3e9a8e4c1168dbf23743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6c863e60901e130475672aff3942ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aae6c863e60901e130475672aff3942ac">isNumberType</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;s)</td></tr>
<tr class="memdesc:aae6c863e60901e130475672aff3942ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the types in the given set are number types.  <a href="#aae6c863e60901e130475672aff3942ac">More...</a><br /></td></tr>
<tr class="separator:aae6c863e60901e130475672aff3942ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91abe89b1490abcc00848fc5d9daf3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa91abe89b1490abcc00848fc5d9daf3a">isNumericType</a> (<a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> ramType)</td></tr>
<tr class="memdesc:aa91abe89b1490abcc00848fc5d9daf3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type is numeric.  <a href="#aa91abe89b1490abcc00848fc5d9daf3a">More...</a><br /></td></tr>
<tr class="separator:aa91abe89b1490abcc00848fc5d9daf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef21c7dc86fd4e9cc7ecf88e4f5c34a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef21c7dc86fd4e9cc7ecf88e4f5c34a0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aef21c7dc86fd4e9cc7ecf88e4f5c34a0">isNumericType</a> (const T &amp;type)</td></tr>
<tr class="memdesc:aef21c7dc86fd4e9cc7ecf88e4f5c34a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the type is numeric.  <a href="#aef21c7dc86fd4e9cc7ecf88e4f5c34a0">More...</a><br /></td></tr>
<tr class="separator:aef21c7dc86fd4e9cc7ecf88e4f5c34a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ad84055112fcf03bb4ba36a662e76a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a01ad84055112fcf03bb4ba36a662e76a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a01ad84055112fcf03bb4ba36a662e76a">isOrderableType</a> (const T &amp;type)</td></tr>
<tr class="separator:a01ad84055112fcf03bb4ba36a662e76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4197fde9d6be59495c0c8b613de0129"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab4197fde9d6be59495c0c8b613de0129">isOrderedBinaryConstraintOp</a> (const <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> op)</td></tr>
<tr class="memdesc:ab4197fde9d6be59495c0c8b613de0129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether arguments of constraint are orderable.  <a href="#ab4197fde9d6be59495c0c8b613de0129">More...</a><br /></td></tr>
<tr class="separator:ab4197fde9d6be59495c0c8b613de0129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7ac56e1539b5fc646d3822edf00bc2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#acf7ac56e1539b5fc646d3822edf00bc2">isOverloaded</a> (const <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> constraintOp)</td></tr>
<tr class="memdesc:acf7ac56e1539b5fc646d3822edf00bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function, informing whether constraint is overloaded.  <a href="#acf7ac56e1539b5fc646d3822edf00bc2">More...</a><br /></td></tr>
<tr class="separator:acf7ac56e1539b5fc646d3822edf00bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dce057a5176061ef6f8cfc3f45af19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a28dce057a5176061ef6f8cfc3f45af19">isOverloadedAggregator</a> (const <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">AggregateOp</a> op)</td></tr>
<tr class="separator:a28dce057a5176061ef6f8cfc3f45af19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1194839f74c824923896977b98541e2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1194839f74c824923896977b98541e2e">isOverloadedFunctor</a> (const <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a> functor)</td></tr>
<tr class="memdesc:a1194839f74c824923896977b98541e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether a functor is overloaded.  <a href="#a1194839f74c824923896977b98541e2e">More...</a><br /></td></tr>
<tr class="separator:a1194839f74c824923896977b98541e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fd86fe230c58e924db2cf47e1ba5e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0">isPrefix</a> (const std::string &amp;prefix, const std::string &amp;element)</td></tr>
<tr class="memdesc:ab9fd86fe230c58e924db2cf47e1ba5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if one string is a prefix of another.  <a href="#ab9fd86fe230c58e924db2cf47e1ba5e0">More...</a><br /></td></tr>
<tr class="separator:ab9fd86fe230c58e924db2cf47e1ba5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c608d44d9d95373b73915fd555eeb60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1c608d44d9d95373b73915fd555eeb60">isProposition</a> (const <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *atom)</td></tr>
<tr class="separator:a1c608d44d9d95373b73915fd555eeb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda7adbee5f19bb274a067facc71d0e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#adda7adbee5f19bb274a067facc71d0e8">isRamTrue</a> (const <a class="el" href="classsouffle_1_1_ram_condition.html">RamCondition</a> *cond)</td></tr>
<tr class="memdesc:adda7adbee5f19bb274a067facc71d0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a condition represents true.  <a href="#adda7adbee5f19bb274a067facc71d0e8">More...</a><br /></td></tr>
<tr class="separator:adda7adbee5f19bb274a067facc71d0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaed06bbcb6b8efcfd2474b1c5d81aa3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aaaed06bbcb6b8efcfd2474b1c5d81aa3">isRamUndefValue</a> (const <a class="el" href="classsouffle_1_1_ram_expression.html">RamExpression</a> *expr)</td></tr>
<tr class="memdesc:aaaed06bbcb6b8efcfd2474b1c5d81aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an expression represents an undefined value.  <a href="#aaaed06bbcb6b8efcfd2474b1c5d81aa3">More...</a><br /></td></tr>
<tr class="separator:aaaed06bbcb6b8efcfd2474b1c5d81aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c8a82b8d9ed840b32e93186002d18c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a34c8a82b8d9ed840b32e93186002d18c">isRecordType</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:a34c8a82b8d9ed840b32e93186002d18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a record type.  <a href="#a34c8a82b8d9ed840b32e93186002d18c">More...</a><br /></td></tr>
<tr class="separator:a34c8a82b8d9ed840b32e93186002d18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790e39fcdcb0e62caaee56e0bf7d3b45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a790e39fcdcb0e62caaee56e0bf7d3b45">isRecordType</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;s)</td></tr>
<tr class="memdesc:a790e39fcdcb0e62caaee56e0bf7d3b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the types in the given set are record types.  <a href="#a790e39fcdcb0e62caaee56e0bf7d3b45">More...</a><br /></td></tr>
<tr class="separator:a790e39fcdcb0e62caaee56e0bf7d3b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32d170d4eebb7da45f9322e8b548aa8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa32d170d4eebb7da45f9322e8b548aa8">isRecursiveClause</a> (const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;clause)</td></tr>
<tr class="memdesc:aa32d170d4eebb7da45f9322e8b548aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given clause is recursive.  <a href="#aa32d170d4eebb7da45f9322e8b548aa8">More...</a><br /></td></tr>
<tr class="separator:aa32d170d4eebb7da45f9322e8b548aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79c60fce08f12e1f11d9d342c17ce56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac79c60fce08f12e1f11d9d342c17ce56">isRecursiveType</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:ac79c60fce08f12e1f11d9d342c17ce56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a recursive type.  <a href="#ac79c60fce08f12e1f11d9d342c17ce56">More...</a><br /></td></tr>
<tr class="separator:ac79c60fce08f12e1f11d9d342c17ce56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3001cd29f8307b210ec039a6f7788636"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3001cd29f8307b210ec039a6f7788636">isRelationQualifierTag</a> (const <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529f">RelationTag</a> &amp;tag)</td></tr>
<tr class="memdesc:a3001cd29f8307b210ec039a6f7788636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a given relation tag is a relation qualifier.  <a href="#a3001cd29f8307b210ec039a6f7788636">More...</a><br /></td></tr>
<tr class="separator:a3001cd29f8307b210ec039a6f7788636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae730235d0fafb09318409c3051334ca8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae730235d0fafb09318409c3051334ca8">isRelationRepresentationTag</a> (const <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529f">RelationTag</a> &amp;tag)</td></tr>
<tr class="memdesc:ae730235d0fafb09318409c3051334ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a given relation tag sets a relation representation.  <a href="#ae730235d0fafb09318409c3051334ca8">More...</a><br /></td></tr>
<tr class="separator:ae730235d0fafb09318409c3051334ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a7da374b6da781f82cdc09d5fe0d38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad9a7da374b6da781f82cdc09d5fe0d38">isRule</a> (const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;clause)</td></tr>
<tr class="memdesc:ad9a7da374b6da781f82cdc09d5fe0d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given clause is a rule.  <a href="#ad9a7da374b6da781f82cdc09d5fe0d38">More...</a><br /></td></tr>
<tr class="separator:ad9a7da374b6da781f82cdc09d5fe0d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc19c66d9d13ce64e65f14dcabb43b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;a, const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a8cc19c66d9d13ce64e65f14dcabb43b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether type a is a subtype of type b.  <a href="#a8cc19c66d9d13ce64e65f14dcabb43b3">More...</a><br /></td></tr>
<tr class="separator:a8cc19c66d9d13ce64e65f14dcabb43b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f6c352eec6bde7b5a0b143ffe64e3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b">isSymbolType</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:a11f6c352eec6bde7b5a0b143ffe64e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a symbol type.  <a href="#a11f6c352eec6bde7b5a0b143ffe64e3b">More...</a><br /></td></tr>
<tr class="separator:a11f6c352eec6bde7b5a0b143ffe64e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f1f97bcd38ff9cd112ade89e631b80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae9f1f97bcd38ff9cd112ade89e631b80">isSymbolType</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;s)</td></tr>
<tr class="memdesc:ae9f1f97bcd38ff9cd112ade89e631b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the types in the given set are symbol types.  <a href="#ae9f1f97bcd38ff9cd112ade89e631b80">More...</a><br /></td></tr>
<tr class="separator:ae9f1f97bcd38ff9cd112ade89e631b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4839a38da22a968ab01e81a67d793c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a5c4839a38da22a968ab01e81a67d793c">isUnsignedType</a> (const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:a5c4839a38da22a968ab01e81a67d793c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a number type.  <a href="#a5c4839a38da22a968ab01e81a67d793c">More...</a><br /></td></tr>
<tr class="separator:a5c4839a38da22a968ab01e81a67d793c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4bd063028ddb747c726ca9fa04f85e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3b4bd063028ddb747c726ca9fa04f85e">isUnsignedType</a> (const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;s)</td></tr>
<tr class="memdesc:a3b4bd063028ddb747c726ca9fa04f85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the types in the given set are number types.  <a href="#a3b4bd063028ddb747c726ca9fa04f85e">More...</a><br /></td></tr>
<tr class="separator:a3b4bd063028ddb747c726ca9fa04f85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1193e67992e4f0591e4011faccb4abe2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1193e67992e4f0591e4011faccb4abe2">isValidFunctorOpArity</a> (const <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a> op, const size_t arity)</td></tr>
<tr class="memdesc:a1193e67992e4f0591e4011faccb4abe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a functor operation can have a given argument count.  <a href="#a1193e67992e4f0591e4011faccb4abe2">More...</a><br /></td></tr>
<tr class="separator:a1193e67992e4f0591e4011faccb4abe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ecff533a6bf91c15209f6fbb56235f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a90ecff533a6bf91c15209f6fbb56235f">isValidMove</a> (const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *left, size_t leftIdx, const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *right, size_t rightIdx)</td></tr>
<tr class="memdesc:a90ecff533a6bf91c15209f6fbb56235f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the atom at leftIdx in the left clause can potentially be matched up with the atom at rightIdx in the right clause.  <a href="#a90ecff533a6bf91c15209f6fbb56235f">More...</a><br /></td></tr>
<tr class="separator:a90ecff533a6bf91c15209f6fbb56235f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3867b63ae91058fdbcbff1475240b16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa3867b63ae91058fdbcbff1475240b16">isValidPermutation</a> (const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *left, const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *right, const std::vector&lt; unsigned int &gt; &amp;permutation)</td></tr>
<tr class="memdesc:aa3867b63ae91058fdbcbff1475240b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a valid variable mapping exists for the given permutation.  <a href="#aa3867b63ae91058fdbcbff1475240b16">More...</a><br /></td></tr>
<tr class="separator:aa3867b63ae91058fdbcbff1475240b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4e3f19879707216a2758b03f4e2deb"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename Printer &gt; </td></tr>
<tr class="memitem:abe4e3f19879707216a2758b03f4e2deb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">detail::joined_sequence</a>&lt; Iter, Printer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">join</a> (const Iter &amp;a, const Iter &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, const std::string &amp;sep, const Printer &amp;<a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:abe4e3f19879707216a2758b03f4e2deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object to be forwarded to some output stream for printing sequences of elements interspersed by a given separator.  <a href="#abe4e3f19879707216a2758b03f4e2deb">More...</a><br /></td></tr>
<tr class="separator:abe4e3f19879707216a2758b03f4e2deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff8ab73e5403aebf8bc9e0cd8a17655"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename T  = typename Iter::value_type&gt; </td></tr>
<tr class="memitem:a2ff8ab73e5403aebf8bc9e0cd8a17655"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">detail::joined_sequence</a>&lt; Iter, <a class="el" href="structsouffle_1_1detail_1_1print.html">detail::print</a>&lt; <a class="el" href="structsouffle_1_1id.html">id</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2ff8ab73e5403aebf8bc9e0cd8a17655">join</a> (const Iter &amp;a, const Iter &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, const std::string &amp;sep=&quot;,&quot;)</td></tr>
<tr class="memdesc:a2ff8ab73e5403aebf8bc9e0cd8a17655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object to be forwarded to some output stream for printing sequences of elements interspersed by a given separator.  <a href="#a2ff8ab73e5403aebf8bc9e0cd8a17655">More...</a><br /></td></tr>
<tr class="separator:a2ff8ab73e5403aebf8bc9e0cd8a17655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5411f3812147edc8be88140d80308bd"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Printer , typename Iter  = typename Container::const_iterator&gt; </td></tr>
<tr class="memitem:af5411f3812147edc8be88140d80308bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">detail::joined_sequence</a>&lt; Iter, Printer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af5411f3812147edc8be88140d80308bd">join</a> (const Container &amp;c, const std::string &amp;sep, const Printer &amp;<a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:af5411f3812147edc8be88140d80308bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object to be forwarded to some output stream for printing the content of containers interspersed by a given separator.  <a href="#af5411f3812147edc8be88140d80308bd">More...</a><br /></td></tr>
<tr class="separator:af5411f3812147edc8be88140d80308bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f126a2c7d2ee710ec8600b2af64da3"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Iter  = typename Container::const_iterator, typename T  = typename Iter::value_type&gt; </td></tr>
<tr class="memitem:af2f126a2c7d2ee710ec8600b2af64da3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">detail::joined_sequence</a>&lt; Iter, <a class="el" href="structsouffle_1_1detail_1_1print.html">detail::print</a>&lt; <a class="el" href="structsouffle_1_1id.html">id</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">join</a> (const Container &amp;c, const std::string &amp;sep=&quot;,&quot;)</td></tr>
<tr class="memdesc:af2f126a2c7d2ee710ec8600b2af64da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object to be forwarded to some output stream for printing the content of containers interspersed by a given separator.  <a href="#af2f126a2c7d2ee710ec8600b2af64da3">More...</a><br /></td></tr>
<tr class="separator:af2f126a2c7d2ee710ec8600b2af64da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052d35be8e032f425317fd1b6d7e487a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a052d35be8e032f425317fd1b6d7e487a">main</a> (int argc, char **argv)</td></tr>
<tr class="separator:a052d35be8e032f425317fd1b6d7e487a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea8a37cc1681f657054f3b30af55003"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:acea8a37cc1681f657054f3b30af55003"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1range.html">range</a>&lt; Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">make_range</a> (const Iter &amp;a, const Iter &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:acea8a37cc1681f657054f3b30af55003"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the construction of ranges without explicitly specifying the iterator type.  <a href="#acea8a37cc1681f657054f3b30af55003">More...</a><br /></td></tr>
<tr class="separator:acea8a37cc1681f657054f3b30af55003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c74d6a5819e15d68eded0c4e9ff9d5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a97c74d6a5819e15d68eded0c4e9ff9d5">makeInfoRelation</a> (<a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;originalClause, size_t originalClauseNum, <a class="el" href="classsouffle_1_1_ast_translation_unit.html">AstTranslationUnit</a> &amp;translationUnit)</td></tr>
<tr class="separator:a97c74d6a5819e15d68eded0c4e9ff9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fd524841b8a60b1bb50b18dc868c7c"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:a67fd524841b8a60b1bb50b18dc868c7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1detail_1_1_lambda_node_mapper.html">detail::LambdaNodeMapper</a>&lt; Lambda &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a67fd524841b8a60b1bb50b18dc868c7c">makeLambdaAstMapper</a> (const Lambda &amp;lambda)</td></tr>
<tr class="memdesc:a67fd524841b8a60b1bb50b18dc868c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a node mapper based on a corresponding lambda expression.  <a href="#a67fd524841b8a60b1bb50b18dc868c7c">More...</a><br /></td></tr>
<tr class="separator:a67fd524841b8a60b1bb50b18dc868c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fba43e03f480ca372449b103dfc9a2f"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:a7fba43e03f480ca372449b103dfc9a2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_lambda_ram_node_mapper.html">LambdaRamNodeMapper</a>&lt; Lambda &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7fba43e03f480ca372449b103dfc9a2f">makeLambdaRamMapper</a> (const Lambda &amp;lambda)</td></tr>
<tr class="memdesc:a7fba43e03f480ca372449b103dfc9a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a node mapper based on a corresponding lambda expression.  <a href="#a7fba43e03f480ca372449b103dfc9a2f">More...</a><br /></td></tr>
<tr class="separator:a7fba43e03f480ca372449b103dfc9a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74ef3c3ffaad63c158bcd0ff2feecb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac74ef3c3ffaad63c158bcd0ff2feecb2">makeRelationName</a> (const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;orig, const std::string &amp;type, int num=-1)</td></tr>
<tr class="separator:ac74ef3c3ffaad63c158bcd0ff2feecb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb53246ca22f17f324a309dc63f2e73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#acbb53246ca22f17f324a309dc63f2e73">nameInlinedUnderscores</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program)</td></tr>
<tr class="memdesc:acbb53246ca22f17f324a309dc63f2e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all underscores in all atoms of inlined relations.  <a href="#acbb53246ca22f17f324a309dc63f2e73">More...</a><br /></td></tr>
<tr class="separator:acbb53246ca22f17f324a309dc63f2e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2b4fc7558b8bce98ff88f8e10b516e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a4a2b4fc7558b8bce98ff88f8e10b516e">negateConstraint</a> (<a class="el" href="classsouffle_1_1_ast_constraint.html">AstConstraint</a> *constraint)</td></tr>
<tr class="memdesc:a4a2b4fc7558b8bce98ff88f8e10b516e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate an ast constraint.  <a href="#a4a2b4fc7558b8bce98ff88f8e10b516e">More...</a><br /></td></tr>
<tr class="separator:a4a2b4fc7558b8bce98ff88f8e10b516e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269a51553c86cbb637013907c879f478"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478">negatedConstraintOp</a> (const <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> op)</td></tr>
<tr class="memdesc:a269a51553c86cbb637013907c879f478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negated <a class="el" href="classsouffle_1_1_constraint.html" title="A generic base class for constraints on variables. ">Constraint</a> Operator Each operator requires a negated operator which is necessary for the expansion of complex rule bodies with disjunction and negation.  <a href="#a269a51553c86cbb637013907c879f478">More...</a><br /></td></tr>
<tr class="separator:a269a51553c86cbb637013907c879f478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ca390c0235d50be215fdc25bb24e4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d">negateLiteral</a> (<a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *lit)</td></tr>
<tr class="memdesc:a72ca390c0235d50be215fdc25bb24e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the negated version of a given literal.  <a href="#a72ca390c0235d50be215fdc25bb24e4d">More...</a><br /></td></tr>
<tr class="separator:a72ca390c0235d50be215fdc25bb24e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f903ef77f947a3123c891794322534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_src_location.html">SrcLocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a70f903ef77f947a3123c891794322534">nextSrcLoc</a> (<a class="el" href="classsouffle_1_1_src_location.html">SrcLocation</a> orig)</td></tr>
<tr class="separator:a70f903ef77f947a3123c891794322534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ec690ba482fd3a9692b5e31f6ad347"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:af4ec690ba482fd3a9692b5e31f6ad347"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af4ec690ba482fd3a9692b5e31f6ad347">none_of</a> (const Container &amp;c, UnaryPredicate <a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:af4ec690ba482fd3a9692b5e31f6ad347"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic test checking whether all elements within a container satisfy a certain predicate.  <a href="#af4ec690ba482fd3a9692b5e31f6ad347">More...</a><br /></td></tr>
<tr class="separator:af4ec690ba482fd3a9692b5e31f6ad347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8556c87eabd8a087d1e0fb9f8b89b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#abc8556c87eabd8a087d1e0fb9f8b89b6">normaliseInlinedHeads</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program)</td></tr>
<tr class="memdesc:abc8556c87eabd8a087d1e0fb9f8b89b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace constants in the head of inlined clauses with (constrained) variables.  <a href="#abc8556c87eabd8a087d1e0fb9f8b89b6">More...</a><br /></td></tr>
<tr class="separator:abc8556c87eabd8a087d1e0fb9f8b89b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c65551944c7ecf6f44ec851b49bdbb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#a9eb29a1677ffbe44fe8663f881213f0e">time_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">now</a> ()</td></tr>
<tr class="separator:a1c65551944c7ecf6f44ec851b49bdbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b8ff6e096476fd6097c05b4eb12386"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a84b8ff6e096476fd6097c05b4eb12386">numBoundArguments</a> (const <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *atom, const std::set&lt; std::string &gt; &amp;boundVariables)</td></tr>
<tr class="memdesc:a84b8ff6e096476fd6097c05b4eb12386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of bound arguments in a given atom.  <a href="#a84b8ff6e096476fd6097c05b4eb12386">More...</a><br /></td></tr>
<tr class="separator:a84b8ff6e096476fd6097c05b4eb12386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad202244da4a83adaa43b98ffa52c371e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad202244da4a83adaa43b98ffa52c371e">operator+</a> (const std::string &amp;name, const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;<a class="el" href="structsouffle_1_1id.html">id</a>)</td></tr>
<tr class="separator:ad202244da4a83adaa43b98ffa52c371e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa174f8f3342ee5a31f6fecee73a29aee"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa174f8f3342ee5a31f6fecee73a29aee">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classsouffle_1_1_tuple_ref.html">TupleRef</a> ref)</td></tr>
<tr class="separator:aa174f8f3342ee5a31f6fecee73a29aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54cfa5513383a790af97fb4e4e5a26a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae54cfa5513383a790af97fb4e4e5a26a">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> T)</td></tr>
<tr class="separator:ae54cfa5513383a790af97fb4e4e5a26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674f99959c31838604c3778e4ef1f919"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a674f99959c31838604c3778e4ef1f919">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classsouffle_1_1_order.html">Order</a> &amp;order)</td></tr>
<tr class="separator:a674f99959c31838604c3778e4ef1f919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d1fa53d5b327689cd083732bf10665"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa2d1fa53d5b327689cd083732bf10665">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespacesouffle.html#a4d1111156440d898474b3cd9cd43a276">RelationQualifier</a> qualifier)</td></tr>
<tr class="separator:aa2d1fa53d5b327689cd083732bf10665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cf2396e4d4fb479990191006785299"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad8cf2396e4d4fb479990191006785299">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classsouffle_1_1_rule_body.html">RuleBody</a> &amp;body)</td></tr>
<tr class="separator:ad8cf2396e4d4fb479990191006785299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45442942bd3d9825308c57c97bdb5c9e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a45442942bd3d9825308c57c97bdb5c9e">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9e">RelationRepresentation</a> representation)</td></tr>
<tr class="separator:a45442942bd3d9825308c57c97bdb5c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfb7f5671f38232db9a50606d07fe04"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned size&gt; </td></tr>
<tr class="memitem:a9dfb7f5671f38232db9a50606d07fe04"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9dfb7f5671f38232db9a50606d07fe04">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classsouffle_1_1_l_r_u_cache.html">LRUCache</a>&lt; T, size &gt; &amp;cache)</td></tr>
<tr class="separator:a9dfb7f5671f38232db9a50606d07fe04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109db698f6adb0de81299c0108b617f6"><td class="memTemplParams" colspan="2">template&lt;std::size_t Arity&gt; </td></tr>
<tr class="memitem:a109db698f6adb0de81299c0108b617f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#aa9d8dbe49d3251e572172b31023b1ce9">RamDomain</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a109db698f6adb0de81299c0108b617f6">pack</a> (<a class="el" href="classsouffle_1_1_record_table.html">RecordTable</a> &amp;recordTab, <a class="el" href="structsouffle_1_1_tuple.html">Tuple</a>&lt; <a class="el" href="namespacesouffle.html#aa9d8dbe49d3251e572172b31023b1ce9">RamDomain</a>, Arity &gt; <a class="el" href="classsouffle_1_1tuple.html">tuple</a>)</td></tr>
<tr class="memdesc:a109db698f6adb0de81299c0108b617f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper to convert tuple to record reference for the synthesiser  <a href="#a109db698f6adb0de81299c0108b617f6">More...</a><br /></td></tr>
<tr class="separator:a109db698f6adb0de81299c0108b617f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168e2fae5a34ddc5215c94d27893a7ff"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a168e2fae5a34ddc5215c94d27893a7ff">pathJoin</a> (const std::string &amp;first, const std::string &amp;second)</td></tr>
<tr class="memdesc:a168e2fae5a34ddc5215c94d27893a7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join two paths together; note that this does not resolve overlaps or relative paths.  <a href="#a168e2fae5a34ddc5215c94d27893a7ff">More...</a><br /></td></tr>
<tr class="separator:a168e2fae5a34ddc5215c94d27893a7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bd1d83dcab901258167a7892db39be"><td class="memTemplParams" colspan="2">template&lt;typename To  = RamDomain, typename From &gt; </td></tr>
<tr class="memitem:aa3bd1d83dcab901258167a7892db39be"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa3bd1d83dcab901258167a7892db39be">ramBitCast</a> (From source)</td></tr>
<tr class="memdesc:aa3bd1d83dcab901258167a7892db39be"><td class="mdescLeft">&#160;</td><td class="mdescRight">In C++20 there will be a new way to cast between types by reinterpreting bits (std::bit_cast), but as of January 2020 it is not yet supported.  <a href="#aa3bd1d83dcab901258167a7892db39be">More...</a><br /></td></tr>
<tr class="separator:aa3bd1d83dcab901258167a7892db39be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f50e44c16d45c78e4a37b005ac94c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#a71ed4e379ed3ad06b9d02a4fc8470646">RamFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a42f50e44c16d45c78e4a37b005ac94c9">RamFloatFromString</a> (const std::string &amp;<a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, std::size_t *position=nullptr)</td></tr>
<tr class="memdesc:a42f50e44c16d45c78e4a37b005ac94c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to a RamFloat.  <a href="#a42f50e44c16d45c78e4a37b005ac94c9">More...</a><br /></td></tr>
<tr class="separator:a42f50e44c16d45c78e4a37b005ac94c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad354d1210c639429c093f92ba2966a75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#a506d6a56200708498577b6e4d3a83ae3">RamSigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad354d1210c639429c093f92ba2966a75">RamSignedFromString</a> (const std::string &amp;<a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, std::size_t *position=nullptr, const int <a class="el" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a>=10)</td></tr>
<tr class="memdesc:ad354d1210c639429c093f92ba2966a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to a RamSigned.  <a href="#ad354d1210c639429c093f92ba2966a75">More...</a><br /></td></tr>
<tr class="separator:ad354d1210c639429c093f92ba2966a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084bbb9535fee35e4682c948ce88bddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#afaab74f4511cf7a2da6afe0e001be9c6">RamUnsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a084bbb9535fee35e4682c948ce88bddb">RamUnsignedFromString</a> (const std::string &amp;<a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, std::size_t *position=nullptr, const int <a class="el" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a>=10)</td></tr>
<tr class="memdesc:a084bbb9535fee35e4682c948ce88bddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to a RamUnsigned.  <a href="#a084bbb9535fee35e4682c948ce88bddb">More...</a><br /></td></tr>
<tr class="separator:a084bbb9535fee35e4682c948ce88bddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b5ec91eb9db76098b8088964808456"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a34b5ec91eb9db76098b8088964808456">reduceLocallyEquivalentClauses</a> (<a class="el" href="classsouffle_1_1_ast_translation_unit.html">AstTranslationUnit</a> &amp;translationUnit)</td></tr>
<tr class="memdesc:a34b5ec91eb9db76098b8088964808456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces locally-redundant clauses.  <a href="#a34b5ec91eb9db76098b8088964808456">More...</a><br /></td></tr>
<tr class="separator:a34b5ec91eb9db76098b8088964808456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a8f568c6ad4616e8ab6225b0e023ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab2a8f568c6ad4616e8ab6225b0e023ce">reduceSingletonRelations</a> (<a class="el" href="classsouffle_1_1_ast_translation_unit.html">AstTranslationUnit</a> &amp;translationUnit)</td></tr>
<tr class="memdesc:ab2a8f568c6ad4616e8ab6225b0e023ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes redundant singleton relations.  <a href="#ab2a8f568c6ad4616e8ab6225b0e023ce">More...</a><br /></td></tr>
<tr class="separator:ab2a8f568c6ad4616e8ab6225b0e023ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659ae2c89cfab47908f27a660f82c147"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a659ae2c89cfab47908f27a660f82c147">reduceSubstitution</a> (std::vector&lt; std::pair&lt; <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *, <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *&gt;&gt; &amp;<a class="el" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>)</td></tr>
<tr class="memdesc:a659ae2c89cfab47908f27a660f82c147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces a vector of substitutions.  <a href="#a659ae2c89cfab47908f27a660f82c147">More...</a><br /></td></tr>
<tr class="separator:a659ae2c89cfab47908f27a660f82c147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503032b9def6267059072aea913780bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a503032b9def6267059072aea913780bc">removeRelationClauses</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;name)</td></tr>
<tr class="memdesc:a503032b9def6267059072aea913780bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the set of clauses with the given relation name.  <a href="#a503032b9def6267059072aea913780bc">More...</a><br /></td></tr>
<tr class="separator:a503032b9def6267059072aea913780bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af790a6a39a388c256d64af7140f3a961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961">renameVariables</a> (<a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *arg)</td></tr>
<tr class="memdesc:af790a6a39a388c256d64af7140f3a961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames all variables in a given argument uniquely.  <a href="#af790a6a39a388c256d64af7140f3a961">More...</a><br /></td></tr>
<tr class="separator:af790a6a39a388c256d64af7140f3a961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6903b947a2473735a22a16f70664b91b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6903b947a2473735a22a16f70664b91b">reorderAdornment</a> (std::vector&lt; std::string &gt; adornment, std::vector&lt; unsigned int &gt; order)</td></tr>
<tr class="separator:a6903b947a2473735a22a16f70664b91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77f3374134c13b638bf7644fcebb5ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae77f3374134c13b638bf7644fcebb5ef">reorderAtoms</a> (const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *clause, const std::vector&lt; unsigned int &gt; &amp;newOrder)</td></tr>
<tr class="memdesc:ae77f3374134c13b638bf7644fcebb5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the atoms of a clause to be in the given order.  <a href="#ae77f3374134c13b638bf7644fcebb5ef">More...</a><br /></td></tr>
<tr class="separator:ae77f3374134c13b638bf7644fcebb5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2cecfcadc16887cd76ccff96466d19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#afa2cecfcadc16887cd76ccff96466d19">reorderClauseWithSips</a> (<a class="el" href="namespacesouffle.html#ad0dcec7b78fdde7450cb55df1fece164">sips_t</a> sipsFunction, <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *clause)</td></tr>
<tr class="separator:afa2cecfcadc16887cd76ccff96466d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8e6aa7bd85198221efb412ec7b898c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6e8e6aa7bd85198221efb412ec7b898c">reorderOrdering</a> (std::vector&lt; unsigned int &gt; order)</td></tr>
<tr class="separator:a6e8e6aa7bd85198221efb412ec7b898c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877abda5aeabc4122f3bce8d74247919"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a877abda5aeabc4122f3bce8d74247919">replaceUnderscores</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program)</td></tr>
<tr class="separator:a877abda5aeabc4122f3bce8d74247919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9046441f0187dc187df0765a55b175"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a0f9046441f0187dc187df0765a55b175">separateDBs</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *program)</td></tr>
<tr class="separator:a0f9046441f0187dc187df0765a55b175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31e06999eb72da2f6d9a85bdd3dda59"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab31e06999eb72da2f6d9a85bdd3dda59">simpleName</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:ab31e06999eb72da2f6d9a85bdd3dda59"><td class="mdescLeft">&#160;</td><td class="mdescRight">File name, with extension removed.  <a href="#ab31e06999eb72da2f6d9a85bdd3dda59">More...</a><br /></td></tr>
<tr class="separator:ab31e06999eb72da2f6d9a85bdd3dda59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2925d5d1ec64b003a6b111ed29a2392b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2925d5d1ec64b003a6b111ed29a2392b">split</a> (const std::string &amp;s, char delim, int <a class="el" href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f">times</a>=-1)</td></tr>
<tr class="memdesc:a2925d5d1ec64b003a6b111ed29a2392b"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility function to split a string  <a href="#a2925d5d1ec64b003a6b111ed29a2392b">More...</a><br /></td></tr>
<tr class="separator:a2925d5d1ec64b003a6b111ed29a2392b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673608e9453179d30f6607384f54463a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a673608e9453179d30f6607384f54463a">splitString</a> (const std::string &amp;<a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, char delimiter)</td></tr>
<tr class="memdesc:a673608e9453179d30f6607384f54463a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string given a delimiter.  <a href="#a673608e9453179d30f6607384f54463a">More...</a><br /></td></tr>
<tr class="separator:a673608e9453179d30f6607384f54463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f428910159c119c1dcdcab76ab7dfa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a06f428910159c119c1dcdcab76ab7dfa">stringify</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:a06f428910159c119c1dcdcab76ab7dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stringify a string using escapes for newline, tab, double-quotes and semicolons.  <a href="#a06f428910159c119c1dcdcab76ab7dfa">More...</a><br /></td></tr>
<tr class="separator:a06f428910159c119c1dcdcab76ab7dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f93cdf21f1a24b593da6691dc892828"><td class="memTemplParams" colspan="2">template&lt;typename Var &gt; </td></tr>
<tr class="memitem:a7f93cdf21f1a24b593da6691dc892828"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classsouffle_1_1_constraint.html">Constraint</a>&lt; Var &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a> (const Var &amp;a, const Var &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, const std::string &amp;symbol=&quot;⊑&quot;)</td></tr>
<tr class="memdesc:a7f93cdf21f1a24b593da6691dc892828"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic factory for constraints of the form.  <a href="#a7f93cdf21f1a24b593da6691dc892828">More...</a><br /></td></tr>
<tr class="separator:a7f93cdf21f1a24b593da6691dc892828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688bb15c1b54c1fb493463f09857778b"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename Val  = typename Var::property_space::value_type&gt; </td></tr>
<tr class="memitem:a688bb15c1b54c1fb493463f09857778b"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classsouffle_1_1_constraint.html">Constraint</a>&lt; Var &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a688bb15c1b54c1fb493463f09857778b">sub</a> (const Val &amp;a, const Var &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, const std::string &amp;symbol=&quot;⊑&quot;)</td></tr>
<tr class="memdesc:a688bb15c1b54c1fb493463f09857778b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic factory for constraints of the form.  <a href="#a688bb15c1b54c1fb493463f09857778b">More...</a><br /></td></tr>
<tr class="separator:a688bb15c1b54c1fb493463f09857778b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2122cfa5acdee4846ecda0855f0beee4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2122cfa5acdee4846ecda0855f0beee4">tempFile</a> ()</td></tr>
<tr class="memdesc:a2122cfa5acdee4846ecda0855f0beee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate temporary file.  <a href="#a2122cfa5acdee4846ecda0855f0beee4">More...</a><br /></td></tr>
<tr class="separator:a2122cfa5acdee4846ecda0855f0beee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fff2be077dd5d1105f3a6e718339f2f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0fff2be077dd5d1105f3a6e718339f2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsouffle_1_1detail_1_1multiplying__printer.html">detail::multiplying_printer</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f">times</a> (const T &amp;value, unsigned num)</td></tr>
<tr class="memdesc:a0fff2be077dd5d1105f3a6e718339f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility printing a given value multiple times.  <a href="#a0fff2be077dd5d1105f3a6e718339f2f">More...</a><br /></td></tr>
<tr class="separator:a0fff2be077dd5d1105f3a6e718339f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399105b8de1698758c5b18bc9efca9fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a399105b8de1698758c5b18bc9efca9fa">toBinaryConstraintOp</a> (const std::string &amp;symbol)</td></tr>
<tr class="memdesc:a399105b8de1698758c5b18bc9efca9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts symbolic representation of an operator to the operator.  <a href="#a399105b8de1698758c5b18bc9efca9fa">More...</a><br /></td></tr>
<tr class="separator:a399105b8de1698758c5b18bc9efca9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91ed26d703343c35171d6803a9c5d0b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa91ed26d703343c35171d6803a9c5d0b">toBinaryConstraintSymbol</a> (const <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> op)</td></tr>
<tr class="memdesc:aa91ed26d703343c35171d6803a9c5d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts operator to its symbolic representation.  <a href="#aa91ed26d703343c35171d6803a9c5d0b">More...</a><br /></td></tr>
<tr class="separator:aa91ed26d703343c35171d6803a9c5d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b80cb84e709bb5d93968317ec2fdbe1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ram_condition.html">RamCondition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9b80cb84e709bb5d93968317ec2fdbe1">toCondition</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ram_condition.html">RamCondition</a> &gt;&gt; &amp;conds)</td></tr>
<tr class="memdesc:a9b80cb84e709bb5d93968317ec2fdbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert list of conditions to a conjunction.  <a href="#a9b80cb84e709bb5d93968317ec2fdbe1">More...</a><br /></td></tr>
<tr class="separator:a9b80cb84e709bb5d93968317ec2fdbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea6de3eaf7c83bc19097c74d3fb6693"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ram_condition.html">RamCondition</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aeea6de3eaf7c83bc19097c74d3fb6693">toConjunctionList</a> (const <a class="el" href="classsouffle_1_1_ram_condition.html">RamCondition</a> *condition)</td></tr>
<tr class="memdesc:aeea6de3eaf7c83bc19097c74d3fb6693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert terms of a conjunction to a list.  <a href="#aeea6de3eaf7c83bc19097c74d3fb6693">More...</a><br /></td></tr>
<tr class="separator:aeea6de3eaf7c83bc19097c74d3fb6693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62d4e824a9d74c7462da546a21780fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad62d4e824a9d74c7462da546a21780fe"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe">toPtrVector</a> (const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:ad62d4e824a9d74c7462da546a21780fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a vector of pointers.  <a href="#ad62d4e824a9d74c7462da546a21780fe">More...</a><br /></td></tr>
<tr class="separator:ad62d4e824a9d74c7462da546a21780fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc08c83ad9634fc515b7aa094702949"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a> (const std::string &amp;<a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>)</td></tr>
<tr class="memdesc:aecc08c83ad9634fc515b7aa094702949"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic function converting strings into strings (trivial case).  <a href="#aecc08c83ad9634fc515b7aa094702949">More...</a><br /></td></tr>
<tr class="separator:aecc08c83ad9634fc515b7aa094702949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f01b6b803d03b90d7f33df9351ade"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aac0f01b6b803d03b90d7f33df9351ade"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structsouffle_1_1detail_1_1is__printable.html">detail::is_printable</a>&lt; T &gt;::value, std::string &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aac0f01b6b803d03b90d7f33df9351ade">toString</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aac0f01b6b803d03b90d7f33df9351ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic function converting arbitrary objects to strings by utilizing their print capability.  <a href="#aac0f01b6b803d03b90d7f33df9351ade">More...</a><br /></td></tr>
<tr class="separator:aac0f01b6b803d03b90d7f33df9351ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde2b7fb9746dae19cf74319c353aa52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afde2b7fb9746dae19cf74319c353aa52"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structsouffle_1_1detail_1_1is__printable.html">detail::is_printable</a>&lt; T &gt;::value, std::string &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#afde2b7fb9746dae19cf74319c353aa52">toString</a> (const T &amp;)</td></tr>
<tr class="memdesc:afde2b7fb9746dae19cf74319c353aa52"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fallback for the to-string function in case an unprintable object is supposed to be printed.  <a href="#afde2b7fb9746dae19cf74319c353aa52">More...</a><br /></td></tr>
<tr class="separator:afde2b7fb9746dae19cf74319c353aa52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2822ded4e7fd1466479b3fd6a1345a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2822ded4e7fd1466479b3fd6a1345a0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab2822ded4e7fd1466479b3fd6a1345a0">toVector</a> ()</td></tr>
<tr class="memdesc:ab2822ded4e7fd1466479b3fd6a1345a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a vector with a fixed set of elements within a single expression.  <a href="#ab2822ded4e7fd1466479b3fd6a1345a0">More...</a><br /></td></tr>
<tr class="separator:ab2822ded4e7fd1466479b3fd6a1345a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae771492463067508eb07c2113550097e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... R&gt; </td></tr>
<tr class="memitem:ae771492463067508eb07c2113550097e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae771492463067508eb07c2113550097e">toVector</a> (const T &amp;first, const R &amp;... rest)</td></tr>
<tr class="memdesc:ae771492463067508eb07c2113550097e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a vector with a fixed set of elements within a single expression.  <a href="#ae771492463067508eb07c2113550097e">More...</a><br /></td></tr>
<tr class="separator:ae771492463067508eb07c2113550097e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1142a31f92b96107d9603e86b13bdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2e1142a31f92b96107d9603e86b13bdb">transformEqrelRelation</a> (<a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;program, <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> &amp;rel)</td></tr>
<tr class="memdesc:a2e1142a31f92b96107d9603e86b13bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform eqrel relations to explicitly define equivalence relations.  <a href="#a2e1142a31f92b96107d9603e86b13bdb">More...</a><br /></td></tr>
<tr class="separator:a2e1142a31f92b96107d9603e86b13bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b370fe6877c2777646f7fad4aad0cb2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6b370fe6877c2777646f7fad4aad0cb2">unescape</a> (const std::string &amp;inputString, const std::string &amp;needle, const std::string &amp;replacement)</td></tr>
<tr class="separator:a6b370fe6877c2777646f7fad4aad0cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20932ae365326d8c0d9bd06f6ea09781"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a20932ae365326d8c0d9bd06f6ea09781">unescape</a> (const std::string &amp;inputString)</td></tr>
<tr class="separator:a20932ae365326d8c0d9bd06f6ea09781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66c00257a9f4ce44653d82cee9c563d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt; std::pair&lt; <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *, <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d">unifyAtoms</a> (<a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *first, <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *second)</td></tr>
<tr class="memdesc:ab66c00257a9f4ce44653d82cee9c563d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nullable vector of substitutions needed to unify the two given atoms.  <a href="#ab66c00257a9f4ce44653d82cee9c563d">More...</a><br /></td></tr>
<tr class="separator:ab66c00257a9f4ce44653d82cee9c563d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf760ad1f1324f47eaf903e0c3ea18d9"><td class="memItemLeft" align="right" valign="top">static const std::vector&lt; <a class="el" href="classsouffle_1_1_src_location.html">SrcLocation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aaf760ad1f1324f47eaf903e0c3ea18d9">usesInvalidWitness</a> (const std::vector&lt; <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *&gt; &amp;literals, const std::set&lt; std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> &gt;&gt; &amp;groundedArguments)</td></tr>
<tr class="separator:aaf760ad1f1324f47eaf903e0c3ea18d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307bae61c898715dccb57c9732335000"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Ps, typename... Args&gt; </td></tr>
<tr class="memitem:a307bae61c898715dccb57c9732335000"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root, <a class="el" href="structsouffle_1_1_ast_visitor.html">AstVisitor</a>&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</td></tr>
<tr class="memdesc:a307bae61c898715dccb57c9732335000"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first pre-order fashion applying the given visitor to each encountered node.  <a href="#a307bae61c898715dccb57c9732335000">More...</a><br /></td></tr>
<tr class="separator:a307bae61c898715dccb57c9732335000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b49c5b71d674c041c04691f7556198"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Ps, typename... Args&gt; </td></tr>
<tr class="memitem:a59b49c5b71d674c041c04691f7556198"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a59b49c5b71d674c041c04691f7556198">visitDepthFirst</a> (const <a class="el" href="classsouffle_1_1_ram_node.html">RamNode</a> &amp;root, <a class="el" href="structsouffle_1_1_ram_visitor.html">RamVisitor</a>&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</td></tr>
<tr class="memdesc:a59b49c5b71d674c041c04691f7556198"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the RAM fragments rooted by the given node recursively in a depth-first pre-order fashion applying the given visitor to each encountered node.  <a href="#a59b49c5b71d674c041c04691f7556198">More...</a><br /></td></tr>
<tr class="separator:a59b49c5b71d674c041c04691f7556198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed08a0a4f3dee722039516cd22f4ae0b"><td class="memTemplParams" colspan="2">template&lt;typename R , typename N &gt; </td></tr>
<tr class="memitem:aed08a0a4f3dee722039516cd22f4ae0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aed08a0a4f3dee722039516cd22f4ae0b">visitDepthFirst</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root, const std::function&lt; R(const N &amp;)&gt; &amp;fun)</td></tr>
<tr class="memdesc:aed08a0a4f3dee722039516cd22f4ae0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first pre-order fashion applying the given function to each encountered node.  <a href="#aed08a0a4f3dee722039516cd22f4ae0b">More...</a><br /></td></tr>
<tr class="separator:aed08a0a4f3dee722039516cd22f4ae0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761efe11ed6dcdff18dce42b36bc9662"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename R  = typename lambda_traits&lt;Lambda&gt;::result_type, typename N  = typename lambda_traits&lt;Lambda&gt;::arg0_type&gt; </td></tr>
<tr class="memitem:a761efe11ed6dcdff18dce42b36bc9662"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structsouffle_1_1detail_1_1is__ast__visitor.html">detail::is_ast_visitor</a>&lt; Lambda &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a761efe11ed6dcdff18dce42b36bc9662">visitDepthFirst</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root, const Lambda &amp;fun)</td></tr>
<tr class="memdesc:a761efe11ed6dcdff18dce42b36bc9662"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first pre-order fashion applying the given function to each encountered node.  <a href="#a761efe11ed6dcdff18dce42b36bc9662">More...</a><br /></td></tr>
<tr class="separator:a761efe11ed6dcdff18dce42b36bc9662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b5ea9dd05a947f514d4db711e026d0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Lambda &gt; </td></tr>
<tr class="memitem:a56b5ea9dd05a947f514d4db711e026d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a56b5ea9dd05a947f514d4db711e026d0">visitDepthFirst</a> (const std::vector&lt; T *&gt; &amp;list, const Lambda &amp;fun)</td></tr>
<tr class="memdesc:a56b5ea9dd05a947f514d4db711e026d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within a given list of AST root nodes recursively in a depth-first pre-order fashion applying the given function to each encountered node.  <a href="#a56b5ea9dd05a947f514d4db711e026d0">More...</a><br /></td></tr>
<tr class="separator:a56b5ea9dd05a947f514d4db711e026d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6b482457e03d290adeaf963dabd078"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Lambda &gt; </td></tr>
<tr class="memitem:a8e6b482457e03d290adeaf963dabd078"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8e6b482457e03d290adeaf963dabd078">visitDepthFirst</a> (const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;list, const Lambda &amp;fun)</td></tr>
<tr class="memdesc:a8e6b482457e03d290adeaf963dabd078"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within a given list of AST root nodes recursively in a depth-first pre-order fashion applying the given function to each encountered node.  <a href="#a8e6b482457e03d290adeaf963dabd078">More...</a><br /></td></tr>
<tr class="separator:a8e6b482457e03d290adeaf963dabd078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f56d579f447fc1976686014c8b6fed4"><td class="memTemplParams" colspan="2">template&lt;typename R , typename N &gt; </td></tr>
<tr class="memitem:a3f56d579f447fc1976686014c8b6fed4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a3f56d579f447fc1976686014c8b6fed4">visitDepthFirst</a> (const <a class="el" href="classsouffle_1_1_ram_node.html">RamNode</a> &amp;root, const std::function&lt; R(const N &amp;)&gt; &amp;fun)</td></tr>
<tr class="memdesc:a3f56d579f447fc1976686014c8b6fed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in a depth-first pre-order fashion applying the given function to each encountered node.  <a href="#a3f56d579f447fc1976686014c8b6fed4">More...</a><br /></td></tr>
<tr class="separator:a3f56d579f447fc1976686014c8b6fed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f75835c6570547ab2d0c50376202dc7"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename R  = typename lambda_traits&lt;Lambda&gt;::result_type, typename N  = typename lambda_traits&lt;Lambda&gt;::arg0_type&gt; </td></tr>
<tr class="memitem:a5f75835c6570547ab2d0c50376202dc7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structsouffle_1_1detail_1_1is__ram__visitor.html">detail::is_ram_visitor</a>&lt; Lambda &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a5f75835c6570547ab2d0c50376202dc7">visitDepthFirst</a> (const <a class="el" href="classsouffle_1_1_ram_node.html">RamNode</a> &amp;root, const Lambda &amp;fun)</td></tr>
<tr class="memdesc:a5f75835c6570547ab2d0c50376202dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in a depth-first pre-order fashion applying the given function to each encountered node.  <a href="#a5f75835c6570547ab2d0c50376202dc7">More...</a><br /></td></tr>
<tr class="separator:a5f75835c6570547ab2d0c50376202dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e603a0cbf511478333b3d6ef87d49c5"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Ps, typename... Args&gt; </td></tr>
<tr class="memitem:a8e603a0cbf511478333b3d6ef87d49c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8e603a0cbf511478333b3d6ef87d49c5">visitDepthFirstPostOrder</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root, <a class="el" href="structsouffle_1_1_ast_visitor.html">AstVisitor</a>&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</td></tr>
<tr class="memdesc:a8e603a0cbf511478333b3d6ef87d49c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first post-order fashion applying the given visitor to each encountered node.  <a href="#a8e603a0cbf511478333b3d6ef87d49c5">More...</a><br /></td></tr>
<tr class="separator:a8e603a0cbf511478333b3d6ef87d49c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c81a4bc3ebe951bd58b9b323b451e3a"><td class="memTemplParams" colspan="2">template&lt;typename R , typename N &gt; </td></tr>
<tr class="memitem:a8c81a4bc3ebe951bd58b9b323b451e3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8c81a4bc3ebe951bd58b9b323b451e3a">visitDepthFirstPostOrder</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root, const std::function&lt; R(const N &amp;)&gt; &amp;fun)</td></tr>
<tr class="memdesc:a8c81a4bc3ebe951bd58b9b323b451e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first post-order fashion applying the given function to each encountered node.  <a href="#a8c81a4bc3ebe951bd58b9b323b451e3a">More...</a><br /></td></tr>
<tr class="separator:a8c81a4bc3ebe951bd58b9b323b451e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1033c68a525f042c980bc63e96363062"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename R  = typename lambda_traits&lt;Lambda&gt;::result_type, typename N  = typename lambda_traits&lt;Lambda&gt;::arg0_type&gt; </td></tr>
<tr class="memitem:a1033c68a525f042c980bc63e96363062"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structsouffle_1_1detail_1_1is__ast__visitor.html">detail::is_ast_visitor</a>&lt; Lambda &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1033c68a525f042c980bc63e96363062">visitDepthFirstPostOrder</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root, const Lambda &amp;fun)</td></tr>
<tr class="memdesc:a1033c68a525f042c980bc63e96363062"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first post-order fashion applying the given function to each encountered node.  <a href="#a1033c68a525f042c980bc63e96363062">More...</a><br /></td></tr>
<tr class="separator:a1033c68a525f042c980bc63e96363062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030c754119d60ea72cff8af5b62710e6"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Ps, typename... Args&gt; </td></tr>
<tr class="memitem:a030c754119d60ea72cff8af5b62710e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6">visitDepthFirstPreOrder</a> (const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;root, <a class="el" href="structsouffle_1_1_ast_visitor.html">AstVisitor</a>&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</td></tr>
<tr class="memdesc:a030c754119d60ea72cff8af5b62710e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first pre-order fashion applying the given visitor to each encountered node.  <a href="#a030c754119d60ea72cff8af5b62710e6">More...</a><br /></td></tr>
<tr class="separator:a030c754119d60ea72cff8af5b62710e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63199900991e5e4c5a08b3f0ecc28fc"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Ps, typename... Args&gt; </td></tr>
<tr class="memitem:aa63199900991e5e4c5a08b3f0ecc28fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa63199900991e5e4c5a08b3f0ecc28fc">visitDepthFirstPreOrder</a> (const <a class="el" href="classsouffle_1_1_ram_node.html">RamNode</a> &amp;root, <a class="el" href="structsouffle_1_1_ram_visitor.html">RamVisitor</a>&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</td></tr>
<tr class="memdesc:aa63199900991e5e4c5a08b3f0ecc28fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in a depth-first pre-order fashion applying the given visitor to each encountered node.  <a href="#aa63199900991e5e4c5a08b3f0ecc28fc">More...</a><br /></td></tr>
<tr class="separator:aa63199900991e5e4c5a08b3f0ecc28fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9757564e85959db8b14a9be7d544e1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6e9757564e85959db8b14a9be7d544e1">which</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a6e9757564e85959db8b14a9be7d544e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple implementation of a which tool.  <a href="#a6e9757564e85959db8b14a9be7d544e1">More...</a><br /></td></tr>
<tr class="separator:a6e9757564e85959db8b14a9be7d544e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0365b7f74600453cae13b5cc4a64cf29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a0365b7f74600453cae13b5cc4a64cf29">else</a></td></tr>
<tr class="separator:a0365b7f74600453cae13b5cc4a64cf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30960f5b40f826ffdc4cd2fb12161fe2"><td class="memItemLeft" align="right" valign="top">ss&lt;&lt; R&quot;_(&quot;usage&quot;: [)_&quot;;bool firstRow=true;Usage previousUsage=*usages.begin();previousUsage.time=beginTime;for(auto usage :usages) { comma(firstRow);ss&lt;&lt; '[';ss&lt;&lt;(usage.time - beginTime).count()/1000000.0&lt;&lt; &quot;, &quot;;ss&lt;&lt; 100.0 *(usage.usertime - previousUsage.usertime)/(usage.time - previousUsage.time)&lt;&lt; &quot;, &quot;;ss&lt;&lt; 100.0 *(usage.systemtime - previousUsage.systemtime)/(usage.time - previousUsage.time)&lt;&lt; &quot;, &quot;;ss&lt;&lt; usage.maxRSS *1024&lt;&lt; &quot;, &quot;;ss&lt;&lt; '&quot;'; bool firstCol = true; for (auto&amp; cur : out.getProgramRun()-&gt;getRelationsAtTime(previousUsage.time, usage.time)) { comma(firstCol); ss &lt;&lt; cur-&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a30960f5b40f826ffdc4cd2fb12161fe2">getName</a> ()</td></tr>
<tr class="separator:a30960f5b40f826ffdc4cd2fb12161fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16844ea6742671f3aed14d36267a103e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a16844ea6742671f3aed14d36267a103e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a16844ea6742671f3aed14d36267a103e">isRamType</a></td></tr>
<tr class="separator:a16844ea6742671f3aed14d36267a103e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e34f8a0110d99825e6a1e3e1123f866"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacesouffle.html#a71ed4e379ed3ad06b9d02a4fc8470646">RamFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8e34f8a0110d99825e6a1e3e1123f866">MAX_RAM_FLOAT</a> = std::numeric_limits&lt;<a class="el" href="namespacesouffle.html#a71ed4e379ed3ad06b9d02a4fc8470646">RamFloat</a>&gt;::max()</td></tr>
<tr class="separator:a8e34f8a0110d99825e6a1e3e1123f866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01cb9e9ef3b075f569709efcd0d8fc2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacesouffle.html#a506d6a56200708498577b6e4d3a83ae3">RamSigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac01cb9e9ef3b075f569709efcd0d8fc2">MAX_RAM_SIGNED</a> = std::numeric_limits&lt;<a class="el" href="namespacesouffle.html#a506d6a56200708498577b6e4d3a83ae3">RamSigned</a>&gt;::max()</td></tr>
<tr class="separator:ac01cb9e9ef3b075f569709efcd0d8fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ca99d17975adee2f4dda8a8f00783e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacesouffle.html#afaab74f4511cf7a2da6afe0e001be9c6">RamUnsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a73ca99d17975adee2f4dda8a8f00783e">MAX_RAM_UNSIGNED</a> = std::numeric_limits&lt;<a class="el" href="namespacesouffle.html#afaab74f4511cf7a2da6afe0e001be9c6">RamUnsigned</a>&gt;::max()</td></tr>
<tr class="separator:a73ca99d17975adee2f4dda8a8f00783e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dab3baf25a2525107df6666d6e9b40f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacesouffle.html#a71ed4e379ed3ad06b9d02a4fc8470646">RamFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a5dab3baf25a2525107df6666d6e9b40f">MIN_RAM_FLOAT</a> = std::numeric_limits&lt;<a class="el" href="namespacesouffle.html#a71ed4e379ed3ad06b9d02a4fc8470646">RamFloat</a>&gt;::min()</td></tr>
<tr class="separator:a5dab3baf25a2525107df6666d6e9b40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab108e1ed3dc35638e9432fba35831c99"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacesouffle.html#a506d6a56200708498577b6e4d3a83ae3">RamSigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab108e1ed3dc35638e9432fba35831c99">MIN_RAM_SIGNED</a> = std::numeric_limits&lt;<a class="el" href="namespacesouffle.html#a506d6a56200708498577b6e4d3a83ae3">RamSigned</a>&gt;::min()</td></tr>
<tr class="memdesc:ab108e1ed3dc35638e9432fba35831c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">lower and upper boundaries for the ram types  <a href="#ab108e1ed3dc35638e9432fba35831c99">More...</a><br /></td></tr>
<tr class="separator:ab108e1ed3dc35638e9432fba35831c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83783b2554d58083585aed095a51349"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacesouffle.html#afaab74f4511cf7a2da6afe0e001be9c6">RamUnsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af83783b2554d58083585aed095a51349">MIN_RAM_UNSIGNED</a> = std::numeric_limits&lt;<a class="el" href="namespacesouffle.html#afaab74f4511cf7a2da6afe0e001be9c6">RamUnsigned</a>&gt;::min()</td></tr>
<tr class="separator:af83783b2554d58083585aed095a51349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ebbb9279d847e1780c7423a4adf030"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacesouffle.html#a86f22adc58415a0ceecac60f7456f7d3">block_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a10ebbb9279d847e1780c7423a4adf030">rank_mask</a> = (1ul &lt;&lt; split_size) - 1</td></tr>
<tr class="separator:a10ebbb9279d847e1780c7423a4adf030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cae1829154de74317f872045c811c2"><td class="memItemLeft" align="right" valign="top">constexpr uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab6cae1829154de74317f872045c811c2">split_size</a> = 8u</td></tr>
<tr class="separator:ab6cae1829154de74317f872045c811c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Souffle - A Datalog Compiler Copyright (c) 2013, 2015, Oracle and/or its affiliates. </p>
<p>All rights reserved Licensed under the Universal Permissive License v 1.0 as shown at:</p><ul>
<li><a href="https://opensource.org/licenses/UPL">https://opensource.org/licenses/UPL</a></li>
<li>&lt;souffle root&gt;=""&gt;/licenses/SOUFFLE-UPL.txt </li>
</ul>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a851652d425321cd735fbe321f392fe85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851652d425321cd735fbe321f392fe85">&#9670;&nbsp;</a></span>AstRelationSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle.html#a851652d425321cd735fbe321f392fe85">souffle::AstRelationSet</a> = typedef std::set&lt;const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a>*, <a class="el" href="structsouffle_1_1_ast_name_comparison.html">AstNameComparison</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ast_relation_8h_source.html#l00181">181</a> of file <a class="el" href="_ast_relation_8h_source.html">AstRelation.h</a>.</p>

</div>
</div>
<a id="a86f22adc58415a0ceecac60f7456f7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f22adc58415a0ceecac60f7456f7d3">&#9670;&nbsp;</a></span>block_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle.html#a86f22adc58415a0ceecac60f7456f7d3">souffle::block_t</a> = typedef uint64_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_union_find_8h_source.html#l00045">45</a> of file <a class="el" href="_union_find_8h_source.html">UnionFind.h</a>.</p>

</div>
</div>
<a id="aae7d41d263a3aaacb9bbfc62c6becd56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7d41d263a3aaacb9bbfc62c6becd56">&#9670;&nbsp;</a></span>comparator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Arity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle.html#aae7d41d263a3aaacb9bbfc62c6becd56">souffle::comparator</a> = typedef typename <a class="el" href="structsouffle_1_1index__utils_1_1get__full__index.html">index_utils::get_full_index</a>&lt;Arity&gt;::type::comparator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interpreter_index_8cpp_source.html#l00565">565</a> of file <a class="el" href="_interpreter_index_8cpp_source.html">InterpreterIndex.cpp</a>.</p>

</div>
</div>
<a id="a3014e8a5f6aab584f9749e0128b84327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3014e8a5f6aab584f9749e0128b84327">&#9670;&nbsp;</a></span>IndexFactory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle.html#a3014e8a5f6aab584f9749e0128b84327">souffle::IndexFactory</a> = typedef std::unique_ptr&lt;<a class="el" href="classsouffle_1_1_interpreter_index.html">InterpreterIndex</a>&gt; (*)(const <a class="el" href="classsouffle_1_1_order.html">Order</a>&amp;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interpreter_index_8h_source.html#l00475">475</a> of file <a class="el" href="_interpreter_index_8h_source.html">InterpreterIndex.h</a>.</p>

</div>
</div>
<a id="a88ed8d79242399e8c145385667df783c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ed8d79242399e8c145385667df783c">&#9670;&nbsp;</a></span>IndexViewPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle.html#a88ed8d79242399e8c145385667df783c">souffle::IndexViewPtr</a> = typedef std::unique_ptr&lt;<a class="el" href="classsouffle_1_1_index_view.html">IndexView</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interpreter_index_8h_source.html#l00387">387</a> of file <a class="el" href="_interpreter_index_8h_source.html">InterpreterIndex.h</a>.</p>

</div>
</div>
<a id="aa5cd00ed671edea5d1ddf34bf8260388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cd00ed671edea5d1ddf34bf8260388">&#9670;&nbsp;</a></span>parent_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle.html#aa5cd00ed671edea5d1ddf34bf8260388">souffle::parent_t</a> = typedef uint64_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_union_find_8h_source.html#l00039">39</a> of file <a class="el" href="_union_find_8h_source.html">UnionFind.h</a>.</p>

</div>
</div>
<a id="aa9d8dbe49d3251e572172b31023b1ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d8dbe49d3251e572172b31023b1ce9">&#9670;&nbsp;</a></span>RamDomain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle.html#aa9d8dbe49d3251e572172b31023b1ce9">souffle::RamDomain</a> = typedef int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ram_types_8h_source.html#l00092">92</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

</div>
</div>
<a id="a71ed4e379ed3ad06b9d02a4fc8470646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ed4e379ed3ad06b9d02a4fc8470646">&#9670;&nbsp;</a></span>RamFloat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle.html#a71ed4e379ed3ad06b9d02a4fc8470646">souffle::RamFloat</a> = typedef float</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ram_types_8h_source.html#l00096">96</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

</div>
</div>
<a id="a506d6a56200708498577b6e4d3a83ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506d6a56200708498577b6e4d3a83ae3">&#9670;&nbsp;</a></span>RamSigned</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle.html#a506d6a56200708498577b6e4d3a83ae3">souffle::RamSigned</a> = typedef <a class="el" href="namespacesouffle.html#aa9d8dbe49d3251e572172b31023b1ce9">RamDomain</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ram_types_8h_source.html#l00093">93</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

</div>
</div>
<a id="afaab74f4511cf7a2da6afe0e001be9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaab74f4511cf7a2da6afe0e001be9c6">&#9670;&nbsp;</a></span>RamUnsigned</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle.html#afaab74f4511cf7a2da6afe0e001be9c6">souffle::RamUnsigned</a> = typedef uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ram_types_8h_source.html#l00094">94</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

</div>
</div>
<a id="a5046648056218d9001c24f049c12c19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5046648056218d9001c24f049c12c19a">&#9670;&nbsp;</a></span>rank_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle.html#a5046648056218d9001c24f049c12c19a">souffle::rank_t</a> = typedef uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_union_find_8h_source.html#l00037">37</a> of file <a class="el" href="_union_find_8h_source.html">UnionFind.h</a>.</p>

</div>
</div>
<a id="aaf42249e9320e05cbb320528f299fb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf42249e9320e05cbb320528f299fb15">&#9670;&nbsp;</a></span>SearchSignature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle.html#aaf42249e9320e05cbb320528f299fb15">souffle::SearchSignature</a> = typedef uint64_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>search signature of a RAM operation; each bit represents an attribute of a relation. </p>
<p>A one represents that the attribute has an assigned value; a zero represents that no value exists (i.e. attribute is unbounded) in the search. </p>

<p class="definition">Definition at line <a class="el" href="_ram_types_8h_source.html#l00144">144</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

</div>
</div>
<a id="ad0dcec7b78fdde7450cb55df1fece164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0dcec7b78fdde7450cb55df1fece164">&#9670;&nbsp;</a></span>sips_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle.html#ad0dcec7b78fdde7450cb55df1fece164">souffle::sips_t</a> = typedef std::function&lt;unsigned int(std::vector&lt;<a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a>*&gt;, const std::set&lt;std::string&gt;&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00040">40</a> of file <a class="el" href="_reorder_literals_transformer_8cpp_source.html">ReorderLiteralsTransformer.cpp</a>.</p>

</div>
</div>
<a id="a954e259daffe7c9e04cfeb83ea0c5742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954e259daffe7c9e04cfeb83ea0c5742">&#9670;&nbsp;</a></span>t_tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Arity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle.html#a954e259daffe7c9e04cfeb83ea0c5742">souffle::t_tuple</a> = typedef typename <a class="el" href="structsouffle_1_1_tuple.html">souffle::Tuple</a>&lt;<a class="el" href="namespacesouffle.html#aa9d8dbe49d3251e572172b31023b1ce9">RamDomain</a>, Arity&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interpreter_index_8cpp_source.html#l00569">569</a> of file <a class="el" href="_interpreter_index_8cpp_source.html">InterpreterIndex.cpp</a>.</p>

</div>
</div>
<a id="a9eb29a1677ffbe44fe8663f881213f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb29a1677ffbe44fe8663f881213f0e">&#9670;&nbsp;</a></span>time_point</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle.html#a9eb29a1677ffbe44fe8663f881213f0e">souffle::time_point</a> = typedef std::chrono::high_resolution_clock::time_point</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01033">1033</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a47203d0502442fd4785dbaeffc4acc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47203d0502442fd4785dbaeffc4acc0f">&#9670;&nbsp;</a></span>yyscan_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesouffle.html#a47203d0502442fd4785dbaeffc4acc0f">souffle::yyscan_t</a> = typedef void*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_parser_driver_8h_source.html#l00039">39</a> of file <a class="el" href="_parser_driver_8h_source.html">ParserDriver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa26a7e6147aca5568158e38f08ffcf21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26a7e6147aca5568158e38f08ffcf21">&#9670;&nbsp;</a></span>AggregateOp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">souffle::AggregateOp</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Types of aggregation functions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5"></a>MAX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653"></a>MIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26a7e6147aca5568158e38f08ffcf21a6970bdc2201030b9c03fbdcf3973858a"></a>SUM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1"></a>FMAX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6"></a>FMIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26a7e6147aca5568158e38f08ffcf21a0645fcc11b74dbdbf2d7501942fa6f6f"></a>FSUM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26a7e6147aca5568158e38f08ffcf21a4ea6d1161ea24d7599365f574aff6610"></a>MEAN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059"></a>UMAX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb"></a>UMIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26a7e6147aca5568158e38f08ffcf21ae6246115490f016a4ecb2604ba5fc2ed"></a>USUM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa26a7e6147aca5568158e38f08ffcf21a4905ac9d6a22bdfc1ae096094ce6248d"></a>COUNT&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_aggregate_op_8h_source.html#l00024">24</a> of file <a class="el" href="_aggregate_op_8h_source.html">AggregateOp.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;                       {</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">MAX</a>,</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">MIN</a>,</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a6970bdc2201030b9c03fbdcf3973858a">SUM</a>,</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1">FMAX</a>,</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6">FMIN</a>,</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a0645fcc11b74dbdbf2d7501942fa6f6f">FSUM</a>,</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a4ea6d1161ea24d7599365f574aff6610">MEAN</a>,</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059">UMAX</a>,</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb">UMIN</a>,</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ae6246115490f016a4ecb2604ba5fc2ed">USUM</a>,</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a4905ac9d6a22bdfc1ae096094ce6248d">COUNT</a>,</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;};</div><div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21ae6246115490f016a4ecb2604ba5fc2ed"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ae6246115490f016a4ecb2604ba5fc2ed">souffle::AggregateOp::USUM</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21a4905ac9d6a22bdfc1ae096094ce6248d"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a4905ac9d6a22bdfc1ae096094ce6248d">souffle::AggregateOp::COUNT</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb">souffle::AggregateOp::UMIN</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21a6970bdc2201030b9c03fbdcf3973858a"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a6970bdc2201030b9c03fbdcf3973858a">souffle::AggregateOp::SUM</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">souffle::AggregateOp::MAX</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">souffle::AggregateOp::MIN</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21a4ea6d1161ea24d7599365f574aff6610"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a4ea6d1161ea24d7599365f574aff6610">souffle::AggregateOp::MEAN</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059">souffle::AggregateOp::UMAX</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6">souffle::AggregateOp::FMIN</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21a0645fcc11b74dbdbf2d7501942fa6f6f"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a0645fcc11b74dbdbf2d7501942fa6f6f">souffle::AggregateOp::FSUM</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1">souffle::AggregateOp::FMAX</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac460f7c8b5ab0da53316d6bb32a19f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac460f7c8b5ab0da53316d6bb32a19f49">&#9670;&nbsp;</a></span>BinaryConstraintOp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">souffle::BinaryConstraintOp</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary <a class="el" href="classsouffle_1_1_constraint.html" title="A generic base class for constraints on variables. ">Constraint</a> Operators. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47"></a>EQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49aa123e958001611b441dab45ff11ba98a"></a>FEQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0"></a>NE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49a90dc357130ab3c37ef770e959ab49b9c"></a>FNE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b"></a>LT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49a2b4652512a6c88f5a39c3288081b6e13"></a>ULT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49a1cc288bb3360b602513d8ffe37a874f9"></a>FLT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49ac71563c4ae48cc1bbd2e7913366cdf7e"></a>SLT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6"></a>LE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49ae29e365fd3b5e59c86218486a0c1c7c1"></a>ULE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49a56267eaefed8c4c5255779a597a72363"></a>FLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49a0a1d07df9a43688c7128eefbe3d41b08"></a>SLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020"></a>GT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49a7efc25ec6c881b13261c1a6d88762483"></a>UGT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49aa302b6b103aca34c46209564002a8252"></a>FGT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49a53acb49d0534e8912fec8569e845400f"></a>SGT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9"></a>GE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49ada0d6078de3703b5680eb9361f2d68fd"></a>UGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49aa1d7888b08b54d43aeadc58136fa0907"></a>FGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49add25db0709d4c7c05b057f311208f753"></a>SGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a"></a>MATCH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b"></a>CONTAINS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01"></a>NOT_MATCH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0"></a>NOT_CONTAINS&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_binary_constraint_ops_8h_source.html#l00034">34</a> of file <a class="el" href="_binary_constraint_ops_8h_source.html">BinaryConstraintOps.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;                              {</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>,           <span class="comment">// equivalence of two values</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa123e958001611b441dab45ff11ba98a">FEQ</a>,          <span class="comment">// float equiv; b/c NaNs are never equiv</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">NE</a>,           <span class="comment">// whether two values are different</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a90dc357130ab3c37ef770e959ab49b9c">FNE</a>,          <span class="comment">// float diff; b/c NaNs are always different</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">LT</a>,           <span class="comment">// signed &lt;</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2b4652512a6c88f5a39c3288081b6e13">ULT</a>,          <span class="comment">// Unsigned &lt;</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a1cc288bb3360b602513d8ffe37a874f9">FLT</a>,          <span class="comment">// Float &lt;</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac71563c4ae48cc1bbd2e7913366cdf7e">SLT</a>,          <span class="comment">// Symbol &lt;</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">LE</a>,           <span class="comment">// signed ≤</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ae29e365fd3b5e59c86218486a0c1c7c1">ULE</a>,          <span class="comment">// Unsigned ≤</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a56267eaefed8c4c5255779a597a72363">FLE</a>,          <span class="comment">// Float ≤</span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a0a1d07df9a43688c7128eefbe3d41b08">SLE</a>,          <span class="comment">// Symbol ≤</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">GT</a>,           <span class="comment">// signed &gt;</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7efc25ec6c881b13261c1a6d88762483">UGT</a>,          <span class="comment">// unsigned &gt;</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa302b6b103aca34c46209564002a8252">FGT</a>,          <span class="comment">// float &gt;</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a53acb49d0534e8912fec8569e845400f">SGT</a>,          <span class="comment">// Symbol &gt;</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">GE</a>,           <span class="comment">// signed ≥</span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ada0d6078de3703b5680eb9361f2d68fd">UGE</a>,          <span class="comment">// Unsigned ≥</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa1d7888b08b54d43aeadc58136fa0907">FGE</a>,          <span class="comment">// Float ≥</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49add25db0709d4c7c05b057f311208f753">SGE</a>,          <span class="comment">// Symbol ≥</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a">MATCH</a>,        <span class="comment">// matching string</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b">CONTAINS</a>,     <span class="comment">// whether a sub-string is contained in a string</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01">NOT_MATCH</a>,    <span class="comment">// not matching string</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0">NOT_CONTAINS</a>  <span class="comment">// whether a sub-string is not contained in a string</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;};</div><div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49aa123e958001611b441dab45ff11ba98a"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa123e958001611b441dab45ff11ba98a">souffle::BinaryConstraintOp::FEQ</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49ada0d6078de3703b5680eb9361f2d68fd"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ada0d6078de3703b5680eb9361f2d68fd">souffle::BinaryConstraintOp::UGE</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01">souffle::BinaryConstraintOp::NOT_MATCH</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49aa1d7888b08b54d43aeadc58136fa0907"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa1d7888b08b54d43aeadc58136fa0907">souffle::BinaryConstraintOp::FGE</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49ae29e365fd3b5e59c86218486a0c1c7c1"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ae29e365fd3b5e59c86218486a0c1c7c1">souffle::BinaryConstraintOp::ULE</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">souffle::BinaryConstraintOp::LT</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a2b4652512a6c88f5a39c3288081b6e13"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2b4652512a6c88f5a39c3288081b6e13">souffle::BinaryConstraintOp::ULT</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a7efc25ec6c881b13261c1a6d88762483"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7efc25ec6c881b13261c1a6d88762483">souffle::BinaryConstraintOp::UGT</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49aa302b6b103aca34c46209564002a8252"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa302b6b103aca34c46209564002a8252">souffle::BinaryConstraintOp::FGT</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49add25db0709d4c7c05b057f311208f753"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49add25db0709d4c7c05b057f311208f753">souffle::BinaryConstraintOp::SGE</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">souffle::BinaryConstraintOp::LE</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a1cc288bb3360b602513d8ffe37a874f9"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a1cc288bb3360b602513d8ffe37a874f9">souffle::BinaryConstraintOp::FLT</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">souffle::BinaryConstraintOp::EQ</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">souffle::BinaryConstraintOp::NE</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">souffle::BinaryConstraintOp::GE</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a56267eaefed8c4c5255779a597a72363"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a56267eaefed8c4c5255779a597a72363">souffle::BinaryConstraintOp::FLE</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">souffle::BinaryConstraintOp::GT</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b">souffle::BinaryConstraintOp::CONTAINS</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49ac71563c4ae48cc1bbd2e7913366cdf7e"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac71563c4ae48cc1bbd2e7913366cdf7e">souffle::BinaryConstraintOp::SLT</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a0a1d07df9a43688c7128eefbe3d41b08"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a0a1d07df9a43688c7128eefbe3d41b08">souffle::BinaryConstraintOp::SLE</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a90dc357130ab3c37ef770e959ab49b9c"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a90dc357130ab3c37ef770e959ab49b9c">souffle::BinaryConstraintOp::FNE</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a">souffle::BinaryConstraintOp::MATCH</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0">souffle::BinaryConstraintOp::NOT_CONTAINS</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49a53acb49d0534e8912fec8569e845400f"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a53acb49d0534e8912fec8569e845400f">souffle::BinaryConstraintOp::SGT</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a28ddd8269d2a01a6041800d3b2e3fad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ddd8269d2a01a6041800d3b2e3fad9">&#9670;&nbsp;</a></span>FunctorOp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">souffle::FunctorOp</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9ac23431d0209648a6b31fa837dd56d681"></a>ORD&#160;</td><td class="fielddoc"><p>Unary Functor Operators. </p>
</td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9afc37711c3936f2459ef27e1dbe4f6480"></a>STRLEN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a5dd68b1a7db42a1cce4dce09dbaa179e"></a>NEG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a36da8d8fdce0e080abfcab7af41066c6"></a>FNEG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a0fd78279a775c262180e0cfbad6fa9eb"></a>BNOT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9ac2fc8ad7a275c06c870529f9f9f07caa"></a>UBNOT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a81145009eec44ad2c399c9459a01d8f0"></a>LNOT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a7fdc4b2848234d42fe9a22b78fd68910"></a>ULNOT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9aae9c007a17eb01f69e2dba22cf15cf30"></a>TONUMBER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a91b8cf1c9769ddb9cb64191c89becc1b"></a>TOSTRING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a4c0f1a4930775ab571de3e85aedc623e"></a>ITOU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9ac059c9401f1af0e831f9f180f3c6bfef"></a>UTOI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9afc526b23b5b6d76a12984c29bf63c4a3"></a>ITOF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a81bf488d5db54d36a738384aaf845fdf"></a>FTOI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a9d0ef69432b16260e9622b4f614bc9c5"></a>UTOF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a89aa92cb66549459a7d407094aacbcef"></a>FTOU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a9eeb52badb613229884838847294b90d"></a>ADD&#160;</td><td class="fielddoc"><p>Binary Functor Operators. </p>
</td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a241dd841abade20fcb27b8a9f494e1eb"></a>SUB&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a2cdf52a55876063ec93b7d18bc741f6c"></a>MUL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a29bbf66f7f8529ec47e394fb5a36c646"></a>DIV&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a8c670f8c37b95e1ed14a0ce414b049c7"></a>EXP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a26a4b44a837bf97b972628509912b4a5"></a>MAX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9ace31e2a082d17e038fcc6e3006166653"></a>MIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9ac5a28f4b35a2884fa3277150ac5d0967"></a>MOD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9aa8a5bbeedca093b94b7f0d3f185b98f7"></a>BAND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a0adf6aac232504c55ea4202e09498bfd"></a>BOR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a21506bac4ecfbfe4272b9bf8185446b6"></a>BXOR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a88d973d6a866ababf2fb28a6112f8d46"></a>BSHIFT_L&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a9e74511ce5c138f374559a76abb6e209"></a>BSHIFT_R&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a3fdb4dd3e2677523449a3747923d4401"></a>BSHIFT_R_UNSIGNED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a479a809c0b6eaaefd3b1df16f976df06"></a>LAND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9ad3335c358811cfc353257e21b1d38229"></a>LOR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a1f0002abde2c29615d914ab0228c68d3"></a>UADD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9af8aba91736be4bad67181a8cce032337"></a>USUB&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9ae89690f1278cca1400678daaa4a6a3b7"></a>UMUL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a56d5c96c848631ef14e1f2a6e0f15d49"></a>UDIV&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a59407eef1229dea3aac5dc8d77d06c92"></a>UEXP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9adf23c745cc30333029ae3a73cd87c059"></a>UMAX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a925d976d8f961af767954de9f62f40cb"></a>UMIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a4bbe00e945b01d43cb7edecf51b0de5c"></a>UMOD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9ab5755f546c5f5ca6a3f1720ef8e642ef"></a>UBAND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a4803dabeb7190f48195a26654eafaa42"></a>UBOR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a70f4367aed9601f37bfbdd4586b327df"></a>UBXOR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a653789f2eb8bfa402c5f60ceceac247b"></a>UBSHIFT_L&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9aab623d5679ac1cc907cb363e2d51eb14"></a>UBSHIFT_R&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a07da89f09f961f63a15696ac57bbc1c3"></a>UBSHIFT_R_UNSIGNED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a3d0f34d8e784f8a48332424dd598a27a"></a>ULAND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9addb2113545b6bd7fbe64ed7bff507964"></a>ULOR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9afc2cbacfa7c4ef9bc72773ebdd9fe166"></a>FADD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a06be1058e817f781f4e0f0641f436247"></a>FSUB&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a26a83f923754f1e7aa12640b8bcca29a"></a>FMUL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9abccb2b7436e0cbfb334fe07304fe28a6"></a>FDIV&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a107c7a3cc48a0fe27d435e82c8679ef0"></a>FEXP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a1e692622d3020e12589d7fb475de73b1"></a>FMAX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9aa188dc14c6a8fb8a3e7204027a3f16e6"></a>FMIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a00e365acdc6de6b62421116e865bd420"></a>SMAX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a2d9174ad446fde0fc750265f9e075977"></a>SMIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9ac01ae1a5f122f25ce5675f86028b536a"></a>CAT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28ddd8269d2a01a6041800d3b2e3fad9a0f85e58dd75e7025beb47ee590ff7669"></a>SUBSTR&#160;</td><td class="fielddoc"><p>Ternary Functor Operators. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_functor_ops_8h_source.html#l00027">27</a> of file <a class="el" href="_functor_ops_8h_source.html">FunctorOps.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;                     {<span class="comment"></span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment">    /** Unary Functor Operators */</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac23431d0209648a6b31fa837dd56d681">ORD</a>,       <span class="comment">// ordinal number of a string</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc37711c3936f2459ef27e1dbe4f6480">STRLEN</a>,    <span class="comment">// length of a string</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a5dd68b1a7db42a1cce4dce09dbaa179e">NEG</a>,       <span class="comment">// Signed numeric negation</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a36da8d8fdce0e080abfcab7af41066c6">FNEG</a>,      <span class="comment">// Float numeric negation</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0fd78279a775c262180e0cfbad6fa9eb">BNOT</a>,      <span class="comment">// Signed bitwise negation</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac2fc8ad7a275c06c870529f9f9f07caa">UBNOT</a>,     <span class="comment">// Unsigned bitwise negation</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a81145009eec44ad2c399c9459a01d8f0">LNOT</a>,      <span class="comment">// Signed logical negation</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a7fdc4b2848234d42fe9a22b78fd68910">ULNOT</a>,     <span class="comment">// Unsigned logical negation</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aae9c007a17eb01f69e2dba22cf15cf30">TONUMBER</a>,  <span class="comment">// convert string to number</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a91b8cf1c9769ddb9cb64191c89becc1b">TOSTRING</a>,  <span class="comment">// convert number to string</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4c0f1a4930775ab571de3e85aedc623e">ITOU</a>,      <span class="comment">// convert signed number to unsigned</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac059c9401f1af0e831f9f180f3c6bfef">UTOI</a>,      <span class="comment">// convert unsigned number to signed</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc526b23b5b6d76a12984c29bf63c4a3">ITOF</a>,      <span class="comment">// convert signed number to float</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a81bf488d5db54d36a738384aaf845fdf">FTOI</a>,      <span class="comment">// convert float number to signed number.</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9d0ef69432b16260e9622b4f614bc9c5">UTOF</a>,      <span class="comment">// convert unsigned number to a float.</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a89aa92cb66549459a7d407094aacbcef">FTOU</a>,      <span class="comment">// convert float to unsigned number.</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment">    /** Binary Functor Operators */</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9eeb52badb613229884838847294b90d">ADD</a>,                 <span class="comment">// addition</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a241dd841abade20fcb27b8a9f494e1eb">SUB</a>,                 <span class="comment">// subtraction</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2cdf52a55876063ec93b7d18bc741f6c">MUL</a>,                 <span class="comment">// multiplication</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a29bbf66f7f8529ec47e394fb5a36c646">DIV</a>,                 <span class="comment">// division</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>,                 <span class="comment">// exponent</span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">MAX</a>,                 <span class="comment">// max of two numbers</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">MIN</a>,                 <span class="comment">// min of two numbers</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac5a28f4b35a2884fa3277150ac5d0967">MOD</a>,                 <span class="comment">// modulus</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aa8a5bbeedca093b94b7f0d3f185b98f7">BAND</a>,                <span class="comment">// bitwise and</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0adf6aac232504c55ea4202e09498bfd">BOR</a>,                 <span class="comment">// bitwise or</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a21506bac4ecfbfe4272b9bf8185446b6">BXOR</a>,                <span class="comment">// bitwise exclusive or</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a88d973d6a866ababf2fb28a6112f8d46">BSHIFT_L</a>,            <span class="comment">// bitwise shift left</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9e74511ce5c138f374559a76abb6e209">BSHIFT_R</a>,            <span class="comment">// bitwise shift right</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3fdb4dd3e2677523449a3747923d4401">BSHIFT_R_UNSIGNED</a>,   <span class="comment">// bitwise shift right (unsigned)</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a479a809c0b6eaaefd3b1df16f976df06">LAND</a>,                <span class="comment">// logical and</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ad3335c358811cfc353257e21b1d38229">LOR</a>,                 <span class="comment">// logical or</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a1f0002abde2c29615d914ab0228c68d3">UADD</a>,                <span class="comment">// addition</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9af8aba91736be4bad67181a8cce032337">USUB</a>,                <span class="comment">// subtraction</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ae89690f1278cca1400678daaa4a6a3b7">UMUL</a>,                <span class="comment">// multiplication</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a56d5c96c848631ef14e1f2a6e0f15d49">UDIV</a>,                <span class="comment">// division</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a59407eef1229dea3aac5dc8d77d06c92">UEXP</a>,                <span class="comment">// exponent</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059">UMAX</a>,                <span class="comment">// max of two numbers</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb">UMIN</a>,                <span class="comment">// min of two numbers</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4bbe00e945b01d43cb7edecf51b0de5c">UMOD</a>,                <span class="comment">// modulus</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ab5755f546c5f5ca6a3f1720ef8e642ef">UBAND</a>,               <span class="comment">// bitwise and</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4803dabeb7190f48195a26654eafaa42">UBOR</a>,                <span class="comment">// bitwise or</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a70f4367aed9601f37bfbdd4586b327df">UBXOR</a>,               <span class="comment">// bitwise exclusive or</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a653789f2eb8bfa402c5f60ceceac247b">UBSHIFT_L</a>,           <span class="comment">// bitwise shift right</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aab623d5679ac1cc907cb363e2d51eb14">UBSHIFT_R</a>,           <span class="comment">// bitwise shift right</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a07da89f09f961f63a15696ac57bbc1c3">UBSHIFT_R_UNSIGNED</a>,  <span class="comment">// bitwise shift right (unsigned)</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3d0f34d8e784f8a48332424dd598a27a">ULAND</a>,               <span class="comment">// logical and</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9addb2113545b6bd7fbe64ed7bff507964">ULOR</a>,                <span class="comment">// logical or</span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc2cbacfa7c4ef9bc72773ebdd9fe166">FADD</a>,                <span class="comment">// addition</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a06be1058e817f781f4e0f0641f436247">FSUB</a>,                <span class="comment">// subtraction</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a26a83f923754f1e7aa12640b8bcca29a">FMUL</a>,                <span class="comment">// multiplication</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9abccb2b7436e0cbfb334fe07304fe28a6">FDIV</a>,                <span class="comment">// division</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a107c7a3cc48a0fe27d435e82c8679ef0">FEXP</a>,                <span class="comment">// exponent</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1">FMAX</a>,                <span class="comment">// max of two floats</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6">FMIN</a>,                <span class="comment">// min of two floats</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a00e365acdc6de6b62421116e865bd420">SMAX</a>,                <span class="comment">// max of two symbols</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2d9174ad446fde0fc750265f9e075977">SMIN</a>,                <span class="comment">// min of two symbols</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac01ae1a5f122f25ce5675f86028b536a">CAT</a>,  <span class="comment">// string concatenation</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment">    /** Ternary Functor Operators */</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <a class="code" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0f85e58dd75e7025beb47ee590ff7669">SUBSTR</a>,  <span class="comment">// substring</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;};</div><div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9ae89690f1278cca1400678daaa4a6a3b7"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ae89690f1278cca1400678daaa4a6a3b7">souffle::FunctorOp::UMUL</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a56d5c96c848631ef14e1f2a6e0f15d49"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a56d5c96c848631ef14e1f2a6e0f15d49">souffle::FunctorOp::UDIV</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a3fdb4dd3e2677523449a3747923d4401"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3fdb4dd3e2677523449a3747923d4401">souffle::FunctorOp::BSHIFT_R_UNSIGNED</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a59407eef1229dea3aac5dc8d77d06c92"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a59407eef1229dea3aac5dc8d77d06c92">souffle::FunctorOp::UEXP</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9abccb2b7436e0cbfb334fe07304fe28a6"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9abccb2b7436e0cbfb334fe07304fe28a6">souffle::FunctorOp::FDIV</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9ad3335c358811cfc353257e21b1d38229"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ad3335c358811cfc353257e21b1d38229">souffle::FunctorOp::LOR</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a241dd841abade20fcb27b8a9f494e1eb"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a241dd841abade20fcb27b8a9f494e1eb">souffle::FunctorOp::SUB</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9afc526b23b5b6d76a12984c29bf63c4a3"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc526b23b5b6d76a12984c29bf63c4a3">souffle::FunctorOp::ITOF</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a2d9174ad446fde0fc750265f9e075977"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2d9174ad446fde0fc750265f9e075977">souffle::FunctorOp::SMIN</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a653789f2eb8bfa402c5f60ceceac247b"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a653789f2eb8bfa402c5f60ceceac247b">souffle::FunctorOp::UBSHIFT_L</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9ac059c9401f1af0e831f9f180f3c6bfef"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac059c9401f1af0e831f9f180f3c6bfef">souffle::FunctorOp::UTOI</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a91b8cf1c9769ddb9cb64191c89becc1b"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a91b8cf1c9769ddb9cb64191c89becc1b">souffle::FunctorOp::TOSTRING</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a2cdf52a55876063ec93b7d18bc741f6c"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2cdf52a55876063ec93b7d18bc741f6c">souffle::FunctorOp::MUL</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a9e74511ce5c138f374559a76abb6e209"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9e74511ce5c138f374559a76abb6e209">souffle::FunctorOp::BSHIFT_R</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a70f4367aed9601f37bfbdd4586b327df"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a70f4367aed9601f37bfbdd4586b327df">souffle::FunctorOp::UBXOR</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb">souffle::AggregateOp::UMIN</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9ac01ae1a5f122f25ce5675f86028b536a"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac01ae1a5f122f25ce5675f86028b536a">souffle::FunctorOp::CAT</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a81145009eec44ad2c399c9459a01d8f0"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a81145009eec44ad2c399c9459a01d8f0">souffle::FunctorOp::LNOT</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9aa8a5bbeedca093b94b7f0d3f185b98f7"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aa8a5bbeedca093b94b7f0d3f185b98f7">souffle::FunctorOp::BAND</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a00e365acdc6de6b62421116e865bd420"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a00e365acdc6de6b62421116e865bd420">souffle::FunctorOp::SMAX</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a07da89f09f961f63a15696ac57bbc1c3"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a07da89f09f961f63a15696ac57bbc1c3">souffle::FunctorOp::UBSHIFT_R_UNSIGNED</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9af8aba91736be4bad67181a8cce032337"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9af8aba91736be4bad67181a8cce032337">souffle::FunctorOp::USUB</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a06be1058e817f781f4e0f0641f436247"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a06be1058e817f781f4e0f0641f436247">souffle::FunctorOp::FSUB</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a89aa92cb66549459a7d407094aacbcef"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a89aa92cb66549459a7d407094aacbcef">souffle::FunctorOp::FTOU</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9afc2cbacfa7c4ef9bc72773ebdd9fe166"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc2cbacfa7c4ef9bc72773ebdd9fe166">souffle::FunctorOp::FADD</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a88d973d6a866ababf2fb28a6112f8d46"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a88d973d6a866ababf2fb28a6112f8d46">souffle::FunctorOp::BSHIFT_L</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">souffle::AggregateOp::MAX</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9ab5755f546c5f5ca6a3f1720ef8e642ef"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ab5755f546c5f5ca6a3f1720ef8e642ef">souffle::FunctorOp::UBAND</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">souffle::AggregateOp::MIN</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a4803dabeb7190f48195a26654eafaa42"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4803dabeb7190f48195a26654eafaa42">souffle::FunctorOp::UBOR</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a26a83f923754f1e7aa12640b8bcca29a"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a26a83f923754f1e7aa12640b8bcca29a">souffle::FunctorOp::FMUL</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059">souffle::AggregateOp::UMAX</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a479a809c0b6eaaefd3b1df16f976df06"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a479a809c0b6eaaefd3b1df16f976df06">souffle::FunctorOp::LAND</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a9d0ef69432b16260e9622b4f614bc9c5"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9d0ef69432b16260e9622b4f614bc9c5">souffle::FunctorOp::UTOF</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a107c7a3cc48a0fe27d435e82c8679ef0"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a107c7a3cc48a0fe27d435e82c8679ef0">souffle::FunctorOp::FEXP</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a0adf6aac232504c55ea4202e09498bfd"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0adf6aac232504c55ea4202e09498bfd">souffle::FunctorOp::BOR</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9ac2fc8ad7a275c06c870529f9f9f07caa"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac2fc8ad7a275c06c870529f9f9f07caa">souffle::FunctorOp::UBNOT</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a9eeb52badb613229884838847294b90d"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9eeb52badb613229884838847294b90d">souffle::FunctorOp::ADD</a></div><div class="ttdoc">Binary Functor Operators. </div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9addb2113545b6bd7fbe64ed7bff507964"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9addb2113545b6bd7fbe64ed7bff507964">souffle::FunctorOp::ULOR</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a29bbf66f7f8529ec47e394fb5a36c646"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a29bbf66f7f8529ec47e394fb5a36c646">souffle::FunctorOp::DIV</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a7fdc4b2848234d42fe9a22b78fd68910"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a7fdc4b2848234d42fe9a22b78fd68910">souffle::FunctorOp::ULNOT</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9aae9c007a17eb01f69e2dba22cf15cf30"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aae9c007a17eb01f69e2dba22cf15cf30">souffle::FunctorOp::TONUMBER</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9ac5a28f4b35a2884fa3277150ac5d0967"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac5a28f4b35a2884fa3277150ac5d0967">souffle::FunctorOp::MOD</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a4c0f1a4930775ab571de3e85aedc623e"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4c0f1a4930775ab571de3e85aedc623e">souffle::FunctorOp::ITOU</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a1f0002abde2c29615d914ab0228c68d3"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a1f0002abde2c29615d914ab0228c68d3">souffle::FunctorOp::UADD</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6">souffle::AggregateOp::FMIN</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a4bbe00e945b01d43cb7edecf51b0de5c"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4bbe00e945b01d43cb7edecf51b0de5c">souffle::FunctorOp::UMOD</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a36da8d8fdce0e080abfcab7af41066c6"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a36da8d8fdce0e080abfcab7af41066c6">souffle::FunctorOp::FNEG</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a21506bac4ecfbfe4272b9bf8185446b6"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a21506bac4ecfbfe4272b9bf8185446b6">souffle::FunctorOp::BXOR</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a0fd78279a775c262180e0cfbad6fa9eb"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0fd78279a775c262180e0cfbad6fa9eb">souffle::FunctorOp::BNOT</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9ac23431d0209648a6b31fa837dd56d681"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac23431d0209648a6b31fa837dd56d681">souffle::FunctorOp::ORD</a></div><div class="ttdoc">Unary Functor Operators. </div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a81bf488d5db54d36a738384aaf845fdf"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a81bf488d5db54d36a738384aaf845fdf">souffle::FunctorOp::FTOI</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a8c670f8c37b95e1ed14a0ce414b049c7"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a8c670f8c37b95e1ed14a0ce414b049c7">souffle::FunctorOp::EXP</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a3d0f34d8e784f8a48332424dd598a27a"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3d0f34d8e784f8a48332424dd598a27a">souffle::FunctorOp::ULAND</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9aab623d5679ac1cc907cb363e2d51eb14"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aab623d5679ac1cc907cb363e2d51eb14">souffle::FunctorOp::UBSHIFT_R</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a0f85e58dd75e7025beb47ee590ff7669"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0f85e58dd75e7025beb47ee590ff7669">souffle::FunctorOp::SUBSTR</a></div><div class="ttdoc">Ternary Functor Operators. </div></div>
<div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1">souffle::AggregateOp::FMAX</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9afc37711c3936f2459ef27e1dbe4f6480"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc37711c3936f2459ef27e1dbe4f6480">souffle::FunctorOp::STRLEN</a></div></div>
<div class="ttc" id="namespacesouffle_html_a28ddd8269d2a01a6041800d3b2e3fad9a5dd68b1a7db42a1cce4dce09dbaa179e"><div class="ttname"><a href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a5dd68b1a7db42a1cce4dce09dbaa179e">souffle::FunctorOp::NEG</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2a982dd15c24b8dde9e7a5ac00b5b30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a982dd15c24b8dde9e7a5ac00b5b30f">&#9670;&nbsp;</a></span>InterpreterNodeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30f">souffle::InterpreterNodeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa427709f25dfaec2407c10c9acfb29fc1"></a>I_Constant&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fac92994264e0a187b6defbf6f364da782"></a>I_TupleElement&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa18ddb6d3d81cb16a6c3489b37e5ee167"></a>I_AutoIncrement&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa019c55f9affc926925c4c36910049fb2"></a>I_IntrinsicOperator&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fad61d7a9c5957b7f79e795384ba68e123"></a>I_UserDefinedOperator&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa05d6d1a89ac8c1d89b8ff21e30d49e7b"></a>I_PackRecord&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fae81168f8a3ef22c641dc84dac0d720a9"></a>I_SubroutineArgument&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa44dac3d2b3026a02d7277cdffd46f11d"></a>I_True&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa21b15245b84482da42ffb795c5a4b5c8"></a>I_False&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa2688791f9d813a0d0c699f4bacc95f43"></a>I_Conjunction&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa4ba0eed2143398a27afdde13d2837bc0"></a>I_Negation&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa427cb5b0ad39f494e2056de4e95f0644"></a>I_EmptinessCheck&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fabe804a8e5d5c1cdfb6eba142561d69b3"></a>I_ExistenceCheck&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30faee48292648ec90d6eb37bbd383c7a563"></a>I_ProvenanceExistenceCheck&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa9005af466e695943d45ba34b31c9bf12"></a>I_Constraint&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa66599d3d6e8e19465056b381eb0105c4"></a>I_TupleOperation&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa876c07f2b24b9ab223b4565ae093124d"></a>I_Scan&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fae636d7e8327c812ef8172c3eb3e89657"></a>I_ParallelScan&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa23eced32caa666668f20e6e0343ab437"></a>I_IndexScan&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa1867a6e2452da99f86c42ebd87eeaf42"></a>I_ParallelIndexScan&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa88751c991b488d81696a70a293fd9711"></a>I_Choice&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa65b0b98e373aec0bd7edb4bfd2e8fb8e"></a>I_ParallelChoice&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fae6b9cd4ad39504b9885812f58c4700b3"></a>I_IndexChoice&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa5fceaa961a0c162fffe84264363cf869"></a>I_ParallelIndexChoice&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30faa1abe444b1239d86342ac4e124115c42"></a>I_UnpackRecord&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30faf33b6910e7880fbe58d36a1f45ac7b0d"></a>I_Aggregate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30faea369dd742cd6fa7a1200f674a5e45c2"></a>I_IndexAggregate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa1a02359e5055f1a1d410c29f864f86a1"></a>I_Break&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa4bcb0f1476b4b863444d05bacae113e6"></a>I_Filter&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fada3099d1691d5164c3588bf09dc9fd58"></a>I_Project&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa93a488c1abddd355249a81a2cb5deee3"></a>I_SubroutineReturnValue&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa156c90460962f8fee52d3601e0bd3fd4"></a>I_Sequence&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fac15228c7d4078e04d726338accd45b72"></a>I_Parallel&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa46c56fc81947741623f054fcf82ed40c"></a>I_Loop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fac9c0ab0f1f28d6e133218d9b42a24880"></a>I_Exit&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30faa1e98030617e3521637f68f67c13dc90"></a>I_LogRelationTimer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa0ffa990468b1fb6b3115d71dd2c3cf4c"></a>I_LogTimer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa4ab85e660bda5d95a2cbafb72cd63376"></a>I_DebugInfo&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fadc64bb855d60d3bac55d2ca021a179e4"></a>I_Clear&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fad7b2c34b2a01495041e9a1c51c22fdb7"></a>I_LogSize&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa0cb26ea1213a532241245a45d45a7c50"></a>I_IO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa3941b34b02226e95f067b9d71fc3d90e"></a>I_Query&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa44906683c26840580ed237141e02f9e4"></a>I_Extend&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a982dd15c24b8dde9e7a5ac00b5b30fa4d2247a5773c7fa7d1bde10982877ec2"></a>I_Swap&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_interpreter_node_8h_source.html#l00032">32</a> of file <a class="el" href="_interpreter_node_8h_source.html">InterpreterNode.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                         {</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa427709f25dfaec2407c10c9acfb29fc1">I_Constant</a>,</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fac92994264e0a187b6defbf6f364da782">I_TupleElement</a>,</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa18ddb6d3d81cb16a6c3489b37e5ee167">I_AutoIncrement</a>,</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa019c55f9affc926925c4c36910049fb2">I_IntrinsicOperator</a>,</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fad61d7a9c5957b7f79e795384ba68e123">I_UserDefinedOperator</a>,</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa05d6d1a89ac8c1d89b8ff21e30d49e7b">I_PackRecord</a>,</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fae81168f8a3ef22c641dc84dac0d720a9">I_SubroutineArgument</a>,</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa44dac3d2b3026a02d7277cdffd46f11d">I_True</a>,</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa21b15245b84482da42ffb795c5a4b5c8">I_False</a>,</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa2688791f9d813a0d0c699f4bacc95f43">I_Conjunction</a>,</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa4ba0eed2143398a27afdde13d2837bc0">I_Negation</a>,</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa427cb5b0ad39f494e2056de4e95f0644">I_EmptinessCheck</a>,</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fabe804a8e5d5c1cdfb6eba142561d69b3">I_ExistenceCheck</a>,</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30faee48292648ec90d6eb37bbd383c7a563">I_ProvenanceExistenceCheck</a>,</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa9005af466e695943d45ba34b31c9bf12">I_Constraint</a>,</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa66599d3d6e8e19465056b381eb0105c4">I_TupleOperation</a>,</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa876c07f2b24b9ab223b4565ae093124d">I_Scan</a>,</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fae636d7e8327c812ef8172c3eb3e89657">I_ParallelScan</a>,</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa23eced32caa666668f20e6e0343ab437">I_IndexScan</a>,</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa1867a6e2452da99f86c42ebd87eeaf42">I_ParallelIndexScan</a>,</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa88751c991b488d81696a70a293fd9711">I_Choice</a>,</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa65b0b98e373aec0bd7edb4bfd2e8fb8e">I_ParallelChoice</a>,</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fae6b9cd4ad39504b9885812f58c4700b3">I_IndexChoice</a>,</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa5fceaa961a0c162fffe84264363cf869">I_ParallelIndexChoice</a>,</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30faa1abe444b1239d86342ac4e124115c42">I_UnpackRecord</a>,</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30faf33b6910e7880fbe58d36a1f45ac7b0d">I_Aggregate</a>,</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30faea369dd742cd6fa7a1200f674a5e45c2">I_IndexAggregate</a>,</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa1a02359e5055f1a1d410c29f864f86a1">I_Break</a>,</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa4bcb0f1476b4b863444d05bacae113e6">I_Filter</a>,</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fada3099d1691d5164c3588bf09dc9fd58">I_Project</a>,</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa93a488c1abddd355249a81a2cb5deee3">I_SubroutineReturnValue</a>,</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa156c90460962f8fee52d3601e0bd3fd4">I_Sequence</a>,</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fac15228c7d4078e04d726338accd45b72">I_Parallel</a>,</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa46c56fc81947741623f054fcf82ed40c">I_Loop</a>,</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fac9c0ab0f1f28d6e133218d9b42a24880">I_Exit</a>,</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30faa1e98030617e3521637f68f67c13dc90">I_LogRelationTimer</a>,</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa0ffa990468b1fb6b3115d71dd2c3cf4c">I_LogTimer</a>,</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa4ab85e660bda5d95a2cbafb72cd63376">I_DebugInfo</a>,</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fadc64bb855d60d3bac55d2ca021a179e4">I_Clear</a>,</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fad7b2c34b2a01495041e9a1c51c22fdb7">I_LogSize</a>,</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa0cb26ea1213a532241245a45d45a7c50">I_IO</a>,</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa3941b34b02226e95f067b9d71fc3d90e">I_Query</a>,</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa44906683c26840580ed237141e02f9e4">I_Extend</a>,</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <a class="code" href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa4d2247a5773c7fa7d1bde10982877ec2">I_Swap</a>,</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;};</div><div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa1a02359e5055f1a1d410c29f864f86a1"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa1a02359e5055f1a1d410c29f864f86a1">souffle::I_Break</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00060">InterpreterNode.h:60</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa156c90460962f8fee52d3601e0bd3fd4"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa156c90460962f8fee52d3601e0bd3fd4">souffle::I_Sequence</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00064">InterpreterNode.h:64</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa88751c991b488d81696a70a293fd9711"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa88751c991b488d81696a70a293fd9711">souffle::I_Choice</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00053">InterpreterNode.h:53</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa44906683c26840580ed237141e02f9e4"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa44906683c26840580ed237141e02f9e4">souffle::I_Extend</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00075">InterpreterNode.h:75</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30faea369dd742cd6fa7a1200f674a5e45c2"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30faea369dd742cd6fa7a1200f674a5e45c2">souffle::I_IndexAggregate</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00059">InterpreterNode.h:59</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa019c55f9affc926925c4c36910049fb2"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa019c55f9affc926925c4c36910049fb2">souffle::I_IntrinsicOperator</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00036">InterpreterNode.h:36</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fada3099d1691d5164c3588bf09dc9fd58"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fada3099d1691d5164c3588bf09dc9fd58">souffle::I_Project</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00062">InterpreterNode.h:62</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fac9c0ab0f1f28d6e133218d9b42a24880"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fac9c0ab0f1f28d6e133218d9b42a24880">souffle::I_Exit</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00067">InterpreterNode.h:67</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa427709f25dfaec2407c10c9acfb29fc1"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa427709f25dfaec2407c10c9acfb29fc1">souffle::I_Constant</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00033">InterpreterNode.h:33</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fac15228c7d4078e04d726338accd45b72"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fac15228c7d4078e04d726338accd45b72">souffle::I_Parallel</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00065">InterpreterNode.h:65</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa2688791f9d813a0d0c699f4bacc95f43"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa2688791f9d813a0d0c699f4bacc95f43">souffle::I_Conjunction</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00042">InterpreterNode.h:42</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa4ab85e660bda5d95a2cbafb72cd63376"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa4ab85e660bda5d95a2cbafb72cd63376">souffle::I_DebugInfo</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00070">InterpreterNode.h:70</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa4ba0eed2143398a27afdde13d2837bc0"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa4ba0eed2143398a27afdde13d2837bc0">souffle::I_Negation</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00043">InterpreterNode.h:43</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fae636d7e8327c812ef8172c3eb3e89657"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fae636d7e8327c812ef8172c3eb3e89657">souffle::I_ParallelScan</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00050">InterpreterNode.h:50</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa05d6d1a89ac8c1d89b8ff21e30d49e7b"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa05d6d1a89ac8c1d89b8ff21e30d49e7b">souffle::I_PackRecord</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00038">InterpreterNode.h:38</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fad61d7a9c5957b7f79e795384ba68e123"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fad61d7a9c5957b7f79e795384ba68e123">souffle::I_UserDefinedOperator</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00037">InterpreterNode.h:37</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa1867a6e2452da99f86c42ebd87eeaf42"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa1867a6e2452da99f86c42ebd87eeaf42">souffle::I_ParallelIndexScan</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00052">InterpreterNode.h:52</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa5fceaa961a0c162fffe84264363cf869"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa5fceaa961a0c162fffe84264363cf869">souffle::I_ParallelIndexChoice</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00056">InterpreterNode.h:56</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fabe804a8e5d5c1cdfb6eba142561d69b3"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fabe804a8e5d5c1cdfb6eba142561d69b3">souffle::I_ExistenceCheck</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00045">InterpreterNode.h:45</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa93a488c1abddd355249a81a2cb5deee3"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa93a488c1abddd355249a81a2cb5deee3">souffle::I_SubroutineReturnValue</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00063">InterpreterNode.h:63</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30faa1e98030617e3521637f68f67c13dc90"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30faa1e98030617e3521637f68f67c13dc90">souffle::I_LogRelationTimer</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00068">InterpreterNode.h:68</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa65b0b98e373aec0bd7edb4bfd2e8fb8e"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa65b0b98e373aec0bd7edb4bfd2e8fb8e">souffle::I_ParallelChoice</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00054">InterpreterNode.h:54</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fac92994264e0a187b6defbf6f364da782"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fac92994264e0a187b6defbf6f364da782">souffle::I_TupleElement</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00034">InterpreterNode.h:34</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa427cb5b0ad39f494e2056de4e95f0644"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa427cb5b0ad39f494e2056de4e95f0644">souffle::I_EmptinessCheck</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00044">InterpreterNode.h:44</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa876c07f2b24b9ab223b4565ae093124d"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa876c07f2b24b9ab223b4565ae093124d">souffle::I_Scan</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00049">InterpreterNode.h:49</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa23eced32caa666668f20e6e0343ab437"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa23eced32caa666668f20e6e0343ab437">souffle::I_IndexScan</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00051">InterpreterNode.h:51</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa0ffa990468b1fb6b3115d71dd2c3cf4c"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa0ffa990468b1fb6b3115d71dd2c3cf4c">souffle::I_LogTimer</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00069">InterpreterNode.h:69</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa21b15245b84482da42ffb795c5a4b5c8"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa21b15245b84482da42ffb795c5a4b5c8">souffle::I_False</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00041">InterpreterNode.h:41</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30faa1abe444b1239d86342ac4e124115c42"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30faa1abe444b1239d86342ac4e124115c42">souffle::I_UnpackRecord</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00057">InterpreterNode.h:57</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30faf33b6910e7880fbe58d36a1f45ac7b0d"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30faf33b6910e7880fbe58d36a1f45ac7b0d">souffle::I_Aggregate</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00058">InterpreterNode.h:58</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa4bcb0f1476b4b863444d05bacae113e6"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa4bcb0f1476b4b863444d05bacae113e6">souffle::I_Filter</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00061">InterpreterNode.h:61</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30faee48292648ec90d6eb37bbd383c7a563"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30faee48292648ec90d6eb37bbd383c7a563">souffle::I_ProvenanceExistenceCheck</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00046">InterpreterNode.h:46</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa66599d3d6e8e19465056b381eb0105c4"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa66599d3d6e8e19465056b381eb0105c4">souffle::I_TupleOperation</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00048">InterpreterNode.h:48</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa18ddb6d3d81cb16a6c3489b37e5ee167"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa18ddb6d3d81cb16a6c3489b37e5ee167">souffle::I_AutoIncrement</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00035">InterpreterNode.h:35</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fadc64bb855d60d3bac55d2ca021a179e4"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fadc64bb855d60d3bac55d2ca021a179e4">souffle::I_Clear</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00071">InterpreterNode.h:71</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa4d2247a5773c7fa7d1bde10982877ec2"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa4d2247a5773c7fa7d1bde10982877ec2">souffle::I_Swap</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00076">InterpreterNode.h:76</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fae81168f8a3ef22c641dc84dac0d720a9"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fae81168f8a3ef22c641dc84dac0d720a9">souffle::I_SubroutineArgument</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00039">InterpreterNode.h:39</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fad7b2c34b2a01495041e9a1c51c22fdb7"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fad7b2c34b2a01495041e9a1c51c22fdb7">souffle::I_LogSize</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00072">InterpreterNode.h:72</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa0cb26ea1213a532241245a45d45a7c50"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa0cb26ea1213a532241245a45d45a7c50">souffle::I_IO</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00073">InterpreterNode.h:73</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa3941b34b02226e95f067b9d71fc3d90e"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa3941b34b02226e95f067b9d71fc3d90e">souffle::I_Query</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00074">InterpreterNode.h:74</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa46c56fc81947741623f054fcf82ed40c"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa46c56fc81947741623f054fcf82ed40c">souffle::I_Loop</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00066">InterpreterNode.h:66</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa9005af466e695943d45ba34b31c9bf12"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa9005af466e695943d45ba34b31c9bf12">souffle::I_Constraint</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00047">InterpreterNode.h:47</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fa44dac3d2b3026a02d7277cdffd46f11d"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fa44dac3d2b3026a02d7277cdffd46f11d">souffle::I_True</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00040">InterpreterNode.h:40</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2a982dd15c24b8dde9e7a5ac00b5b30fae6b9cd4ad39504b9885812f58c4700b3"><div class="ttname"><a href="namespacesouffle.html#a2a982dd15c24b8dde9e7a5ac00b5b30fae6b9cd4ad39504b9885812f58c4700b3">souffle::I_IndexChoice</a></div><div class="ttdef"><b>Definition:</b> <a href="_interpreter_node_8h_source.html#l00055">InterpreterNode.h:55</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4d1111156440d898474b3cd9cd43a276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1111156440d898474b3cd9cd43a276">&#9670;&nbsp;</a></span>RelationQualifier</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesouffle.html#a4d1111156440d898474b3cd9cd43a276">souffle::RelationQualifier</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Space of qualifiers that a relation can have. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4d1111156440d898474b3cd9cd43a276aa84cc046d48610b05c21fd3670d0c829"></a>INPUT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d1111156440d898474b3cd9cd43a276a50a87f0d71f7221582dad4bf507a0f34"></a>OUTPUT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d1111156440d898474b3cd9cd43a276a412e14f57c2f0eeb02d2475ca63bf38c"></a>PRINTSIZE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d1111156440d898474b3cd9cd43a276ac9572efed22489a0eb4ab9dcd8132d4b"></a>OVERRIDABLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d1111156440d898474b3cd9cd43a276acfbac07c6ae3e73f0e10ca60ad916bef"></a>INLINE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d1111156440d898474b3cd9cd43a276a749f7196d531a918508ddc75af68469d"></a>SUPPRESSED&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_relation_tag_8h_source.html#l00035">35</a> of file <a class="el" href="_relation_tag_8h_source.html">RelationTag.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;                             {</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529faa84cc046d48610b05c21fd3670d0c829">INPUT</a>,        <span class="comment">// relation read from csv</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa50a87f0d71f7221582dad4bf507a0f34">OUTPUT</a>,       <span class="comment">// relation written to csv</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa412e14f57c2f0eeb02d2475ca63bf38c">PRINTSIZE</a>,    <span class="comment">// number of tuples written to stdout</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fac9572efed22489a0eb4ab9dcd8132d4b">OVERRIDABLE</a>,  <span class="comment">// rules defined in component can be overwritten by sub-component</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">INLINE</a>,       <span class="comment">// inlined</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa749f7196d531a918508ddc75af68469d">SUPPRESSED</a>,   <span class="comment">// warnings suppressed</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;};</div><div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529fa50a87f0d71f7221582dad4bf507a0f34"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa50a87f0d71f7221582dad4bf507a0f34">souffle::RelationTag::OUTPUT</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529fa749f7196d531a918508ddc75af68469d"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa749f7196d531a918508ddc75af68469d">souffle::RelationTag::SUPPRESSED</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">souffle::RelationTag::INLINE</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529fac9572efed22489a0eb4ab9dcd8132d4b"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fac9572efed22489a0eb4ab9dcd8132d4b">souffle::RelationTag::OVERRIDABLE</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529faa84cc046d48610b05c21fd3670d0c829"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529faa84cc046d48610b05c21fd3670d0c829">souffle::RelationTag::INPUT</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529fa412e14f57c2f0eeb02d2475ca63bf38c"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa412e14f57c2f0eeb02d2475ca63bf38c">souffle::RelationTag::PRINTSIZE</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6309f0948137356de74c7d16ffbf2d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6309f0948137356de74c7d16ffbf2d9e">&#9670;&nbsp;</a></span>RelationRepresentation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9e">souffle::RelationRepresentation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Space of internal representations that a relation can have. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6309f0948137356de74c7d16ffbf2d9ea5b39c8b553c821e7cddc6da64b5bd2ee"></a>DEFAULT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6309f0948137356de74c7d16ffbf2d9eade0f2c62e46b76fe07b1033a2af15a28"></a>BRIE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6309f0948137356de74c7d16ffbf2d9ea26daa90bc6e4e7baf2b5781caef22940"></a>BTREE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6309f0948137356de74c7d16ffbf2d9ea06a35dca93aeafc1b0f548410517223a"></a>EQREL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6309f0948137356de74c7d16ffbf2d9ea551b723eafd6a31d444fcb2f5920fbd3"></a>INFO&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_relation_tag_8h_source.html#l00045">45</a> of file <a class="el" href="_relation_tag_8h_source.html">RelationTag.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                                  {</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <a class="code" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9ea5b39c8b553c821e7cddc6da64b5bd2ee">DEFAULT</a>,  <span class="comment">// use default data-structure</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fade0f2c62e46b76fe07b1033a2af15a28">BRIE</a>,     <span class="comment">// use brie data-structure</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa26daa90bc6e4e7baf2b5781caef22940">BTREE</a>,    <span class="comment">// use btree data-structure</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa06a35dca93aeafc1b0f548410517223a">EQREL</a>,    <span class="comment">// use union data-structure</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <a class="code" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9ea551b723eafd6a31d444fcb2f5920fbd3">INFO</a>,     <span class="comment">// info relation for provenance</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;};</div><div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529fade0f2c62e46b76fe07b1033a2af15a28"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fade0f2c62e46b76fe07b1033a2af15a28">souffle::RelationTag::BRIE</a></div></div>
<div class="ttc" id="namespacesouffle_html_a6309f0948137356de74c7d16ffbf2d9ea551b723eafd6a31d444fcb2f5920fbd3"><div class="ttname"><a href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9ea551b723eafd6a31d444fcb2f5920fbd3">souffle::RelationRepresentation::INFO</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529fa06a35dca93aeafc1b0f548410517223a"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa06a35dca93aeafc1b0f548410517223a">souffle::RelationTag::EQREL</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529fa26daa90bc6e4e7baf2b5781caef22940"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa26daa90bc6e4e7baf2b5781caef22940">souffle::RelationTag::BTREE</a></div></div>
<div class="ttc" id="namespacesouffle_html_a6309f0948137356de74c7d16ffbf2d9ea5b39c8b553c821e7cddc6da64b5bd2ee"><div class="ttname"><a href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9ea5b39c8b553c821e7cddc6da64b5bd2ee">souffle::RelationRepresentation::DEFAULT</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8d04bccb8804e1ace183494574e4529f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d04bccb8804e1ace183494574e4529f">&#9670;&nbsp;</a></span>RelationTag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529f">souffle::RelationTag</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Space of user-chosen tags that a relation can have. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8d04bccb8804e1ace183494574e4529faa84cc046d48610b05c21fd3670d0c829"></a>INPUT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8d04bccb8804e1ace183494574e4529fa50a87f0d71f7221582dad4bf507a0f34"></a>OUTPUT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8d04bccb8804e1ace183494574e4529fa412e14f57c2f0eeb02d2475ca63bf38c"></a>PRINTSIZE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8d04bccb8804e1ace183494574e4529fac9572efed22489a0eb4ab9dcd8132d4b"></a>OVERRIDABLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef"></a>INLINE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8d04bccb8804e1ace183494574e4529fa749f7196d531a918508ddc75af68469d"></a>SUPPRESSED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8d04bccb8804e1ace183494574e4529fade0f2c62e46b76fe07b1033a2af15a28"></a>BRIE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8d04bccb8804e1ace183494574e4529fa26daa90bc6e4e7baf2b5781caef22940"></a>BTREE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8d04bccb8804e1ace183494574e4529fa06a35dca93aeafc1b0f548410517223a"></a>EQREL&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_relation_tag_8h_source.html#l00022">22</a> of file <a class="el" href="_relation_tag_8h_source.html">RelationTag.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;                       {</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529faa84cc046d48610b05c21fd3670d0c829">INPUT</a>,        <span class="comment">// relation read from csv</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa50a87f0d71f7221582dad4bf507a0f34">OUTPUT</a>,       <span class="comment">// relation written to csv</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa412e14f57c2f0eeb02d2475ca63bf38c">PRINTSIZE</a>,    <span class="comment">// number of tuples written to stdout</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fac9572efed22489a0eb4ab9dcd8132d4b">OVERRIDABLE</a>,  <span class="comment">// rules defined in component can be overwritten by sub-component</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">INLINE</a>,       <span class="comment">// inlined</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa749f7196d531a918508ddc75af68469d">SUPPRESSED</a>,   <span class="comment">// warnings suppressed</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fade0f2c62e46b76fe07b1033a2af15a28">BRIE</a>,         <span class="comment">// use brie data-structure</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa26daa90bc6e4e7baf2b5781caef22940">BTREE</a>,        <span class="comment">// use btree data-structure</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa06a35dca93aeafc1b0f548410517223a">EQREL</a>,        <span class="comment">// use union data-structure</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;};</div><div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529fa50a87f0d71f7221582dad4bf507a0f34"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa50a87f0d71f7221582dad4bf507a0f34">souffle::RelationTag::OUTPUT</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529fa749f7196d531a918508ddc75af68469d"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa749f7196d531a918508ddc75af68469d">souffle::RelationTag::SUPPRESSED</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529fade0f2c62e46b76fe07b1033a2af15a28"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fade0f2c62e46b76fe07b1033a2af15a28">souffle::RelationTag::BRIE</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">souffle::RelationTag::INLINE</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529fa06a35dca93aeafc1b0f548410517223a"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa06a35dca93aeafc1b0f548410517223a">souffle::RelationTag::EQREL</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529fac9572efed22489a0eb4ab9dcd8132d4b"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fac9572efed22489a0eb4ab9dcd8132d4b">souffle::RelationTag::OVERRIDABLE</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529fa26daa90bc6e4e7baf2b5781caef22940"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa26daa90bc6e4e7baf2b5781caef22940">souffle::RelationTag::BTREE</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529faa84cc046d48610b05c21fd3670d0c829"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529faa84cc046d48610b05c21fd3670d0c829">souffle::RelationTag::INPUT</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8d04bccb8804e1ace183494574e4529fa412e14f57c2f0eeb02d2475ca63bf38c"><div class="ttname"><a href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa412e14f57c2f0eeb02d2475ca63bf38c">souffle::RelationTag::PRINTSIZE</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af5361aa1e84030b37d7c8df1bf45e1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5361aa1e84030b37d7c8df1bf45e1c0">&#9670;&nbsp;</a></span>TypeAttribute</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">souffle::TypeAttribute</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af5361aa1e84030b37d7c8df1bf45e1c0a02c86eb2792f3262c21d030a87e19793"></a>Symbol&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379"></a>Signed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af5361aa1e84030b37d7c8df1bf45e1c0aa1a914735b205424ba6c40b85528d78a"></a>Unsigned&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af5361aa1e84030b37d7c8df1bf45e1c0a22ae0e2b89e5e3d477f988cc36d3272b"></a>Float&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af5361aa1e84030b37d7c8df1bf45e1c0a6a0d9eaee314c567fd72fb97ee707a36"></a>Record&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_ram_types_8h_source.html#l00028">28</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;                         {</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <a class="code" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a02c86eb2792f3262c21d030a87e19793">Symbol</a>,</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <a class="code" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379">Signed</a>,    <span class="comment">// Signed number</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0aa1a914735b205424ba6c40b85528d78a">Unsigned</a>,  <span class="comment">// Unsigned number</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <a class="code" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a22ae0e2b89e5e3d477f988cc36d3272b">Float</a>,     <span class="comment">// Floating point number.</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <a class="code" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a6a0d9eaee314c567fd72fb97ee707a36">Record</a>,</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;};</div><div class="ttc" id="namespacesouffle_html_af5361aa1e84030b37d7c8df1bf45e1c0a6a0d9eaee314c567fd72fb97ee707a36"><div class="ttname"><a href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a6a0d9eaee314c567fd72fb97ee707a36">souffle::TypeAttribute::Record</a></div></div>
<div class="ttc" id="namespacesouffle_html_af5361aa1e84030b37d7c8df1bf45e1c0aa1a914735b205424ba6c40b85528d78a"><div class="ttname"><a href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0aa1a914735b205424ba6c40b85528d78a">souffle::TypeAttribute::Unsigned</a></div></div>
<div class="ttc" id="namespacesouffle_html_af5361aa1e84030b37d7c8df1bf45e1c0a02c86eb2792f3262c21d030a87e19793"><div class="ttname"><a href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a02c86eb2792f3262c21d030a87e19793">souffle::TypeAttribute::Symbol</a></div></div>
<div class="ttc" id="namespacesouffle_html_af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379"><div class="ttname"><a href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379">souffle::TypeAttribute::Signed</a></div></div>
<div class="ttc" id="namespacesouffle_html_af5361aa1e84030b37d7c8df1bf45e1c0a22ae0e2b89e5e3d477f988cc36d3272b"><div class="ttname"><a href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a22ae0e2b89e5e3d477f988cc36d3272b">souffle::TypeAttribute::Float</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8a2c294e3ff514cd4ca29b466ff3cab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2c294e3ff514cd4ca29b466ff3cab3">&#9670;&nbsp;</a></span>absPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::absPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++-style realpath. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01139">1139</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;                                                {</div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;    <span class="keywordtype">char</span> buf[PATH_MAX];</div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;    <span class="keywordtype">char</span>* res = realpath(path.c_str(), buf);</div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;    <span class="keywordflow">return</span> (res == <span class="keyword">nullptr</span>) ? <span class="stringliteral">&quot;&quot;</span> : std::string(buf);</div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ad121faea3dab6bbecd66db7757b89e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad121faea3dab6bbecd66db7757b89e5d">&#9670;&nbsp;</a></span>addAggregators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a>&gt; souffle::addAggregators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt;&#160;</td>
          <td class="paramname"><em>ignoredNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00285">285</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_literal_8h_source.html#l00058">souffle::AstAtom::getQualifiedName()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00695">souffle::Adornment::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                                                                                                  {</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    std::set&lt;AstQualifiedName&gt; retVal = std::move(ignoredNames);</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(*clause, [&amp;](<span class="keyword">const</span> AstAggregator&amp; aggregator) {</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(aggregator, [&amp;](<span class="keyword">const</span> AstAtom&amp; atom) { retVal.insert(atom.getQualifiedName()); });</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    });</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    <span class="keywordflow">return</span> retVal;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ad121faea3dab6bbecd66db7757b89e5d_cgraph.png" border="0" usemap="#namespacesouffle_ad121faea3dab6bbecd66db7757b89e5d_cgraph" alt=""/></div>
<map name="namespacesouffle_ad121faea3dab6bbecd66db7757b89e5d_cgraph" id="namespacesouffle_ad121faea3dab6bbecd66db7757b89e5d_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="231,5,487,32"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="275,56,443,83"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="535,49,703,90"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="751,49,941,90"/>
</map>
</div>

</div>
</div>
<a id="a1ef96dcee06ebf23b793c3fd5a9fe111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef96dcee06ebf23b793c3fd5a9fe111">&#9670;&nbsp;</a></span>addBackwardDependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a>&gt; souffle::addBackwardDependencies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt;&#160;</td>
          <td class="paramname"><em>relations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00297">297</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_magic_set_8cpp_source.html#l00046">contains()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00042">getClauses()</a>, <a class="el" href="_ast_literal_8h_source.html#l00058">souffle::AstAtom::getQualifiedName()</a>, <a class="el" href="_ast_program_8h_source.html#l00057">souffle::AstProgram::getRelations()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00370">addIgnoredRelations()</a>.</p>
<div class="fragment"><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                                                                       {</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    <span class="keywordtype">bool</span> relationsAdded = <span class="keyword">false</span>;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    std::set&lt;AstQualifiedName&gt; result;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    <span class="keywordflow">for</span> (AstQualifiedName relName : <a class="code" href="_component_instantiation_transformer_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a>) {</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        <span class="comment">// Add the relation itself</span></div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        result.insert(relName);</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    }</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    <span class="comment">// Add in all relations that need to use an ignored relation</span></div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    <span class="keywordflow">for</span> (AstRelation* rel : program-&gt;getRelations()) {</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        <span class="keywordflow">for</span> (AstClause* clause : <a class="code" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">getClauses</a>(*program, *rel)) {</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            AstQualifiedName clauseHeadName = clause-&gt;getHead()-&gt;getQualifiedName();</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;            <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">contains</a>(relations, clauseHeadName)) {</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                <span class="comment">// Clause hasn&#39;t been added yet, so check if it needs to be added</span></div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(*clause, [&amp;](<span class="keyword">const</span> AstAtom&amp; subatom) {</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                    AstQualifiedName atomName = subatom.getQualifiedName();</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">contains</a>(relations, atomName)) {</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;                        <span class="comment">// Clause uses one of the given relations</span></div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                        result.insert(clauseHeadName);</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                        <span class="comment">// Clause name hasn&#39;t been seen yet, so fixed point not reached</span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;                        relationsAdded = <span class="keyword">true</span>;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                    }</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                });</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;            }</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        }</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    }</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    <span class="keywordflow">if</span> (relationsAdded) {</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        <span class="comment">// Keep going until we reach a fixed point</span></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a1ef96dcee06ebf23b793c3fd5a9fe111">addBackwardDependencies</a>(program, result);</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;        <span class="keywordflow">return</span> result;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    }</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a8a825f62e860ca448e7e16ab1a3a4333"><div class="ttname"><a href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">souffle::contains</a></div><div class="ttdeci">bool contains(std::set&lt; AdornedPredicate &gt; adornedPredicates, const AstQualifiedName &amp;atomName, const std::string &amp;atomAdornment)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00046">MagicSet.cpp:46</a></div></div>
<div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
<div class="ttc" id="_component_instantiation_transformer_8cpp_html_a9141804302982067ed0a048c2336105a"><div class="ttname"><a href="_component_instantiation_transformer_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a></div><div class="ttdeci">std::vector&lt; std::unique_ptr&lt; AstRelation &gt; &gt; relations</div><div class="ttdef"><b>Definition:</b> <a href="_component_instantiation_transformer_8cpp_source.html#l00047">ComponentInstantiationTransformer.cpp:47</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4d9e53888640a9abfd7ea7c43715152a"><div class="ttname"><a href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">souffle::getClauses</a></div><div class="ttdeci">std::vector&lt; AstClause * &gt; getClauses(const AstProgram &amp;program, const AstQualifiedName &amp;relationName)</div><div class="ttdoc">Returns a vector of clauses in the program describing the relation with the given name...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00042">AstUtils.cpp:42</a></div></div>
<div class="ttc" id="namespacesouffle_html_a1ef96dcee06ebf23b793c3fd5a9fe111"><div class="ttname"><a href="namespacesouffle.html#a1ef96dcee06ebf23b793c3fd5a9fe111">souffle::addBackwardDependencies</a></div><div class="ttdeci">std::set&lt; AstQualifiedName &gt; addBackwardDependencies(const AstProgram *program, std::set&lt; AstQualifiedName &gt; relations)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00297">MagicSet.cpp:297</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a1ef96dcee06ebf23b793c3fd5a9fe111_cgraph.png" border="0" usemap="#namespacesouffle_a1ef96dcee06ebf23b793c3fd5a9fe111_cgraph" alt=""/></div>
<map name="namespacesouffle_a1ef96dcee06ebf23b793c3fd5a9fe111_cgraph" id="namespacesouffle_a1ef96dcee06ebf23b793c3fd5a9fe111_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333" title="souffle::contains" alt="" coords="371,5,501,32"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="363,56,509,83"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="308,107,564,133"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="633,131,784,173"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="352,208,520,235"/>
<area shape="rect" id="node3" href="namespacesouffle.html#aae135d2382a133fa5b036296fbd7f60a" title="souffle::isEqualAdornment" alt="" coords="612,5,805,32"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="633,59,784,101"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="875,103,1022,129"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="625,201,793,242"/>
<area shape="rect" id="node11" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="853,201,1044,242"/>
</map>
</div>

</div>
</div>
<a id="a54eec417845f7cc5e1b5a47a3dbcf599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54eec417845f7cc5e1b5a47a3dbcf599">&#9670;&nbsp;</a></span>addForwardDependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a>&gt; souffle::addForwardDependencies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt;&#160;</td>
          <td class="paramname"><em>relations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00337">337</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_magic_set_8cpp_source.html#l00046">contains()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00042">getClauses()</a>, <a class="el" href="_ast_literal_8h_source.html#l00058">souffle::AstAtom::getQualifiedName()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00056">getRelation()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00695">souffle::Adornment::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                                                                       {</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    <span class="keywordtype">bool</span> relationsAdded = <span class="keyword">false</span>;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    std::set&lt;AstQualifiedName&gt; result;</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    <span class="keywordflow">for</span> (AstQualifiedName relName : <a class="code" href="_component_instantiation_transformer_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a>) {</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        <span class="comment">// Add the relation itself</span></div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        result.insert(relName);</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        <span class="comment">// Add in all the relations that it needs to use</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        AstRelation* associatedRelation = <a class="code" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">getRelation</a>(*program, relName);</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        <span class="keywordflow">for</span> (AstClause* clause : <a class="code" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">getClauses</a>(*program, *associatedRelation)) {</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;            <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(*clause, [&amp;](<span class="keyword">const</span> AstAtom&amp; subatom) {</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;                AstQualifiedName atomName = subatom.getQualifiedName();</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                result.insert(atomName);</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">contains</a>(relations, atomName)) {</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                    <span class="comment">// Hasn&#39;t been seen yet, so fixed point not reached</span></div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;                    relationsAdded = <span class="keyword">true</span>;</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                }</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;            });</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;        }</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    }</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="keywordflow">if</span> (relationsAdded) {</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;        <span class="comment">// Keep going until we reach a fixed point</span></div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a54eec417845f7cc5e1b5a47a3dbcf599">addForwardDependencies</a>(program, result);</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        <span class="keywordflow">return</span> result;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    }</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a8a825f62e860ca448e7e16ab1a3a4333"><div class="ttname"><a href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">souffle::contains</a></div><div class="ttdeci">bool contains(std::set&lt; AdornedPredicate &gt; adornedPredicates, const AstQualifiedName &amp;atomName, const std::string &amp;atomAdornment)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00046">MagicSet.cpp:46</a></div></div>
<div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
<div class="ttc" id="namespacesouffle_html_ada252aa15afbf7d703a11b000dfd4048"><div class="ttname"><a href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">souffle::getRelation</a></div><div class="ttdeci">AstRelation * getRelation(const AstProgram &amp;program, const AstQualifiedName &amp;name)</div><div class="ttdoc">Returns the relation with the given name in the program. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00056">AstUtils.cpp:56</a></div></div>
<div class="ttc" id="_component_instantiation_transformer_8cpp_html_a9141804302982067ed0a048c2336105a"><div class="ttname"><a href="_component_instantiation_transformer_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a></div><div class="ttdeci">std::vector&lt; std::unique_ptr&lt; AstRelation &gt; &gt; relations</div><div class="ttdef"><b>Definition:</b> <a href="_component_instantiation_transformer_8cpp_source.html#l00047">ComponentInstantiationTransformer.cpp:47</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4d9e53888640a9abfd7ea7c43715152a"><div class="ttname"><a href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">souffle::getClauses</a></div><div class="ttdeci">std::vector&lt; AstClause * &gt; getClauses(const AstProgram &amp;program, const AstQualifiedName &amp;relationName)</div><div class="ttdoc">Returns a vector of clauses in the program describing the relation with the given name...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00042">AstUtils.cpp:42</a></div></div>
<div class="ttc" id="namespacesouffle_html_a54eec417845f7cc5e1b5a47a3dbcf599"><div class="ttname"><a href="namespacesouffle.html#a54eec417845f7cc5e1b5a47a3dbcf599">souffle::addForwardDependencies</a></div><div class="ttdeci">std::set&lt; AstQualifiedName &gt; addForwardDependencies(const AstProgram *program, std::set&lt; AstQualifiedName &gt; relations)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00337">MagicSet.cpp:337</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a54eec417845f7cc5e1b5a47a3dbcf599_cgraph.png" border="0" usemap="#namespacesouffle_a54eec417845f7cc5e1b5a47a3dbcf599_cgraph" alt=""/></div>
<map name="namespacesouffle_a54eec417845f7cc5e1b5a47a3dbcf599_cgraph" id="namespacesouffle_a54eec417845f7cc5e1b5a47a3dbcf599_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333" title="souffle::contains" alt="" coords="359,9,489,36"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="351,64,497,91"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="296,115,552,141"/>
<area shape="rect" id="node8" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="350,165,498,192"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="340,231,508,257"/>
<area shape="rect" id="node3" href="namespacesouffle.html#aae135d2382a133fa5b036296fbd7f60a" title="souffle::isEqualAdornment" alt="" coords="600,5,793,32"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="621,57,772,98"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="863,123,1010,149"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="645,123,749,149"/>
<area shape="rect" id="node10" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="621,174,772,215"/>
<area shape="rect" id="node12" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="613,239,781,281"/>
<area shape="rect" id="node13" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="841,239,1032,281"/>
</map>
</div>

</div>
</div>
<a id="a6fe97eb10ce6551c9e957bb3950c68eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe97eb10ce6551c9e957bb3950c68eb">&#9670;&nbsp;</a></span>addIgnoredRelations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a>&gt; souffle::addIgnoredRelations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt;&#160;</td>
          <td class="paramname"><em>relations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00370">370</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_magic_set_8cpp_source.html#l00297">addBackwardDependencies()</a>, <a class="el" href="_global_8h_source.html#l00135">souffle::Global::config()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00046">contains()</a>, <a class="el" href="_ast_program_8h_source.html#l00057">souffle::AstProgram::getRelations()</a>, <a class="el" href="_component_instantiation_transformer_8cpp_source.html#l00047">relations</a>, and <a class="el" href="_util_8h_source.html#l00908">splitString()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00695">souffle::Adornment::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;                                                                       {</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <span class="comment">// get a vector of all relations specified by the option</span></div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    std::vector&lt;std::string&gt; specifiedRelations = <a class="code" href="namespacesouffle.html#a673608e9453179d30f6607384f54463a">splitString</a>(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;magic-transform&quot;</span>), <span class="charliteral">&#39;,&#39;</span>);</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    <span class="comment">// if a star was used as a relation, then magic set will be performed for all nodes</span></div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">contains</a>(specifiedRelations, <span class="stringliteral">&quot;*&quot;</span>)) {</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="_component_instantiation_transformer_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a>;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    }</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <span class="comment">// find all specified relations</span></div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    std::set&lt;AstQualifiedName&gt; targetRelations;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    <span class="keywordflow">for</span> (AstRelation* rel : program-&gt;getRelations()) {</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        std::string mainName = rel-&gt;getQualifiedName().getQualifiers()[0];</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">contains</a>(specifiedRelations, mainName)) {</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;            targetRelations.insert(rel-&gt;getQualifiedName());</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        }</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    }</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    <span class="comment">// add all backward-dependencies to the list of relations to transform;</span></div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    <span class="comment">// if we want to magic transform &#39;a&#39;, then we also have to magic transform</span></div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    <span class="comment">// every relation that (directly or indirectly) uses &#39;a&#39; in its clauses</span></div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    targetRelations = <a class="code" href="namespacesouffle.html#a1ef96dcee06ebf23b793c3fd5a9fe111">addBackwardDependencies</a>(program, targetRelations);</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    <span class="comment">// ignore all relations not specified by the option</span></div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    std::set&lt;AstQualifiedName&gt; retVal(<a class="code" href="_component_instantiation_transformer_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a>);</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    <span class="keywordflow">for</span> (AstRelation* rel : program-&gt;getRelations()) {</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">contains</a>(targetRelations, rel-&gt;getQualifiedName())) {</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;            retVal.insert(rel-&gt;getQualifiedName());</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;        }</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    }</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="keywordflow">return</span> retVal;</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a8a825f62e860ca448e7e16ab1a3a4333"><div class="ttname"><a href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">souffle::contains</a></div><div class="ttdeci">bool contains(std::set&lt; AdornedPredicate &gt; adornedPredicates, const AstQualifiedName &amp;atomName, const std::string &amp;atomAdornment)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00046">MagicSet.cpp:46</a></div></div>
<div class="ttc" id="_component_instantiation_transformer_8cpp_html_a9141804302982067ed0a048c2336105a"><div class="ttname"><a href="_component_instantiation_transformer_8cpp.html#a9141804302982067ed0a048c2336105a">relations</a></div><div class="ttdeci">std::vector&lt; std::unique_ptr&lt; AstRelation &gt; &gt; relations</div><div class="ttdef"><b>Definition:</b> <a href="_component_instantiation_transformer_8cpp_source.html#l00047">ComponentInstantiationTransformer.cpp:47</a></div></div>
<div class="ttc" id="namespacesouffle_html_a673608e9453179d30f6607384f54463a"><div class="ttname"><a href="namespacesouffle.html#a673608e9453179d30f6607384f54463a">souffle::splitString</a></div><div class="ttdeci">std::vector&lt; std::string &gt; splitString(const std::string &amp;str, char delimiter)</div><div class="ttdoc">Splits a string given a delimiter. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00908">Util.h:908</a></div></div>
<div class="ttc" id="namespacesouffle_html_a1ef96dcee06ebf23b793c3fd5a9fe111"><div class="ttname"><a href="namespacesouffle.html#a1ef96dcee06ebf23b793c3fd5a9fe111">souffle::addBackwardDependencies</a></div><div class="ttdeci">std::set&lt; AstQualifiedName &gt; addBackwardDependencies(const AstProgram *program, std::set&lt; AstQualifiedName &gt; relations)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00297">MagicSet.cpp:297</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a6fe97eb10ce6551c9e957bb3950c68eb_cgraph.png" border="0" usemap="#namespacesouffle_a6fe97eb10ce6551c9e957bb3950c68eb_cgraph" alt=""/></div>
<map name="namespacesouffle_a6fe97eb10ce6551c9e957bb3950c68eb_cgraph" id="namespacesouffle_a6fe97eb10ce6551c9e957bb3950c68eb_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a1ef96dcee06ebf23b793c3fd5a9fe111" title="souffle::addBackwardDependencies" alt="" coords="260,107,515,133"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333" title="souffle::contains" alt="" coords="626,5,755,32"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="615,209,766,250"/>
<area shape="rect" id="node13" href="classsouffle_1_1_global.html#a2dcb257b0f98d0b882862427cc965640" title="souffle::Global::config" alt="" coords="306,208,469,235"/>
<area shape="rect" id="node14" href="namespacesouffle.html#a673608e9453179d30f6607384f54463a" title="Splits a string given a delimiter. " alt="" coords="317,259,457,285"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="617,157,764,184"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="563,56,819,83"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="607,107,775,133"/>
<area shape="rect" id="node4" href="namespacesouffle.html#aae135d2382a133fa5b036296fbd7f60a" title="souffle::isEqualAdornment" alt="" coords="867,5,1060,32"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="888,150,1039,191"/>
<area shape="rect" id="node7" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1130,187,1277,213"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="879,85,1047,126"/>
<area shape="rect" id="node12" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="1108,85,1299,126"/>
</map>
</div>

</div>
</div>
<a id="a14b5f9eb9ec09c40e558b242e75de872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b5f9eb9ec09c40e558b242e75de872">&#9670;&nbsp;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::all_of </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic test checking whether all elements within a container satisfy a certain predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container </td></tr>
    <tr><td class="paramname">p</td><td>the predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if for all elements x in c the predicate p(x) is true, false otherwise; for empty containers the result is always true </dd></dl>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00996">996</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_type_system_8cpp_source.html#l00435">areSubtypesOf()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00566">isConstantArithExpr()</a>, <a class="el" href="_type_system_8cpp_source.html#l00335">isFloatType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00343">isNumberType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00367">isRecordType()</a>, <a class="el" href="_type_system_8h_source.html#l00286">souffle::TypeSet::isSubsetOf()</a>, <a class="el" href="_type_system_8cpp_source.html#l00359">isSymbolType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00351">isUnsignedType()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l01253">souffle::PolymorphicObjectsTransformer::transform()</a>, and <a class="el" href="_explain_provenance_8h_source.html#l00114">souffle::ConstConstraint::verify()</a>.</p>
<div class="fragment"><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;                                                  {</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">std::all_of</a>(c.begin(), c.end(), <a class="code" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>);</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a0e2839cf85d4f50ed7cdcc6c1b3adf83"><div class="ttname"><a href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a></div><div class="ttdeci">a horizontalBars(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})):a.axisX.type.call(c, c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})), l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y, b.normalized.series, o,{ticks:k}):a.axisY.type.call(c, c.Axis.units.y, b.normalized.series, o, a.axisY)) var p</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a14b5f9eb9ec09c40e558b242e75de872"><div class="ttname"><a href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">souffle::all_of</a></div><div class="ttdeci">bool all_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether all elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00996">Util.h:996</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a34f8eecb81c090fca9e58d3357b63ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f8eecb81c090fca9e58d3357b63ed9">&#9670;&nbsp;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::any_of </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic test checking whether any elements within a container satisfy a certain predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container </td></tr>
    <tr><td class="paramname">p</td><td>the predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is an element x in c such that predicate p(x) is true, false otherwise; for empty containers the result is always false </dd></dl>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01010">1010</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00534">souffle::AstTranslator::ClauseTranslator::createValueIndex()</a>, <a class="el" href="_type_system_8cpp_source.html#l00446">getLeastCommonSupertypes()</a>, <a class="el" href="_type_system_8cpp_source.html#l00327">hasFloatType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00319">hasSignedType()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00402">hasUnnamedVariable()</a>, <a class="el" href="_type_system_8cpp_source.html#l00323">hasUnsignedType()</a>, <a class="el" href="_ast_translator_8h_source.html#l00250">souffle::AstTranslator::ValueIndex::isAggregator()</a>, <a class="el" href="_type_system_8cpp_source.html#l00371">isRecursiveType()</a>, and <a class="el" href="_resolve_aliases_transformer_8cpp_source.html#l00360">souffle::ResolveAliasesTransformer::removeComplexTermsInAtoms()</a>.</p>
<div class="fragment"><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;                                                  {</div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">std::any_of</a>(c.begin(), c.end(), <a class="code" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>);</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a0e2839cf85d4f50ed7cdcc6c1b3adf83"><div class="ttname"><a href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a></div><div class="ttdeci">a horizontalBars(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})):a.axisX.type.call(c, c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})), l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y, b.normalized.series, o,{ticks:k}):a.axisY.type.call(c, c.Axis.units.y, b.normalized.series, o, a.axisY)) var p</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a34f8eecb81c090fca9e58d3357b63ed9"><div class="ttname"><a href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">souffle::any_of</a></div><div class="ttdeci">bool any_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether any elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01010">Util.h:1010</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a58307d673d31e66b4f26149089d7758d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58307d673d31e66b4f26149089d7758d">&#9670;&nbsp;</a></span>appendStmt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::appendStmt </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ram_statement.html">RamStatement</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>stmtList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ram_statement.html">RamStatement</a> &gt;&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>append statement to a list of statements </p>

<p class="definition">Definition at line <a class="el" href="_ast_translator_8cpp_source.html#l00075">75</a> of file <a class="el" href="_ast_translator_8cpp_source.html">AstTranslator.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_translator_8cpp_source.html#l01352">souffle::AstTranslator::makeNegationSubproofSubroutine()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00960">souffle::AstTranslator::translateNonRecursiveRelation()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l01518">souffle::AstTranslator::translateProgram()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l01061">souffle::AstTranslator::translateRecursiveRelation()</a>.</p>
<div class="fragment"><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                                                                                            {</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="keywordflow">if</span> (stmt) {</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        stmtList.push_back(std::move(stmt));</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    }</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a0654c08409f66fdca60d0cc668de83a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0654c08409f66fdca60d0cc668de83a5">&#9670;&nbsp;</a></span>applySips()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned int&gt; souffle::applySips </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesouffle.html#ad0dcec7b78fdde7450cb55df1fece164">sips_t</a>&#160;</td>
          <td class="paramname"><em>sipsFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&gt;&#160;</td>
          <td class="paramname"><em>atoms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the new ordering of a vector of atoms after the given SIPS is applied. </p>

<p class="definition">Definition at line <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00308">308</a> of file <a class="el" href="_reorder_literals_transformer_8cpp_source.html">ReorderLiteralsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_literal_8h_source.html#l00078">souffle::AstAtom::getArguments()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00334">reorderClauseWithSips()</a>.</p>
<div class="fragment"><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                                                                                  {</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    std::set&lt;std::string&gt; boundVariables;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    std::vector&lt;unsigned int&gt; newOrder(atoms.size());</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numAdded = 0;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    <span class="keywordflow">while</span> (numAdded &lt; atoms.size()) {</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        <span class="comment">// grab the next atom, based on the SIPS function</span></div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextIdx = sipsFunction(atoms, boundVariables);</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;        AstAtom* nextAtom = atoms[nextIdx];</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        <span class="comment">// set all arguments that are variables as bound</span></div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        <span class="comment">// note: arguments that are functors, etc., do not newly bind anything</span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;        <span class="keywordflow">for</span> (AstArgument* arg : nextAtom-&gt;getArguments()) {</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">auto</span>* var = dynamic_cast&lt;AstVariable*&gt;(arg)) {</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                boundVariables.insert(var-&gt;getName());</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;            }</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        }</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        newOrder[numAdded] = nextIdx;  <span class="comment">// add to the ordering</span></div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        atoms[nextIdx] = <span class="keyword">nullptr</span>;      <span class="comment">// mark as done</span></div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        numAdded++;                    <span class="comment">// move on</span></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    }</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    <span class="keywordflow">return</span> newOrder;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a0654c08409f66fdca60d0cc668de83a5_cgraph.png" border="0" usemap="#namespacesouffle_a0654c08409f66fdca60d0cc668de83a5_cgraph" alt=""/></div>
<map name="namespacesouffle_a0654c08409f66fdca60d0cc668de83a5_cgraph" id="namespacesouffle_a0654c08409f66fdca60d0cc668de83a5_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="191,5,421,32"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="469,5,616,32"/>
</map>
</div>

</div>
</div>
<a id="a979f111a08bcb653771f92ec4c8c3e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979f111a08bcb653771f92ec4c8c3e16">&#9670;&nbsp;</a></span>areBijectivelyEquivalent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::areBijectivelyEquivalent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether two clauses are bijectively equivalent. </p>

<p class="definition">Definition at line <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00249">249</a> of file <a class="el" href="_minimise_program_transformer_8cpp_source.html">MinimiseProgramTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00041">extractPermutations()</a>, <a class="el" href="_ast_literal_8h_source.html#l00063">souffle::AstAtom::getArity()</a>, <a class="el" href="_ast_clause_8h_source.html#l00171">souffle::AstClause::getBodyLiterals()</a>, <a class="el" href="_ast_clause_8h_source.html#l00166">souffle::AstClause::getHead()</a>, <a class="el" href="json11_8h_source.html#l00651">i</a>, <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00136">isValidMove()</a>, <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00161">isValidPermutation()</a>, <a class="el" href="html_js_chartist_min_8h_source.html#l00015">j</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00324">reduceLocallyEquivalentClauses()</a>, and <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00372">reduceSingletonRelations()</a>.</p>
<div class="fragment"><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                                                                             {</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    <span class="comment">// only check bijective equivalence for a subset of the possible clauses</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    <span class="keyword">auto</span> isValidClause = [&amp;](<span class="keyword">const</span> AstClause* clause) {</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        <span class="comment">// check that all body literals are atoms</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        <span class="comment">// i.e. avoid clauses with constraints or negations</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        <span class="comment">// TODO (azreika): extend to constraints and negations</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        <span class="keywordflow">for</span> (AstLiteral* lit : clause-&gt;getBodyLiterals()) {</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            <span class="keywordflow">if</span> (dynamic_cast&lt;AstAtom*&gt;(lit) == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            }</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;        }</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        <span class="comment">// check that all arguments are either constants or variables</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        <span class="comment">// i.e. only allow primitive arguments</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        <span class="keywordtype">bool</span> valid = <span class="keyword">true</span>;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(*clause, [&amp;](<span class="keyword">const</span> AstArgument&amp; arg) {</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            <span class="keywordflow">if</span> (dynamic_cast&lt;const AstVariable*&gt;(&amp;arg) == <span class="keyword">nullptr</span> &amp;&amp;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                    dynamic_cast&lt;const AstConstant*&gt;(&amp;arg) == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                valid = <span class="keyword">false</span>;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            }</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        });</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        <span class="keywordflow">return</span> valid;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    };</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    <span class="keywordflow">if</span> (!isValidClause(left) || !isValidClause(right)) {</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    }</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    <span class="comment">// rules must be the same length to be equal</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    <span class="keywordflow">if</span> (left-&gt;getBodyLiterals().size() != right-&gt;getBodyLiterals().size()) {</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    }</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    <span class="comment">// head atoms must have the same arity</span></div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="keywordflow">if</span> (left-&gt;getHead()-&gt;getArity() != right-&gt;getHead()-&gt;getArity()) {</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    }</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    <span class="comment">// set up the n x n permutation matrix, where n is the number of</span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    <span class="comment">// atoms in the clause, including the head atom</span></div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <span class="keywordtype">size_t</span> size = left-&gt;getBodyLiterals().size() + 1;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    <span class="keyword">auto</span> permutationMatrix = std::vector&lt;std::vector&lt;unsigned int&gt;&gt;(size);</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> : permutationMatrix) {</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = std::vector&lt;unsigned int&gt;(size);</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    }</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    <span class="comment">// create permutation matrix</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    permutationMatrix[0][0] = 1;</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 1; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; size; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> = 1; <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> &lt; size; <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>++) {</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a90ecff533a6bf91c15209f6fbb56235f">isValidMove</a>(left, <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>, right, <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>)) {</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                permutationMatrix[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>][<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>] = 1;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;            }</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        }</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    }</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <span class="comment">// check if any of these permutations have valid variable mappings associated with them</span></div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    std::vector&lt;std::vector&lt;unsigned int&gt;&gt; permutations = <a class="code" href="namespacesouffle.html#a63b103a79e1c9886c80cff614ba6ef93">extractPermutations</a>(permutationMatrix);</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> permutation : permutations) {</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#aa3867b63ae91058fdbcbff1475240b16">isValidPermutation</a>(left, right, permutation)) {</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;            <span class="comment">// valid permutation with valid corresponding variable mapping exists</span></div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            <span class="comment">// therefore, the two clauses are equivalent!</span></div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        }</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    }</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_aab858032a95af802114b255fac6f45f2"><div class="ttname"><a href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a></div><div class="ttdeci">var j</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a63b103a79e1c9886c80cff614ba6ef93"><div class="ttname"><a href="namespacesouffle.html#a63b103a79e1c9886c80cff614ba6ef93">souffle::extractPermutations</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; extractPermutations(const std::vector&lt; std::vector&lt; unsigned int &gt;&gt; &amp;permutationMatrix)</div><div class="ttdoc">Extract valid permutations from a given permutation matrix of valid moves. </div><div class="ttdef"><b>Definition:</b> <a href="_minimise_program_transformer_8cpp_source.html#l00041">MinimiseProgramTransformer.cpp:41</a></div></div>
<div class="ttc" id="namespacesouffle_html_a90ecff533a6bf91c15209f6fbb56235f"><div class="ttname"><a href="namespacesouffle.html#a90ecff533a6bf91c15209f6fbb56235f">souffle::isValidMove</a></div><div class="ttdeci">bool isValidMove(const AstClause *left, size_t leftIdx, const AstClause *right, size_t rightIdx)</div><div class="ttdoc">Check if the atom at leftIdx in the left clause can potentially be matched up with the atom at rightI...</div><div class="ttdef"><b>Definition:</b> <a href="_minimise_program_transformer_8cpp_source.html#l00136">MinimiseProgramTransformer.cpp:136</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa3867b63ae91058fdbcbff1475240b16"><div class="ttname"><a href="namespacesouffle.html#aa3867b63ae91058fdbcbff1475240b16">souffle::isValidPermutation</a></div><div class="ttdeci">bool isValidPermutation(const AstClause *left, const AstClause *right, const std::vector&lt; unsigned int &gt; &amp;permutation)</div><div class="ttdoc">Check whether a valid variable mapping exists for the given permutation. </div><div class="ttdef"><b>Definition:</b> <a href="_minimise_program_transformer_8cpp_source.html#l00161">MinimiseProgramTransformer.cpp:161</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a979f111a08bcb653771f92ec4c8c3e16_cgraph.png" border="0" usemap="#namespacesouffle_a979f111a08bcb653771f92ec4c8c3e16_cgraph" alt=""/></div>
<map name="namespacesouffle_a979f111a08bcb653771f92ec4c8c3e16_cgraph" id="namespacesouffle_a979f111a08bcb653771f92ec4c8c3e16_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a63b103a79e1c9886c80cff614ba6ef93" title="Extract valid permutations from a given permutation matrix of valid moves. " alt="" coords="287,5,493,32"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#a6728012e15c7e2be0b626c477c5018fd" title="get arity of the atom " alt="" coords="295,56,485,83"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="816,193,955,234"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="1087,251,1226,293"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a90ecff533a6bf91c15209f6fbb56235f" title="Check if the atom at leftIdx in the left clause can potentially be matched up with the atom at rightI..." alt="" coords="549,107,701,133"/>
<area shape="rect" id="node9" href="namespacesouffle.html#aa3867b63ae91058fdbcbff1475240b16" title="Check whether a valid variable mapping exists for the given permutation. " alt="" coords="291,368,489,395"/>
<area shape="rect" id="node21" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="541,528,709,555"/>
<area shape="rect" id="node5" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1083,200,1230,227"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="757,91,1013,117"/>
<area shape="rect" id="node10" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Create a clone (i.e. " alt="" coords="816,543,955,585"/>
<area shape="rect" id="node13" href="namespacesouffle.html#ae77f3374134c13b638bf7644fcebb5ef" title="Reorders the atoms of a clause to be in the given order. " alt="" coords="544,427,707,453"/>
<area shape="rect" id="node24" href="classsouffle_1_1_ast_variable.html#a2b73a95c7b59624d956dee0ed4e13884" title="souffle::AstVariable\l::getName" alt="" coords="551,361,699,402"/>
<area shape="rect" id="node11" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="1300,437,1500,464"/>
<area shape="rect" id="node12" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="1102,551,1211,577"/>
<area shape="rect" id="node14" href="namespacesouffle.html#a6aa6d61f4a71ddbb2458d23ce24dbced" title="Returns a clause which contains head of the given clause. " alt="" coords="814,492,957,519"/>
<area shape="rect" id="node19" href="classsouffle_1_1_ast_clause.html#ac5e3416082d23734d1277daa5c9dee81" title="Add a Literal to the body of the clause. " alt="" coords="816,361,955,402"/>
<area shape="rect" id="node20" href="classsouffle_1_1_ast_literal.html#a8e7b7424c40acb87df022913c5928fd8" title="Create a clone (i.e. " alt="" coords="817,426,953,467"/>
<area shape="rect" id="node15" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Create a clone (i.e. " alt="" coords="1070,317,1243,344"/>
<area shape="rect" id="node17" href="classsouffle_1_1_ast_clause.html#aa943423c45971e70c837da5b88c8fc04" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="1085,434,1228,475"/>
<area shape="rect" id="node18" href="classsouffle_1_1_ast_execution_plan.html#ac657ffa016ae777656585a56fc9a899c" title="Create a clone (i.e. " alt="" coords="1063,369,1250,410"/>
<area shape="rect" id="node16" href="classsouffle_1_1_ast_atom.html#acef18129b13ce45477044717ded051d2" title="souffle::AstAtom::AstAtom" alt="" coords="1303,317,1497,344"/>
<area shape="rect" id="node22" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="801,630,969,671"/>
<area shape="rect" id="node23" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="1061,653,1252,694"/>
</map>
</div>

</div>
</div>
<a id="ac810dd526309dc398254f53e18edf50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac810dd526309dc398254f53e18edf50a">&#9670;&nbsp;</a></span>areSubtypesOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::areSubtypesOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether all types in s are subtypes of type b. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00435">435</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00996">all_of()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00401">isSubtypeOf()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_type_system_8h_source.html#l00513">isOrderableType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;                                                    {</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">all_of</a>(s, [&amp;](<span class="keyword">const</span> Type&amp; t) { <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(t, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>); });</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8cc19c66d9d13ce64e65f14dcabb43b3"><div class="ttname"><a href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">souffle::isSubtypeOf</a></div><div class="ttdeci">bool isSubtypeOf(const Type &amp;a, const Type &amp;b)</div><div class="ttdoc">Determines whether type a is a subtype of type b. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00401">TypeSystem.cpp:401</a></div></div>
<div class="ttc" id="namespacesouffle_html_a14b5f9eb9ec09c40e558b242e75de872"><div class="ttname"><a href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">souffle::all_of</a></div><div class="ttdeci">bool all_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether all elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00996">Util.h:996</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ac810dd526309dc398254f53e18edf50a_cgraph.png" border="0" usemap="#namespacesouffle_ac810dd526309dc398254f53e18edf50a_cgraph" alt=""/></div>
<map name="namespacesouffle_ac810dd526309dc398254f53e18edf50a_cgraph" id="namespacesouffle_ac810dd526309dc398254f53e18edf50a_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872" title="A generic test checking whether all elements within a container satisfy a certain predicate..." alt="" coords="245,100,356,127"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="224,151,377,178"/>
<area shape="rect" id="node4" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="660,50,907,76"/>
<area shape="rect" id="node5" href="classsouffle_1_1_type_environment.html#a5ead83575e9abfebb3a0b180a33a7d96" title="souffle::TypeEnvironment\l::isType" alt="" coords="425,253,612,294"/>
<area shape="rect" id="node6" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="690,180,877,221"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="435,100,602,127"/>
<area shape="rect" id="node12" href="classsouffle_1_1_type_environment.html#a72fa419d33bf813f22efabec629a4627" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="690,114,877,156"/>
<area shape="rect" id="node13" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="437,50,601,76"/>
<area shape="rect" id="node14" href="classsouffle_1_1_subset_type.html#ac5c52e503cbce42370d6ada3f050773d" title="souffle::SubsetType\l::getBaseType" alt="" coords="445,318,593,360"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="955,155,1080,182"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1151,126,1255,152"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="1128,177,1279,218"/>
<area shape="rect" id="node10" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1327,184,1473,211"/>
</map>
</div>

</div>
</div>
<a id="a9fbc2262a6164b62766f6fcb67f12ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbc2262a6164b62766f6fcb67f12ae4">&#9670;&nbsp;</a></span>baseName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::baseName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01182">1182</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_src_location_8cpp_source.html#l00087">souffle::SrcLocation::extloc()</a>, <a class="el" href="_src_location_8cpp_source.html#l00027">getCurrentFilename()</a>, <a class="el" href="main_8cpp_source.html#l00124">main()</a>, <a class="el" href="_read_stream_c_s_v_8h_source.html#l00231">souffle::ReadFileCSV::ReadFileCSV()</a>, and <a class="el" href="_read_stream_c_s_v_8h_source.html#l00252">souffle::ReadFileCSV::readNextTuple()</a>.</p>
<div class="fragment"><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;                                                     {</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;    <span class="keywordflow">if</span> (filename.empty()) {</div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;.&quot;</span>;</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;    }</div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;</div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;    <span class="keywordtype">size_t</span> lastNotSlash = filename.find_last_not_of(<span class="charliteral">&#39;/&#39;</span>);</div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;    <span class="keywordflow">if</span> (lastNotSlash == std::string::npos) {</div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;/&quot;</span>;</div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;    }</div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;</div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;    <span class="keywordtype">size_t</span> lastSlashBeforeBasename = filename.find_last_of(<span class="charliteral">&#39;/&#39;</span>, lastNotSlash - 1);</div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;    <span class="keywordflow">if</span> (lastSlashBeforeBasename == std::string::npos) {</div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;        lastSlashBeforeBasename = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(-1);</div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;    }</div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;    <span class="keywordflow">return</span> filename.substr(lastSlashBeforeBasename + 1, lastNotSlash - lastSlashBeforeBasename);</div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a90cc6d2beab208ecbf25ddabd458256e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cc6d2beab208ecbf25ddabd458256e">&#9670;&nbsp;</a></span>bindArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::string, std::set&lt;std::string&gt; &gt; souffle::bindArguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&#160;</td>
          <td class="paramname"><em>currAtom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>boundArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;&#160;</td>
          <td class="paramname"><em>compositeBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00444">444</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_literal_8h_source.html#l00078">souffle::AstAtom::getArguments()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00083">getString()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00115">isBoundArgument()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00695">souffle::Adornment::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;                                                                                         {</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    std::set&lt;std::string&gt; newlyBoundArgs;</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    std::string atomAdornment = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    <span class="keywordflow">for</span> (AstArgument* arg : currAtom-&gt;getArguments()) {</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a5048549cddd623327a828a4cc90fe746">isBoundArgument</a>(arg, boundArgs, compositeBindings)) {</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;            atomAdornment += <span class="stringliteral">&quot;b&quot;</span>;  <span class="comment">// bound</span></div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;            atomAdornment += <span class="stringliteral">&quot;f&quot;</span>;  <span class="comment">// free</span></div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;            std::string argName = <a class="code" href="namespacesouffle.html#a526256b2f4d593cceb8b73068e7de882">getString</a>(arg);</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;            newlyBoundArgs.insert(argName);  <span class="comment">// now bound</span></div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;        }</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    }</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <span class="comment">// add newly bound arguments to the list of bound arguments</span></div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    <span class="keywordflow">for</span> (std::string newArg : newlyBoundArgs) {</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;        boundArgs.insert(newArg);</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    }</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    <span class="keywordflow">return</span> std::make_pair(atomAdornment, boundArgs);</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a526256b2f4d593cceb8b73068e7de882"><div class="ttname"><a href="namespacesouffle.html#a526256b2f4d593cceb8b73068e7de882">souffle::getString</a></div><div class="ttdeci">std::string getString(const AstArgument *arg)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00083">MagicSet.cpp:83</a></div></div>
<div class="ttc" id="namespacesouffle_html_a5048549cddd623327a828a4cc90fe746"><div class="ttname"><a href="namespacesouffle.html#a5048549cddd623327a828a4cc90fe746">souffle::isBoundArgument</a></div><div class="ttdeci">bool isBoundArgument(AstArgument *arg, const std::set&lt; std::string &gt; &amp;boundArgs, BindingStore &amp;compositeBindings)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00115">MagicSet.cpp:115</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a90cc6d2beab208ecbf25ddabd458256e_cgraph.png" border="0" usemap="#namespacesouffle_a90cc6d2beab208ecbf25ddabd458256e_cgraph" alt=""/></div>
<map name="namespacesouffle_a90cc6d2beab208ecbf25ddabd458256e_cgraph" id="namespacesouffle_a90cc6d2beab208ecbf25ddabd458256e_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="227,5,457,32"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a526256b2f4d593cceb8b73068e7de882" title="souffle::getString" alt="" coords="275,56,409,83"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a5048549cddd623327a828a4cc90fe746" title="souffle::isBoundArgument" alt="" coords="247,107,437,133"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="530,5,677,32"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198" title="souffle::hasPrefix" alt="" coords="536,56,671,83"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a4d2a34e7c27740b381cf558eeebb28e4" title="souffle::isBoundComposite" alt="" coords="505,161,701,188"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333" title="souffle::contains" alt="" coords="794,103,923,129"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_variable.html#a2b73a95c7b59624d956dee0ed4e13884" title="souffle::AstVariable\l::getName" alt="" coords="785,154,933,195"/>
<area shape="rect" id="node11" href="classsouffle_1_1_binding_store.html#a9ce08dc8e33c130b291f57e9d72d0c78" title="souffle::BindingStore\l::getVariableDependencies" alt="" coords="761,219,957,261"/>
<area shape="rect" id="node12" href="classsouffle_1_1_binding_store.html#a0da8360ecba6d9b26e9d075a0b285740" title="souffle::BindingStore\l::addVariableBoundComposite" alt="" coords="749,285,968,326"/>
<area shape="rect" id="node10" href="namespacesouffle.html#aae135d2382a133fa5b036296fbd7f60a" title="souffle::isEqualAdornment" alt="" coords="1016,103,1209,129"/>
</map>
</div>

</div>
</div>
<a id="a5c6308ee8b92e79229e01daec1d68d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6308ee8b92e79229e01daec1d68d6a">&#9670;&nbsp;</a></span>bindComposites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> souffle::bindComposites </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00594">594</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_magic_set_8h_source.html#l00148">souffle::BindingStore::addBinding()</a>, <a class="el" href="_ast_constraint_analysis_8h_source.html#l00132">constraints</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa123e958001611b441dab45ff11ba98a">FEQ</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a22ae0e2b89e5e3d477f988cc36d3272b">Float</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00042">getClauses()</a>, and <a class="el" href="_ast_program_8h_source.html#l00057">souffle::AstProgram::getRelations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00695">souffle::Adornment::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;                                                       {</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    <span class="keyword">struct </span>M : <span class="keyword">public</span> AstNodeMapper {</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;        BindingStore&amp; compositeBindings;</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;        std::set&lt;AstBinaryConstraint*&gt;&amp; <a class="code" href="_ast_constraint_analysis_8h.html#a4551a78b0ee37ec3710ad8cda752cf2e">constraints</a>;</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;        <span class="keyword">mutable</span> <span class="keywordtype">int</span> changeCount;</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;        M(BindingStore&amp; compositeBindings, std::set&lt;AstBinaryConstraint*&gt;&amp; constraints, <span class="keywordtype">int</span> changeCount)</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;                : compositeBindings(compositeBindings), constraints(constraints), changeCount(changeCount) {}</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;        <span class="keywordtype">int</span> getChangeCount()<span class="keyword"> const </span>{</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;            <span class="keywordflow">return</span> changeCount;</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;        }</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;        std::unique_ptr&lt;AstNode&gt; operator()(std::unique_ptr&lt;AstNode&gt; node)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">auto</span>* functor = dynamic_cast&lt;AstFunctor*&gt;(node.get())) {</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;                <span class="comment">// functor found</span></div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                changeCount++;</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;                <span class="comment">// create new variable name (with appropriate suffix)</span></div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;                std::stringstream newVariableName;</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;                newVariableName &lt;&lt; <span class="stringliteral">&quot;+functor&quot;</span> &lt;&lt; changeCount;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;                <span class="comment">// add the binding to the BindingStore</span></div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;                compositeBindings.addBinding(newVariableName.str(), functor);</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;                <span class="comment">// create new constraint (+functorX = original-functor)</span></div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;                <span class="keyword">auto</span> newVariable = std::make_unique&lt;AstVariable&gt;(newVariableName.str());</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;                <span class="keyword">auto</span> opEq = functor-&gt;getReturnType() == TypeAttribute::Float ? BinaryConstraintOp::FEQ</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;                                                                             : BinaryConstraintOp::EQ;</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;                constraints.insert(</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;                        <span class="keyword">new</span> AstBinaryConstraint(opEq, std::unique_ptr&lt;AstArgument&gt;(newVariable-&gt;clone()),</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;                                std::unique_ptr&lt;AstArgument&gt;(functor-&gt;clone())));</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;                <span class="comment">// update functor to be the variable created</span></div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;                <span class="keywordflow">return</span> newVariable;</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span>* record = dynamic_cast&lt;AstRecordInit*&gt;(node.get())) {</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;                <span class="comment">// record found</span></div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;                changeCount++;</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;                <span class="comment">// create new variable name (with appropriate suffix)</span></div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;                std::stringstream newVariableName;</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;                newVariableName &lt;&lt; <span class="stringliteral">&quot;+record&quot;</span> &lt;&lt; changeCount;</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;                <span class="comment">// add the binding to the BindingStore</span></div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;                compositeBindings.addBinding(newVariableName.str(), record);</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;                <span class="comment">// create new constraint (+recordX = original-record)</span></div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;                <span class="keyword">auto</span> newVariable = std::make_unique&lt;AstVariable&gt;(newVariableName.str());</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;                constraints.insert(<span class="keyword">new</span> AstBinaryConstraint(BinaryConstraintOp::EQ,</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;                        std::unique_ptr&lt;AstArgument&gt;(newVariable-&gt;clone()),</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;                        std::unique_ptr&lt;AstArgument&gt;(record-&gt;clone())));</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;                <span class="comment">// update record to be the variable created</span></div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;                <span class="keywordflow">return</span> newVariable;</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;            }</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;            <span class="keywordflow">return</span> node;</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;        }</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;    };</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;    BindingStore compositeBindings;</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;    <span class="keywordtype">int</span> changeCount = 0;  <span class="comment">// number of functors/records seen so far</span></div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;    <span class="comment">// apply the change to all clauses in the program</span></div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;    <span class="keywordflow">for</span> (AstRelation* rel : program-&gt;getRelations()) {</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;        <span class="keywordflow">for</span> (AstClause* clause : <a class="code" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">getClauses</a>(*program, *rel)) {</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;            std::set&lt;AstBinaryConstraint*&gt; <a class="code" href="_ast_constraint_analysis_8h.html#a4551a78b0ee37ec3710ad8cda752cf2e">constraints</a>;</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;            M update(compositeBindings, constraints, changeCount);</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;            clause-&gt;apply(update);</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;            changeCount = update.getChangeCount();</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;            <span class="keywordflow">for</span> (AstBinaryConstraint* constraint : constraints) {</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;                clause-&gt;addToBody(std::unique_ptr&lt;AstBinaryConstraint&gt;(constraint));</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;            }</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;        }</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;    }</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;    <span class="keywordflow">return</span> compositeBindings;</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;}</div><div class="ttc" id="_ast_constraint_analysis_8h_html_a4551a78b0ee37ec3710ad8cda752cf2e"><div class="ttname"><a href="_ast_constraint_analysis_8h.html#a4551a78b0ee37ec3710ad8cda752cf2e">constraints</a></div><div class="ttdeci">Problem&lt; AnalysisVar &gt; constraints</div><div class="ttdoc">The list of constraints making underlying this analysis. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_constraint_analysis_8h_source.html#l00132">AstConstraintAnalysis.h:132</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4d9e53888640a9abfd7ea7c43715152a"><div class="ttname"><a href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">souffle::getClauses</a></div><div class="ttdeci">std::vector&lt; AstClause * &gt; getClauses(const AstProgram &amp;program, const AstQualifiedName &amp;relationName)</div><div class="ttdoc">Returns a vector of clauses in the program describing the relation with the given name...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00042">AstUtils.cpp:42</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a5c6308ee8b92e79229e01daec1d68d6a_cgraph.png" border="0" usemap="#namespacesouffle_a5c6308ee8b92e79229e01daec1d68d6a_cgraph" alt=""/></div>
<map name="namespacesouffle_a5c6308ee8b92e79229e01daec1d68d6a_cgraph" id="namespacesouffle_a5c6308ee8b92e79229e01daec1d68d6a_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_binding_store.html#a5274542dd9e7da5e28dfb25e566f3719" title="souffle::BindingStore\l::addBinding" alt="" coords="232,93,389,135"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="237,195,384,222"/>
<area shape="rect" id="node11" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="235,247,386,288"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_argument.html#a5f13087d708e0117ec3a913c7ffc3ad8" title="Create clone. " alt="" coords="442,5,601,47"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="437,71,605,98"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_variable.html#a2b73a95c7b59624d956dee0ed4e13884" title="souffle::AstVariable\l::getName" alt="" coords="447,123,595,164"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="653,64,821,105"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="869,64,1060,105"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="446,188,597,229"/>
<area shape="rect" id="node10" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="664,225,811,251"/>
</map>
</div>

</div>
</div>
<a id="a785852c2fc649d79a481627605ffcf4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785852c2fc649d79a481627605ffcf4f">&#9670;&nbsp;</a></span>canBeParsedAsRamFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::canBeParsedAsRamFloat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can a string be parsed as RamFloat. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00262">262</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00163">RamFloatFromString()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_type_analysis_8cpp_source.html#l00517">souffle::TypeAnalysis::analyseTypes()</a>, and <a class="el" href="_explain_provenance_impl_8h_source.html#l00613">souffle::ExplainProvenanceImpl::queryProcess()</a>.</p>
<div class="fragment"><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;                                                           {</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    <span class="keywordtype">size_t</span> charactersRead = 0;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    <span class="keywordflow">try</span> {</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        <a class="code" href="namespacesouffle.html#a42f50e44c16d45c78e4a37b005ac94c9">RamFloatFromString</a>(<span class="keywordtype">string</span>, &amp;charactersRead);</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    } <span class="keywordflow">catch</span> (...) {</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    }</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    <span class="keywordflow">return</span> charactersRead == <span class="keywordtype">string</span>.size();</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a42f50e44c16d45c78e4a37b005ac94c9"><div class="ttname"><a href="namespacesouffle.html#a42f50e44c16d45c78e4a37b005ac94c9">souffle::RamFloatFromString</a></div><div class="ttdeci">RamFloat RamFloatFromString(const std::string &amp;str, std::size_t *position=nullptr)</div><div class="ttdoc">Converts a string to a RamFloat. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00163">Util.h:163</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a785852c2fc649d79a481627605ffcf4f_cgraph.png" border="0" usemap="#namespacesouffle_a785852c2fc649d79a481627605ffcf4f_cgraph" alt=""/></div>
<map name="namespacesouffle_a785852c2fc649d79a481627605ffcf4f_cgraph" id="namespacesouffle_a785852c2fc649d79a481627605ffcf4f_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a42f50e44c16d45c78e4a37b005ac94c9" title="Converts a string to a RamFloat. " alt="" coords="256,13,463,39"/>
</map>
</div>

</div>
</div>
<a id="a89f207449b2332bf06ab28993dda09b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f207449b2332bf06ab28993dda09b9">&#9670;&nbsp;</a></span>canBeParsedAsRamSigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::canBeParsedAsRamSigned </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can a string be parsed as RamSigned. </p>
<p>Souffle (parser, not fact file readers) accepts: hex, binary and base 10. Integer can be negative, in all 3 formats this means that it starts with minus (c++ default semantics). </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00232">232</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00121">RamSignedFromString()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_type_analysis_8cpp_source.html#l00517">souffle::TypeAnalysis::analyseTypes()</a>, and <a class="el" href="_explain_provenance_impl_8h_source.html#l00613">souffle::ExplainProvenanceImpl::queryProcess()</a>.</p>
<div class="fragment"><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;                                                            {</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    <span class="keywordtype">size_t</span> charactersRead = 0;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <span class="keywordflow">try</span> {</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        <a class="code" href="namespacesouffle.html#ad354d1210c639429c093f92ba2966a75">RamSignedFromString</a>(<span class="keywordtype">string</span>, &amp;charactersRead, 0);</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    } <span class="keywordflow">catch</span> (...) {</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    }</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    <span class="keywordflow">return</span> charactersRead == <span class="keywordtype">string</span>.size();</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_ad354d1210c639429c093f92ba2966a75"><div class="ttname"><a href="namespacesouffle.html#ad354d1210c639429c093f92ba2966a75">souffle::RamSignedFromString</a></div><div class="ttdeci">RamSigned RamSignedFromString(const std::string &amp;str, std::size_t *position=nullptr, const int base=10)</div><div class="ttdoc">Converts a string to a RamSigned. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00121">Util.h:121</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a89f207449b2332bf06ab28993dda09b9_cgraph.png" border="0" usemap="#namespacesouffle_a89f207449b2332bf06ab28993dda09b9_cgraph" alt=""/></div>
<map name="namespacesouffle_a89f207449b2332bf06ab28993dda09b9_cgraph" id="namespacesouffle_a89f207449b2332bf06ab28993dda09b9_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ad354d1210c639429c093f92ba2966a75" title="Converts a string to a RamSigned. " alt="" coords="256,13,475,39"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0" title="Determine if one string is a prefix of another. " alt="" coords="523,13,645,39"/>
</map>
</div>

</div>
</div>
<a id="a3773094eb7aa42e20a209b40c9873aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3773094eb7aa42e20a209b40c9873aa4">&#9670;&nbsp;</a></span>canBeParsedAsRamUnsigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::canBeParsedAsRamUnsigned </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can a string be parsed as RamUnsigned. </p>
<p>Souffle accepts: hex, binary and base 10. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00249">249</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00180">RamUnsignedFromString()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_type_analysis_8cpp_source.html#l00517">souffle::TypeAnalysis::analyseTypes()</a>, and <a class="el" href="_explain_provenance_impl_8h_source.html#l00613">souffle::ExplainProvenanceImpl::queryProcess()</a>.</p>
<div class="fragment"><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                                                              {</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    <span class="keywordtype">size_t</span> charactersRead = 0;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    <span class="keywordflow">try</span> {</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        <a class="code" href="namespacesouffle.html#a084bbb9535fee35e4682c948ce88bddb">RamUnsignedFromString</a>(<span class="keywordtype">string</span>, &amp;charactersRead, 0);</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    } <span class="keywordflow">catch</span> (...) {</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    }</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    <span class="keywordflow">return</span> charactersRead == <span class="keywordtype">string</span>.size();</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a084bbb9535fee35e4682c948ce88bddb"><div class="ttname"><a href="namespacesouffle.html#a084bbb9535fee35e4682c948ce88bddb">souffle::RamUnsignedFromString</a></div><div class="ttdeci">RamUnsigned RamUnsignedFromString(const std::string &amp;str, std::size_t *position=nullptr, const int base=10)</div><div class="ttdoc">Converts a string to a RamUnsigned. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00180">Util.h:180</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a3773094eb7aa42e20a209b40c9873aa4_cgraph.png" border="0" usemap="#namespacesouffle_a3773094eb7aa42e20a209b40c9873aa4_cgraph" alt=""/></div>
<map name="namespacesouffle_a3773094eb7aa42e20a209b40c9873aa4_cgraph" id="namespacesouffle_a3773094eb7aa42e20a209b40c9873aa4_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a084bbb9535fee35e4682c948ce88bddb" title="Converts a string to a RamUnsigned. " alt="" coords="256,5,453,47"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0" title="Determine if one string is a prefix of another. " alt="" coords="501,13,624,39"/>
</map>
</div>

</div>
</div>
<a id="aa523350db005da7a3c79c845ebbb6aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa523350db005da7a3c79c845ebbb6aa7">&#9670;&nbsp;</a></span>castEq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename toType , typename baseType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::castEq </td>
          <td>(</td>
          <td class="paramtype">const baseType *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const baseType *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast the values, from baseType to toType and compare using ==. </p>
<p>(if casting fails -&gt; return false.)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">baseType,initial</td><td><a class="el" href="classsouffle_1_1_type.html" title="An abstract base class for types to be covered within a type environment. ">Type</a> of values </td></tr>
    <tr><td class="paramname">toType,type</td><td>where equality comparison takes place. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00495">495</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;                                                         {</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span> castedLeft = dynamic_cast&lt;const toType*&gt;(left)) {</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">auto</span> castedRight = dynamic_cast&lt;const toType*&gt;(right)) {</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;            <span class="keywordflow">return</span> castedLeft == castedRight;</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;        }</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    }</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a018886d19f141b1cb565199a517c598f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018886d19f141b1cb565199a517c598f">&#9670;&nbsp;</a></span>clone() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;A&gt; souffle::clone </td>
          <td>(</td>
          <td class="paramtype">const A *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00465">465</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_clause_8h_source.html#l00190">souffle::AstClause::clone()</a>, <a class="el" href="_util_8h_source.html#l00475">clone()</a>, <a class="el" href="_ast_argument_8h_source.html#l00524">souffle::AstAggregator::clone()</a>, <a class="el" href="_brie_8h_source.html#l01286">souffle::SparseArray&lt; value_t, BITS, merge_op &gt;::clone()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00179">cloneHead()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00273">souffle::MakeIndexTransformer::constructPattern()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00996">createMagicRelation()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00529">getInlinedArgument()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00731">getInlinedAtom()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l01281">souffle::AstTranslator::makeSubproofSubroutine()</a>, <a class="el" href="_brie_8h_source.html#l00784">souffle::SparseArray&lt; value_t, BITS, merge_op &gt;::merge()</a>, <a class="el" href="_ram_node_8h_source.html#l00112">souffle::RamNode::operator!=()</a>, <a class="el" href="_brie_8h_source.html#l00239">souffle::SparseArray&lt; value_t, BITS, merge_op &gt;::operator=()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00355">souffle::MakeIndexTransformer::rewriteIndexScan()</a>, <a class="el" href="_brie_8h_source.html#l00204">souffle::SparseArray&lt; value_t, BITS, merge_op &gt;::SparseArray()</a>, <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l01489">souffle::FoldAnonymousRecords::transformClause()</a>.</p>
<div class="fragment"><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;                                      {</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    <span class="keywordflow">return</span> node ? std::unique_ptr&lt;A&gt;(node-&gt;clone()) : <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="afd5539f3bdbac7d5cc7fc87434aa4adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5539f3bdbac7d5cc7fc87434aa4adb">&#9670;&nbsp;</a></span>clone() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;A&gt; souffle::clone </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00470">470</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;                                                     {</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    <span class="keywordflow">return</span> node ? std::unique_ptr&lt;A&gt;(node-&gt;clone()) : <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a7b945c962bb01844b4b2032a77e64564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b945c962bb01844b4b2032a77e64564">&#9670;&nbsp;</a></span>clone() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unique_ptr&lt;A&gt; &gt; souffle::clone </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; A &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00475">475</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00465">clone()</a>.</p>
<div class="fragment"><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;                                                                         {</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    std::vector&lt;std::unique_ptr&lt;A&gt;&gt; ys;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;    ys.reserve(xs.size());</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; x : xs) {</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;        ys.emplace_back(<a class="code" href="namespacesouffle.html#a7b945c962bb01844b4b2032a77e64564">clone</a>(x));</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    }</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    <span class="keywordflow">return</span> ys;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a7b945c962bb01844b4b2032a77e64564"><div class="ttname"><a href="namespacesouffle.html#a7b945c962bb01844b4b2032a77e64564">souffle::clone</a></div><div class="ttdeci">std::vector&lt; std::unique_ptr&lt; A &gt; &gt; clone(const std::vector&lt; std::unique_ptr&lt; A &gt;&gt; &amp;xs)</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00475">Util.h:475</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a7b945c962bb01844b4b2032a77e64564_cgraph.png" border="0" usemap="#namespacesouffle_a7b945c962bb01844b4b2032a77e64564_cgraph" alt=""/></div>
<map name="namespacesouffle_a7b945c962bb01844b4b2032a77e64564_cgraph" id="namespacesouffle_a7b945c962bb01844b4b2032a77e64564_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="163,5,272,32"/>
</map>
</div>

</div>
</div>
<a id="a6aa6d61f4a71ddbb2458d23ce24dbced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa6d61f4a71ddbb2458d23ce24dbced">&#9670;&nbsp;</a></span>cloneHead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> * souffle::cloneHead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td>
          <td class="paramname"><em>clause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a clause which contains head of the given clause. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clause</td><td>the clause which head to be cloned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to clause which has head cloned from given clause </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00179">179</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_literal_8h_source.html#l00082">souffle::AstAtom::clone()</a>, <a class="el" href="_ast_clause_8h_source.html#l00091">souffle::AstExecutionPlan::clone()</a>, <a class="el" href="_util_8h_source.html#l00465">clone()</a>, <a class="el" href="_ast_clause_8h_source.html#l00176">souffle::AstClause::getExecutionPlan()</a>, <a class="el" href="_ast_clause_8h_source.html#l00166">souffle::AstClause::getHead()</a>, and <a class="el" href="_ast_node_8h_source.html#l00045">souffle::AstNode::getSrcLoc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00915">getInlinedClause()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00435">souffle::RemoveEmptyRelationsTransformer::removeEmptyRelationUses()</a>, <a class="el" href="_resolve_aliases_transformer_8cpp_source.html#l00339">souffle::ResolveAliasesTransformer::removeTrivialEquality()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00189">reorderAtoms()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l00516">souffle::RemoveBooleanConstraintsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                                              {</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="keyword">auto</span>* <a class="code" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f">clone</a> = <span class="keyword">new</span> AstClause();</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <a class="code" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f">clone</a>-&gt;setSrcLoc(clause-&gt;getSrcLoc());</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <a class="code" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f">clone</a>-&gt;setHead(std::unique_ptr&lt;AstAtom&gt;(clause-&gt;getHead()-&gt;clone()));</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    <span class="keywordflow">if</span> (clause-&gt;getExecutionPlan() != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <a class="code" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f">clone</a>-&gt;setExecutionPlan(std::unique_ptr&lt;AstExecutionPlan&gt;(clause-&gt;getExecutionPlan()-&gt;clone()));</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    }</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f">clone</a>;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a018886d19f141b1cb565199a517c598f"><div class="ttname"><a href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f">souffle::clone</a></div><div class="ttdeci">std::unique_ptr&lt; A &gt; clone(const A *node)</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00465">Util.h:465</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a6aa6d61f4a71ddbb2458d23ce24dbced_cgraph.png" border="0" usemap="#namespacesouffle_a6aa6d61f4a71ddbb2458d23ce24dbced_cgraph" alt=""/></div>
<map name="namespacesouffle_a6aa6d61f4a71ddbb2458d23ce24dbced_cgraph" id="namespacesouffle_a6aa6d61f4a71ddbb2458d23ce24dbced_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Create a clone (i.e. " alt="" coords="203,5,376,32"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="431,56,631,83"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_execution_plan.html#ac657ffa016ae777656585a56fc9a899c" title="Create a clone (i.e. " alt="" coords="196,107,383,149"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="235,173,344,200"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_clause.html#aa943423c45971e70c837da5b88c8fc04" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="218,225,361,266"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="220,290,359,331"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#acef18129b13ce45477044717ded051d2" title="souffle::AstAtom::AstAtom" alt="" coords="433,5,628,32"/>
</map>
</div>

</div>
</div>
<a id="a42c2f399b871f8fe7f0ba652812e2db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c2f399b871f8fe7f0ba652812e2db5">&#9670;&nbsp;</a></span>combineAggregators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a>* souffle::combineAggregators </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsouffle_1_1_ast_aggregator.html">AstAggregator</a> *&gt;&#160;</td>
          <td class="paramname"><em>aggrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a>&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00504">504</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_functor_ops_8h_source.html#l00098">isValidFunctorOpArity()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00477">renameVariables()</a>, and <a class="el" href="_resolve_aliases_transformer_8cpp_source.html#l00161">rhs</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00529">getInlinedArgument()</a>.</p>
<div class="fragment"><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                                                                                {</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    assert(<a class="code" href="namespacesouffle.html#a1193e67992e4f0591e4011faccb4abe2">isValidFunctorOpArity</a>(fun, 2) &amp;&amp; <span class="stringliteral">&quot;not a binary functor&quot;</span>);</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;    <span class="comment">// Due to variable scoping issues with aggregators, we rename all variables uniquely in the</span></div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    <span class="comment">// added aggregator</span></div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    <a class="code" href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961">renameVariables</a>(aggrs[0]);</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    <span class="keywordflow">if</span> (aggrs.size() == 1) {</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;        <span class="keywordflow">return</span> aggrs[0];</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;    }</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    AstArgument* <a class="code" href="_resolve_aliases_transformer_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a> = <a class="code" href="namespacesouffle.html#a42c2f399b871f8fe7f0ba652812e2db5">combineAggregators</a>(std::vector&lt;AstAggregator*&gt;(aggrs.begin() + 1, aggrs.end()), fun);</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;    AstArgument* result = <span class="keyword">new</span> AstIntrinsicFunctor(</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;            fun, std::unique_ptr&lt;AstArgument&gt;(aggrs[0]), std::unique_ptr&lt;AstArgument&gt;(rhs));</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    <span class="keywordflow">return</span> result;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a1193e67992e4f0591e4011faccb4abe2"><div class="ttname"><a href="namespacesouffle.html#a1193e67992e4f0591e4011faccb4abe2">souffle::isValidFunctorOpArity</a></div><div class="ttdeci">bool isValidFunctorOpArity(const FunctorOp op, const size_t arity)</div><div class="ttdoc">Checks whether a functor operation can have a given argument count. </div><div class="ttdef"><b>Definition:</b> <a href="_functor_ops_8h_source.html#l00098">FunctorOps.h:98</a></div></div>
<div class="ttc" id="_resolve_aliases_transformer_8cpp_html_a99d7476d0087a8405f52a79852efa6eb"><div class="ttname"><a href="_resolve_aliases_transformer_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; rhs</div><div class="ttdef"><b>Definition:</b> <a href="_resolve_aliases_transformer_8cpp_source.html#l00161">ResolveAliasesTransformer.cpp:161</a></div></div>
<div class="ttc" id="namespacesouffle_html_a42c2f399b871f8fe7f0ba652812e2db5"><div class="ttname"><a href="namespacesouffle.html#a42c2f399b871f8fe7f0ba652812e2db5">souffle::combineAggregators</a></div><div class="ttdeci">AstArgument * combineAggregators(std::vector&lt; AstAggregator *&gt; aggrs, FunctorOp fun)</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00504">InlineRelationsTransformer.cpp:504</a></div></div>
<div class="ttc" id="namespacesouffle_html_af790a6a39a388c256d64af7140f3a961"><div class="ttname"><a href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961">souffle::renameVariables</a></div><div class="ttdeci">void renameVariables(AstArgument *arg)</div><div class="ttdoc">Renames all variables in a given argument uniquely. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00477">InlineRelationsTransformer.cpp:477</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a42c2f399b871f8fe7f0ba652812e2db5_cgraph.png" border="0" usemap="#namespacesouffle_a42c2f399b871f8fe7f0ba652812e2db5_cgraph" alt=""/></div>
<map name="namespacesouffle_a42c2f399b871f8fe7f0ba652812e2db5_cgraph" id="namespacesouffle_a42c2f399b871f8fe7f0ba652812e2db5_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a1193e67992e4f0591e4011faccb4abe2" title="Checks whether a functor operation can have a given argument count. " alt="" coords="263,5,446,47"/>
<area shape="rect" id="node3" href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961" title="Renames all variables in a given argument uniquely. " alt="" coords="263,71,447,98"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#ad7c4f8ce0322749e72ed60f543c6fd93" title="Apply the mapper to all child nodes. " alt="" coords="495,71,668,98"/>
</map>
</div>

</div>
</div>
<a id="a0e3e2145b6ac09dba3c7ba2e5535935f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3e2145b6ac09dba3c7ba2e5535935f">&#9670;&nbsp;</a></span>combineNegatedLiterals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a>*&gt; &gt; souffle::combineNegatedLiterals </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *&gt;&gt;&#160;</td>
          <td class="paramname"><em>litGroups</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the negated version of a disjunction of conjunctions. </p>
<p>E.g. (a1(x) ^ a2(x) ^ ...) v (b1(x) ^ b2(x) ^ ...) &ndash;into-&gt; (!a1(x) ^ !b1(x)) v (!a2(x) ^ !b2(x)) v ... </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00366">366</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="json11_8h_source.html#l00651">i</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00345">negateLiteral()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00422">formNegatedLiterals()</a>.</p>
<div class="fragment"><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                                                     {</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    std::vector&lt;std::vector&lt;AstLiteral*&gt;&gt; negation;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    <span class="comment">// Corner case: !() = ()</span></div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="keywordflow">if</span> (litGroups.empty()) {</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        <span class="keywordflow">return</span> negation;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    }</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    std::vector&lt;AstLiteral*&gt; litGroup = litGroups[0];</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    <span class="keywordflow">if</span> (litGroups.size() == 1) {</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        <span class="comment">// !(a1 ^ a2 ^ a3 ^ ...) --into-&gt; !a1 v !a2 v !a3 v ...</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> : litGroup) {</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;            std::vector&lt;AstLiteral*&gt; newVec;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;            newVec.push_back(<a class="code" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d">negateLiteral</a>(<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>));</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;            negation.push_back(newVec);</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;        }</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        <span class="comment">// Done!</span></div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;        <span class="keywordflow">return</span> negation;</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    }</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    <span class="comment">// Produce the negated versions of all disjunctions ignoring the first recursively</span></div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    std::vector&lt;std::vector&lt;AstLiteral*&gt;&gt; combinedRHS = <a class="code" href="namespacesouffle.html#a0e3e2145b6ac09dba3c7ba2e5535935f">combineNegatedLiterals</a>(</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;            std::vector&lt;std::vector&lt;AstLiteral*&gt;&gt;(litGroups.begin() + 1, litGroups.end()));</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    <span class="comment">// We now just need to add the negation of a single literal from the untouched LHS</span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    <span class="comment">// to every single conjunction on the RHS to finalise creating every possible combination</span></div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    <span class="keywordflow">for</span> (AstLiteral* lhsLit : litGroup) {</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;        <span class="keywordflow">for</span> (std::vector&lt;AstLiteral*&gt; rhsVec : combinedRHS) {</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;            std::vector&lt;AstLiteral*&gt; newVec;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;            newVec.push_back(<a class="code" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d">negateLiteral</a>(lhsLit));</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;            <span class="keywordflow">for</span> (AstLiteral* lit : rhsVec) {</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                newVec.push_back(lit-&gt;clone());</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;            }</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;            negation.push_back(newVec);</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        }</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    }</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    <span class="keywordflow">for</span> (std::vector&lt;AstLiteral*&gt; rhsVec : combinedRHS) {</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;        <span class="keywordflow">for</span> (AstLiteral* lit : rhsVec) {</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;            <span class="keyword">delete</span> lit;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;        }</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    }</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    <span class="keywordflow">return</span> negation;</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a72ca390c0235d50be215fdc25bb24e4d"><div class="ttname"><a href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d">souffle::negateLiteral</a></div><div class="ttdeci">AstLiteral * negateLiteral(AstLiteral *lit)</div><div class="ttdoc">Returns the negated version of a given literal. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00345">InlineRelationsTransformer.cpp:345</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="namespacesouffle_html_a0e3e2145b6ac09dba3c7ba2e5535935f"><div class="ttname"><a href="namespacesouffle.html#a0e3e2145b6ac09dba3c7ba2e5535935f">souffle::combineNegatedLiterals</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; AstLiteral * &gt; &gt; combineNegatedLiterals(std::vector&lt; std::vector&lt; AstLiteral *&gt;&gt; litGroups)</div><div class="ttdoc">Return the negated version of a disjunction of conjunctions. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00366">InlineRelationsTransformer.cpp:366</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a0e3e2145b6ac09dba3c7ba2e5535935f_cgraph.png" border="0" usemap="#namespacesouffle_a0e3e2145b6ac09dba3c7ba2e5535935f_cgraph" alt=""/></div>
<map name="namespacesouffle_a0e3e2145b6ac09dba3c7ba2e5535935f_cgraph" id="namespacesouffle_a0e3e2145b6ac09dba3c7ba2e5535935f_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d" title="Returns the negated version of a given literal. " alt="" coords="287,89,447,116"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Create a clone (i.e. " alt="" coords="501,31,675,57"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_constraint.html#a4bc070302396ff2bee073f62c00b5e21" title="Create a clone (i.e. " alt="" coords="507,82,669,123"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a4a2b4fc7558b8bce98ff88f8e10b516e" title="Negate an ast constraint. " alt="" coords="495,148,681,175"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_atom.html#acef18129b13ce45477044717ded051d2" title="souffle::AstAtom::AstAtom" alt="" coords="738,5,933,32"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="735,56,935,83"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="729,148,941,175"/>
</map>
</div>

</div>
</div>
<a id="a97d640155c037c468924198354aae2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d640155c037c468924198354aae2ea">&#9670;&nbsp;</a></span>compileToBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::compileToBinary </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>compileCmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sourceFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles the given source file to a binary file. </p>

<p class="definition">Definition at line <a class="el" href="main_8cpp_source.html#l00098">98</a> of file <a class="el" href="main_8cpp_source.html">main.cpp</a>.</p>

<p class="reference">References <a class="el" href="_global_8h_source.html#l00135">souffle::Global::config()</a>, and <a class="el" href="_util_8h_source.html#l00908">splitString()</a>.</p>

<p class="reference">Referenced by <a class="el" href="main_8cpp_source.html#l00124">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                                                                            {</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="comment">// add source code</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    compileCmd += <span class="charliteral">&#39; &#39;</span>;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::string&amp; path : <a class="code" href="namespacesouffle.html#a673608e9453179d30f6607384f54463a">splitString</a>(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;library-dir&quot;</span>), <span class="charliteral">&#39; &#39;</span>)) {</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <span class="comment">// The first entry may be blank</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        <span class="keywordflow">if</span> (path.empty()) {</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        }</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        compileCmd += <span class="stringliteral">&quot;-L&quot;</span> + path + <span class="charliteral">&#39; &#39;</span>;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    }</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::string&amp; library : <a class="code" href="namespacesouffle.html#a673608e9453179d30f6607384f54463a">splitString</a>(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;libraries&quot;</span>), <span class="charliteral">&#39; &#39;</span>)) {</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        <span class="comment">// The first entry may be blank</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        <span class="keywordflow">if</span> (library.empty()) {</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        }</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        compileCmd += <span class="stringliteral">&quot;-l&quot;</span> + library + <span class="charliteral">&#39; &#39;</span>;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    }</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    compileCmd += sourceFilename;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <span class="comment">// run executable</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <span class="keywordflow">if</span> (system(compileCmd.c_str()) != 0) {</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;failed to compile C++ source &lt;&quot;</span> + sourceFilename + <span class="stringliteral">&quot;&gt;&quot;</span>);</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    }</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a673608e9453179d30f6607384f54463a"><div class="ttname"><a href="namespacesouffle.html#a673608e9453179d30f6607384f54463a">souffle::splitString</a></div><div class="ttdeci">std::vector&lt; std::string &gt; splitString(const std::string &amp;str, char delimiter)</div><div class="ttdoc">Splits a string given a delimiter. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00908">Util.h:908</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a97d640155c037c468924198354aae2ea_cgraph.png" border="0" usemap="#namespacesouffle_a97d640155c037c468924198354aae2ea_cgraph" alt=""/></div>
<map name="namespacesouffle_a97d640155c037c468924198354aae2ea_cgraph" id="namespacesouffle_a97d640155c037c468924198354aae2ea_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_global.html#a2dcb257b0f98d0b882862427cc965640" title="souffle::Global::config" alt="" coords="236,5,399,32"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a673608e9453179d30f6607384f54463a" title="Splits a string given a delimiter. " alt="" coords="247,56,387,83"/>
</map>
</div>

</div>
</div>
<a id="a8a825f62e860ca448e7e16ab1a3a4333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a825f62e860ca448e7e16ab1a3a4333">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::contains </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="classsouffle_1_1_adorned_predicate.html">AdornedPredicate</a> &gt;&#160;</td>
          <td class="paramname"><em>adornedPredicates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>atomName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>atomAdornment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00046">46</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_magic_set_8cpp_source.html#l00040">isEqualAdornment()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00297">addBackwardDependencies()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00337">addForwardDependencies()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00370">addIgnoredRelations()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00629">souffle::AstSemanticChecker::checkClause()</a>, <a class="el" href="_b_tree_8h_source.html#l01723">souffle::detail::btree&lt; Key, Comparator, Allocator, blockSize, SearchStrategy, true, WeakComparator, Updater &gt;::contains()</a>, <a class="el" href="_brie_8h_source.html#l02501">souffle::Trie&lt; Arity &gt;::contains()</a>, <a class="el" href="_brie_8h_source.html#l02912">souffle::Trie&lt; 1u &gt;::contains()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l01447">souffle::FoldAnonymousRecords::containsValidRecordConstraint()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00074">souffle::ExplainProvenanceImpl::explain()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00327">souffle::ExplainProvenanceImpl::explainNegation()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00261">souffle::ExplainProvenanceImpl::explainNegationGetVariables()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00511">getNextAtomMaxBoundSIPS()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00470">getNextAtomNaiveSIPS()</a>, <a class="el" href="_b_tree_8h_source.html#l00531">souffle::detail::btree&lt; Key, Comparator, Allocator, blockSize, SearchStrategy, isSet, WeakComparator, Updater &gt;::node::getSplitPoint()</a>, <a class="el" href="_write_stream_c_s_v_8h_source.html#l00182">souffle::WriteFileCSVFactory::getWriter()</a>, <a class="el" href="_b_tree_8h_source.html#l00728">souffle::detail::btree&lt; Key, Comparator, Allocator, blockSize, SearchStrategy, isSet, WeakComparator, Updater &gt;::node::grow_parent()</a>, <a class="el" href="_b_tree_8h_source.html#l00778">souffle::detail::btree&lt; Key, Comparator, Allocator, blockSize, SearchStrategy, isSet, WeakComparator, Updater &gt;::node::insert_inner()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00115">isBoundArgument()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00090">isBoundComposite()</a>, <a class="el" href="_b_tree_8h_source.html#l01960">souffle::detail::btree&lt; Key, Comparator, Allocator, blockSize, SearchStrategy, true, WeakComparator, Updater &gt;::operator==()</a>, <a class="el" href="_b_tree_8h_source.html#l00615">souffle::detail::btree&lt; Key, Comparator, Allocator, blockSize, SearchStrategy, isSet, WeakComparator, Updater &gt;::node::rebalance_or_split()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00695">souffle::Adornment::run()</a>, <a class="el" href="_b_tree_8h_source.html#l00550">souffle::detail::btree&lt; Key, Comparator, Allocator, blockSize, SearchStrategy, isSet, WeakComparator, Updater &gt;::node::split()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;                                        {</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <span class="keywordflow">for</span> (AdornedPredicate seenPred : adornedPredicates) {</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#aae135d2382a133fa5b036296fbd7f60a">isEqualAdornment</a>(seenPred.getQualifiedName(), seenPred.getAdornment(), atomName, atomAdornment)) {</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        }</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    }</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_aae135d2382a133fa5b036296fbd7f60a"><div class="ttname"><a href="namespacesouffle.html#aae135d2382a133fa5b036296fbd7f60a">souffle::isEqualAdornment</a></div><div class="ttdeci">bool isEqualAdornment(const AstQualifiedName &amp;pred1, const std::string &amp;adorn1, const AstQualifiedName &amp;pred2, const std::string &amp;adorn2)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00040">MagicSet.cpp:40</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8a825f62e860ca448e7e16ab1a3a4333_cgraph.png" border="0" usemap="#namespacesouffle_a8a825f62e860ca448e7e16ab1a3a4333_cgraph" alt=""/></div>
<map name="namespacesouffle_a8a825f62e860ca448e7e16ab1a3a4333_cgraph" id="namespacesouffle_a8a825f62e860ca448e7e16ab1a3a4333_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#aae135d2382a133fa5b036296fbd7f60a" title="souffle::isEqualAdornment" alt="" coords="183,5,376,32"/>
</map>
</div>

</div>
</div>
<a id="af3295dd83a588d612cf777e600beac4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3295dd83a588d612cf777e600beac4a">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::contains </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename C::value_type &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility to check generically whether a given element is contained in a given container. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00298">298</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                                                                       {</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    <span class="keywordflow">return</span> std::find(container.begin(), container.end(), element) != container.end();</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aad2a6a041cccb09653b996dbeed7b4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2a6a041cccb09653b996dbeed7b4fd">&#9670;&nbsp;</a></span>contains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::contains </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename C::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version of contains specialized for maps. </p>
<p>This workaround is needed because of set container, for which value_type == key_type, which is ambiguous in this context. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00309">309</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                                                                                 {</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    <span class="keywordflow">return</span> container.find(element) != container.end();</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aeeb4465d8c07d802fb161440e0399ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb4465d8c07d802fb161440e0399ee1">&#9670;&nbsp;</a></span>containsAggregators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::containsAggregators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td>
          <td class="paramname"><em>clause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00164">164</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00695">souffle::Adornment::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                                            {</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    <span class="comment">// check for aggregators</span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(*clause, [&amp;](<span class="keyword">const</span> AstAggregator&amp;) { found = <span class="keyword">true</span>; });</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="keywordflow">return</span> found;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aeeb4465d8c07d802fb161440e0399ee1_cgraph.png" border="0" usemap="#namespacesouffle_aeeb4465d8c07d802fb161440e0399ee1_cgraph" alt=""/></div>
<map name="namespacesouffle_aeeb4465d8c07d802fb161440e0399ee1_cgraph" id="namespacesouffle_aeeb4465d8c07d802fb161440e0399ee1_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="261,13,429,39"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="477,5,645,47"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="693,5,884,47"/>
</map>
</div>

</div>
</div>
<a id="af48d6e1a779132e5412105fc9cfb85ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48d6e1a779132e5412105fc9cfb85ed">&#9670;&nbsp;</a></span>containsInlinedAtom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::containsInlinedAtom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given clause contains an atom that should be inlined. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00176">176</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_literal_8h_source.html#l00058">souffle::AstAtom::getQualifiedName()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00056">getRelation()</a>, <a class="el" href="_ast_relation_8h_source.html#l00103">souffle::AstRelation::hasQualifier()</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">INLINE</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l01006">souffle::InlineRelationsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                                                                             {</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    <span class="keywordtype">bool</span> foundInlinedAtom = <span class="keyword">false</span>;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(clause, [&amp;](<span class="keyword">const</span> AstAtom&amp; atom) {</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        AstRelation* rel = <a class="code" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">getRelation</a>(program, atom.getQualifiedName());</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;        <span class="keywordflow">if</span> (rel-&gt;hasQualifier(RelationQualifier::INLINE)) {</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;            foundInlinedAtom = <span class="keyword">true</span>;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        }</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    });</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="keywordflow">return</span> foundInlinedAtom;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
<div class="ttc" id="namespacesouffle_html_ada252aa15afbf7d703a11b000dfd4048"><div class="ttname"><a href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">souffle::getRelation</a></div><div class="ttdeci">AstRelation * getRelation(const AstProgram &amp;program, const AstQualifiedName &amp;name)</div><div class="ttdoc">Returns the relation with the given name in the program. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00056">AstUtils.cpp:56</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_af48d6e1a779132e5412105fc9cfb85ed_cgraph.png" border="0" usemap="#namespacesouffle_af48d6e1a779132e5412105fc9cfb85ed_cgraph" alt=""/></div>
<map name="namespacesouffle_af48d6e1a779132e5412105fc9cfb85ed_cgraph" id="namespacesouffle_af48d6e1a779132e5412105fc9cfb85ed_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="261,5,517,32"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="315,56,463,83"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_relation.html#a698481c4da3f71880cb2cf8c622a9cdc" title="check for a relation qualifier " alt="" coords="315,107,463,149"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="305,173,473,200"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="597,24,701,51"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="574,75,725,117"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="803,83,950,109"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="565,166,733,207"/>
<area shape="rect" id="node10" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="781,166,972,207"/>
</map>
</div>

</div>
</div>
<a id="a2d035bffae77e02ed7a0cc029653e64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d035bffae77e02ed7a0cc029653e64d">&#9670;&nbsp;</a></span>convertOverloadedAggregator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">AggregateOp</a> souffle::convertOverloadedAggregator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">AggregateOp</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert aggregator to a give type. </p>
<p>Eg. sum, float → fsum. </p>

<p class="definition">Definition at line <a class="el" href="_aggregate_op_8h_source.html#l00085">85</a> of file <a class="el" href="_aggregate_op_8h_source.html">AggregateOp.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a22ae0e2b89e5e3d477f988cc36d3272b">Float</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1">FMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6">FMIN</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a0645fcc11b74dbdbf2d7501942fa6f6f">FSUM</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">MAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">MIN</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a6970bdc2201030b9c03fbdcf3973858a">SUM</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059">UMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb">UMIN</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0aa1a914735b205424ba6c40b85528d78a">Unsigned</a>, and <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ae6246115490f016a4ecb2604ba5fc2ed">USUM</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_transforms_8cpp_source.html#l01253">souffle::PolymorphicObjectsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                                                                                               {</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keywordflow">switch</span> (op) {</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        <span class="keywordflow">case</span> AggregateOp::SUM:</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            <span class="keywordflow">if</span> (type == TypeAttribute::Float) {</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;                <span class="keywordflow">return</span> AggregateOp::FSUM;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == TypeAttribute::Unsigned) {</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;                <span class="keywordflow">return</span> AggregateOp::USUM;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;                assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Invalid argument;&quot;</span>);</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;            }</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        <span class="keywordflow">case</span> AggregateOp::MAX:</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;            <span class="keywordflow">if</span> (type == TypeAttribute::Float) {</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                <span class="keywordflow">return</span> AggregateOp::FMAX;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == TypeAttribute::Unsigned) {</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                <span class="keywordflow">return</span> AggregateOp::UMAX;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Invalid argument;&quot;</span>);</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            }</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        <span class="keywordflow">case</span> AggregateOp::MIN:</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;            <span class="keywordflow">if</span> (type == TypeAttribute::Float) {</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                <span class="keywordflow">return</span> AggregateOp::FMIN;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == TypeAttribute::Unsigned) {</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                <span class="keywordflow">return</span> AggregateOp::UMIN;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Invalid argument;&quot;</span>);</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;            }</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;            assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Invalid argument&quot;</span>);</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    }</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab55155cf1bff3a08e76b26290a08c9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55155cf1bff3a08e76b26290a08c9d3">&#9670;&nbsp;</a></span>convertOverloadedConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> souffle::convertOverloadedConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a>&#160;</td>
          <td class="paramname"><em>constraintOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a>&#160;</td>
          <td class="paramname"><em>toType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <a class="el" href="classsouffle_1_1_constraint.html" title="A generic base class for constraints on variables. ">Constraint</a> to work with requested type. </p>
<p>Example: constraintOp = LT, toType = Float -&gt; FLT (less-than working on floats). </p>

<p class="definition">Definition at line <a class="el" href="_binary_constraint_ops_8h_source.html#l00095">95</a> of file <a class="el" href="_binary_constraint_ops_8h_source.html">BinaryConstraintOps.h</a>.</p>

<p class="reference">References <a class="el" href="_binary_constraint_ops_8h.html#a8d79a3fde7687f59e8c1393642840984">COMPARE_CONSTRAINT</a>, <a class="el" href="_binary_constraint_ops_8h.html#ad97c03b516d96cba774e128b8b654237">COMPARE_CONSTRAINT_FLOAT_OR_RAW</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">GE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">GT</a>, <a class="el" href="_binary_constraint_ops_8h_source.html#l00076">isOverloaded()</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">LE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">LT</a>, and <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">NE</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_transforms_8cpp_source.html#l01253">souffle::PolymorphicObjectsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                                                                           {</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="keyword">auto</span> FAIL = [&amp;]() -&gt; <a class="code" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> {</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid binary constraint overload: &quot;</span> &lt;&lt; int(constraintOp) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; int(toType);</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;invalid binary constraint overload&quot;</span>);</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        exit(EXIT_FAILURE);</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    };</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="comment">// clang-format off</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="preprocessor">#define COMPARE_CONSTRAINT_FLOAT_OR_RAW(op)                             \</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="preprocessor">    case BinaryConstraintOp::op:                                        \</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="preprocessor">        switch (toType) {                                               \</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="preprocessor">        default                     : return BinaryConstraintOp::   op; \</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="preprocessor">        case TypeAttribute::Float   : return BinaryConstraintOp::F##op; \</span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="preprocessor">        }</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="preprocessor">#define COMPARE_CONSTRAINT(op)                                          \</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="preprocessor">    case BinaryConstraintOp::op:                                        \</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="preprocessor">        switch (toType) {                                               \</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="preprocessor">        case TypeAttribute::Signed  : return BinaryConstraintOp::   op; \</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="preprocessor">        case TypeAttribute::Unsigned: return BinaryConstraintOp::U##op; \</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="preprocessor">        case TypeAttribute::Float   : return BinaryConstraintOp::F##op; \</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="preprocessor">        case TypeAttribute::Symbol  : return BinaryConstraintOp::S##op; \</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="preprocessor">        case TypeAttribute::Record  : return FAIL();                    \</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="preprocessor">        }                                                               \</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="preprocessor">        assert(false &amp;&amp; &quot;unhandled TypeAttr&quot;);                          \</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="preprocessor">        break; </span><span class="comment">/* HACK: GCC-9 is incorrectly reporting a case fallthru */</span><span class="preprocessor"></span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="comment">// clang-format on</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="keywordflow">switch</span> (constraintOp) {</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        <a class="code" href="_binary_constraint_ops_8h.html#ad97c03b516d96cba774e128b8b654237">COMPARE_CONSTRAINT_FLOAT_OR_RAW</a>(EQ)</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        <a class="code" href="_binary_constraint_ops_8h.html#ad97c03b516d96cba774e128b8b654237">COMPARE_CONSTRAINT_FLOAT_OR_RAW</a>(NE)</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        <a class="code" href="_binary_constraint_ops_8h.html#a8d79a3fde7687f59e8c1393642840984">COMPARE_CONSTRAINT</a>(LT)</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        <a class="code" href="_binary_constraint_ops_8h.html#a8d79a3fde7687f59e8c1393642840984">COMPARE_CONSTRAINT</a>(LE)</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <a class="code" href="_binary_constraint_ops_8h.html#a8d79a3fde7687f59e8c1393642840984">COMPARE_CONSTRAINT</a>(GT)</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        <a class="code" href="_binary_constraint_ops_8h.html#a8d79a3fde7687f59e8c1393642840984">COMPARE_CONSTRAINT</a>(GE)</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;            assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Invalid constraint conversion&quot;</span>);</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    }</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="preprocessor">#undef COMPARE_CONSTRAINT_FLOAT_OR_RAW</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="preprocessor">#undef COMPARE_CONSTRAINT</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    assert(<a class="code" href="namespacesouffle.html#acf7ac56e1539b5fc646d3822edf00bc2">isOverloaded</a>(constraintOp) &amp;&amp; <span class="stringliteral">&quot;missing handler for overloadable constraint op&quot;</span>);</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    assert(!<a class="code" href="namespacesouffle.html#acf7ac56e1539b5fc646d3822edf00bc2">isOverloaded</a>(constraintOp) &amp;&amp; <span class="stringliteral">&quot;can&#39;t overload this binary op&quot;</span>);</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    exit(EXIT_FAILURE);</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;}</div><div class="ttc" id="_binary_constraint_ops_8h_html_ad97c03b516d96cba774e128b8b654237"><div class="ttname"><a href="_binary_constraint_ops_8h.html#ad97c03b516d96cba774e128b8b654237">COMPARE_CONSTRAINT_FLOAT_OR_RAW</a></div><div class="ttdeci">#define COMPARE_CONSTRAINT_FLOAT_OR_RAW(op)</div></div>
<div class="ttc" id="namespacesouffle_html_acf7ac56e1539b5fc646d3822edf00bc2"><div class="ttname"><a href="namespacesouffle.html#acf7ac56e1539b5fc646d3822edf00bc2">souffle::isOverloaded</a></div><div class="ttdeci">bool isOverloaded(const BinaryConstraintOp constraintOp)</div><div class="ttdoc">Utility function, informing whether constraint is overloaded. </div><div class="ttdef"><b>Definition:</b> <a href="_binary_constraint_ops_8h_source.html#l00076">BinaryConstraintOps.h:76</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac460f7c8b5ab0da53316d6bb32a19f49"><div class="ttname"><a href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">souffle::BinaryConstraintOp</a></div><div class="ttdeci">BinaryConstraintOp</div><div class="ttdoc">Binary Constraint Operators. </div><div class="ttdef"><b>Definition:</b> <a href="_binary_constraint_ops_8h_source.html#l00034">BinaryConstraintOps.h:34</a></div></div>
<div class="ttc" id="_binary_constraint_ops_8h_html_a8d79a3fde7687f59e8c1393642840984"><div class="ttname"><a href="_binary_constraint_ops_8h.html#a8d79a3fde7687f59e8c1393642840984">COMPARE_CONSTRAINT</a></div><div class="ttdeci">#define COMPARE_CONSTRAINT(op)</div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ab55155cf1bff3a08e76b26290a08c9d3_cgraph.png" border="0" usemap="#namespacesouffle_ab55155cf1bff3a08e76b26290a08c9d3_cgraph" alt=""/></div>
<map name="namespacesouffle_ab55155cf1bff3a08e76b26290a08c9d3_cgraph" id="namespacesouffle_ab55155cf1bff3a08e76b26290a08c9d3_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#acf7ac56e1539b5fc646d3822edf00bc2" title="Utility function, informing whether constraint is overloaded. " alt="" coords="252,13,412,39"/>
</map>
</div>

</div>
</div>
<a id="a5fbbaeea6848aa8448ccc59a7e404aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbbaeea6848aa8448ccc59a7e404aeb">&#9670;&nbsp;</a></span>convertOverloadedFunctor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a> souffle::convertOverloadedFunctor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a>&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a>&#160;</td>
          <td class="paramname"><em>toType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an overloaded functor, so that it works with the requested type. </p>
<p>Example: toType = Float, functor = PLUS -&gt; FPLUS (version of plus working on floats) </p>

<p class="definition">Definition at line <a class="el" href="_functor_ops_8h_source.html#l00493">493</a> of file <a class="el" href="_functor_ops_8h_source.html">FunctorOps.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9eeb52badb613229884838847294b90d">ADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aa8a5bbeedca093b94b7f0d3f185b98f7">BAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0fd78279a775c262180e0cfbad6fa9eb">BNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0adf6aac232504c55ea4202e09498bfd">BOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a88d973d6a866ababf2fb28a6112f8d46">BSHIFT_L</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9e74511ce5c138f374559a76abb6e209">BSHIFT_R</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a21506bac4ecfbfe4272b9bf8185446b6">BXOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a29bbf66f7f8529ec47e394fb5a36c646">DIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc2cbacfa7c4ef9bc72773ebdd9fe166">FADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9abccb2b7436e0cbfb334fe07304fe28a6">FDIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a107c7a3cc48a0fe27d435e82c8679ef0">FEXP</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a22ae0e2b89e5e3d477f988cc36d3272b">Float</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1">FMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6">FMIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a26a83f923754f1e7aa12640b8bcca29a">FMUL</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a36da8d8fdce0e080abfcab7af41066c6">FNEG</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a06be1058e817f781f4e0f0641f436247">FSUB</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a479a809c0b6eaaefd3b1df16f976df06">LAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a81145009eec44ad2c399c9459a01d8f0">LNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ad3335c358811cfc353257e21b1d38229">LOR</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">MAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">MIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac5a28f4b35a2884fa3277150ac5d0967">MOD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2cdf52a55876063ec93b7d18bc741f6c">MUL</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a5dd68b1a7db42a1cce4dce09dbaa179e">NEG</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a00e365acdc6de6b62421116e865bd420">SMAX</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2d9174ad446fde0fc750265f9e075977">SMIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a241dd841abade20fcb27b8a9f494e1eb">SUB</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a02c86eb2792f3262c21d030a87e19793">Symbol</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a1f0002abde2c29615d914ab0228c68d3">UADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ab5755f546c5f5ca6a3f1720ef8e642ef">UBAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac2fc8ad7a275c06c870529f9f9f07caa">UBNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4803dabeb7190f48195a26654eafaa42">UBOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a653789f2eb8bfa402c5f60ceceac247b">UBSHIFT_L</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aab623d5679ac1cc907cb363e2d51eb14">UBSHIFT_R</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a70f4367aed9601f37bfbdd4586b327df">UBXOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a56d5c96c848631ef14e1f2a6e0f15d49">UDIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a59407eef1229dea3aac5dc8d77d06c92">UEXP</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3d0f34d8e784f8a48332424dd598a27a">ULAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a7fdc4b2848234d42fe9a22b78fd68910">ULNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9addb2113545b6bd7fbe64ed7bff507964">ULOR</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059">UMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb">UMIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4bbe00e945b01d43cb7edecf51b0de5c">UMOD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ae89690f1278cca1400678daaa4a6a3b7">UMUL</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0aa1a914735b205424ba6c40b85528d78a">Unsigned</a>, and <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9af8aba91736be4bad67181a8cce032337">USUB</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_transforms_8cpp_source.html#l01253">souffle::PolymorphicObjectsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;                                                                                               {</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    <span class="keywordflow">switch</span> (functor) {</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;        <span class="keywordflow">case</span> FunctorOp::NEG:</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;            assert(toType == TypeAttribute::Float &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion from NEG&quot;</span>);</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;            <span class="keywordflow">return</span> FunctorOp::FNEG;</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BNOT:</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            assert(toType == TypeAttribute::Unsigned &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion from UBNOT&quot;</span>);</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;            <span class="keywordflow">return</span> FunctorOp::UBNOT;</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LNOT:</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;            assert(toType == TypeAttribute::Unsigned &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion from LNOT&quot;</span>);</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;            <span class="keywordflow">return</span> FunctorOp::ULNOT;</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        <span class="comment">/* Binary */</span></div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ADD:</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;            <span class="keywordflow">if</span> (toType == TypeAttribute::Float) {</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;                <span class="keywordflow">return</span> FunctorOp::FADD;</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (toType == TypeAttribute::Unsigned) {</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;                <span class="keywordflow">return</span> FunctorOp::UADD;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;            }</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;            assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion&quot;</span>);</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SUB:</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;            <span class="keywordflow">if</span> (toType == TypeAttribute::Float) {</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;                <span class="keywordflow">return</span> FunctorOp::FSUB;</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (toType == TypeAttribute::Unsigned) {</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;                <span class="keywordflow">return</span> FunctorOp::USUB;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;            }</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;            assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion&quot;</span>);</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MUL:</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;            <span class="keywordflow">if</span> (toType == TypeAttribute::Float) {</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;                <span class="keywordflow">return</span> FunctorOp::FMUL;</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (toType == TypeAttribute::Unsigned) {</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;                <span class="keywordflow">return</span> FunctorOp::UMUL;</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;            }</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;            assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion&quot;</span>);</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;        <span class="keywordflow">case</span> FunctorOp::DIV:</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;            <span class="keywordflow">if</span> (toType == TypeAttribute::Float) {</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;                <span class="keywordflow">return</span> FunctorOp::FDIV;</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (toType == TypeAttribute::Unsigned) {</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;                <span class="keywordflow">return</span> FunctorOp::UDIV;</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;            }</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;            assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion&quot;</span>);</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;        <span class="keywordflow">case</span> FunctorOp::EXP:</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;            <span class="keywordflow">if</span> (toType == TypeAttribute::Float) {</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;                <span class="keywordflow">return</span> FunctorOp::FEXP;</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (toType == TypeAttribute::Unsigned) {</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;                <span class="keywordflow">return</span> FunctorOp::UEXP;</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;            }</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;            assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion&quot;</span>);</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MAX:</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;            <span class="keywordflow">if</span> (toType == TypeAttribute::Float) {</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;                <span class="keywordflow">return</span> FunctorOp::FMAX;</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (toType == TypeAttribute::Unsigned) {</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;                <span class="keywordflow">return</span> FunctorOp::UMAX;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (toType == TypeAttribute::Symbol) {</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;                <span class="keywordflow">return</span> FunctorOp::SMAX;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;            }</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;            assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion&quot;</span>);</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MIN:</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;            <span class="keywordflow">if</span> (toType == TypeAttribute::Float) {</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;                <span class="keywordflow">return</span> FunctorOp::FMIN;</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (toType == TypeAttribute::Unsigned) {</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;                <span class="keywordflow">return</span> FunctorOp::UMIN;</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (toType == TypeAttribute::Symbol) {</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;                <span class="keywordflow">return</span> FunctorOp::SMIN;</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;            }</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;            assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion&quot;</span>);</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BAND:</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;            assert(toType == TypeAttribute::Unsigned &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion&quot;</span>);</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;            <span class="keywordflow">return</span> FunctorOp::UBAND;</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BOR:</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;            assert(toType == TypeAttribute::Unsigned &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion&quot;</span>);</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;            <span class="keywordflow">return</span> FunctorOp::UBOR;</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BXOR:</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;            assert(toType == TypeAttribute::Unsigned &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion&quot;</span>);</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;            <span class="keywordflow">return</span> FunctorOp::UBXOR;</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_L:</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;            assert(toType == TypeAttribute::Unsigned &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion&quot;</span>);</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;            <span class="keywordflow">return</span> FunctorOp::UBSHIFT_L;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_R:</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;            assert(toType == TypeAttribute::Unsigned &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion&quot;</span>);</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;            <span class="keywordflow">return</span> FunctorOp::UBSHIFT_R;</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LAND:</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;            assert(toType == TypeAttribute::Unsigned &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion&quot;</span>);</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;            <span class="keywordflow">return</span> FunctorOp::ULAND;</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LOR:</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;            assert(toType == TypeAttribute::Unsigned &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion&quot;</span>);</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;            <span class="keywordflow">return</span> FunctorOp::ULOR;</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MOD:</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;            assert(toType == TypeAttribute::Unsigned &amp;&amp; <span class="stringliteral">&quot;Invalid functor conversion&quot;</span>);</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;            <span class="keywordflow">return</span> FunctorOp::UMOD;</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;            assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Invalid functor&quot;</span>);</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;    }</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a63b1cbb15ab5fafb19d94e2ad5199973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b1cbb15ab5fafb19d94e2ad5199973">&#9670;&nbsp;</a></span>createAdornedIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> souffle::createAdornedIdentifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>relationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>adornment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00246">246</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_qualified_name_8h_source.html#l00046">souffle::AstQualifiedName::append()</a>, <a class="el" href="_ast_qualified_name_8h_source.html#l00061">souffle::AstQualifiedName::getQualifiers()</a>, and <a class="el" href="json11_8h_source.html#l00651">i</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                                                                                                           {</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    std::vector&lt;std::string&gt; relationNames = relationName.getQualifiers();</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    <span class="comment">// change the base name</span></div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    std::stringstream newMainName;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    newMainName.str(<span class="stringliteral">&quot;&quot;</span>);</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    <span class="comment">// add a &#39;+&#39; to avoid name conflict</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    newMainName &lt;&lt; relationNames[0] &lt;&lt; <span class="stringliteral">&quot;+_&quot;</span> &lt;&lt; adornment;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    AstQualifiedName newRelationName(newMainName.str());</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    <span class="comment">// add in the other names</span></div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 1; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; relationNames.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        newRelationName.append(relationNames[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>]);</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    }</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    <span class="keywordflow">return</span> newRelationName;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a63b1cbb15ab5fafb19d94e2ad5199973_cgraph.png" border="0" usemap="#namespacesouffle_a63b1cbb15ab5fafb19d94e2ad5199973_cgraph" alt=""/></div>
<map name="namespacesouffle_a63b1cbb15ab5fafb19d94e2ad5199973_cgraph" id="namespacesouffle_a63b1cbb15ab5fafb19d94e2ad5199973_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_qualified_name.html#a6341a67891b6d0174b92264eb4dc5d43" title="append qualifiers " alt="" coords="280,5,472,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_qualified_name.html#a4b36798d8506689de4ec2794f4777bfa" title="get qualifiers " alt="" coords="280,71,472,112"/>
</map>
</div>

</div>
</div>
<a id="a42eef65f1512c8189dc19ae26f200acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42eef65f1512c8189dc19ae26f200acc">&#9670;&nbsp;</a></span>createAnnotatedClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a>* souffle::createAnnotatedClause </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *, <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &gt;&#160;</td>
          <td class="paramname"><em>argumentTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ast_type_analysis_8cpp_source.html#l00416">416</a> of file <a class="el" href="_ast_type_analysis_8cpp_source.html">AstTypeAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_clause_8h_source.html#l00203">souffle::AstClause::apply()</a>, <a class="el" href="_ast_clause_8h_source.html#l00190">souffle::AstClause::clone()</a>, <a class="el" href="json11_8h_source.html#l00651">i</a>, <a class="el" href="_component_instantiation_transformer_8cpp_source.html#l00046">types</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_type_analysis_8cpp_source.html#l00479">souffle::TypeAnalysis::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;                                                                                          {</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    <span class="comment">// Annotates each variable with its type based on a given type analysis result</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    <span class="keyword">struct </span>TypeAnnotator : <span class="keyword">public</span> AstNodeMapper {</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        <span class="keyword">const</span> std::map&lt;const AstArgument*, TypeSet&gt;&amp; <a class="code" href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        TypeAnnotator(<span class="keyword">const</span> std::map&lt;const AstArgument*, TypeSet&gt;&amp; types) : types(types) {}</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;        std::unique_ptr&lt;AstNode&gt; operator()(std::unique_ptr&lt;AstNode&gt; node)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">auto</span>* var = dynamic_cast&lt;AstVariable*&gt;(node.get())) {</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;                std::stringstream newVarName;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;                newVarName &lt;&lt; var-&gt;getName() &lt;&lt; <span class="stringliteral">&quot;&amp;isin;&quot;</span> &lt;&lt; types.find(var)-&gt;second;</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;                <span class="keywordflow">return</span> std::make_unique&lt;AstVariable&gt;(newVarName.str());</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span>* var = dynamic_cast&lt;AstUnnamedVariable*&gt;(node.get())) {</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;                std::stringstream newVarName;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;                newVarName &lt;&lt; <span class="stringliteral">&quot;_&quot;</span></div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;                           &lt;&lt; <span class="stringliteral">&quot;&amp;isin;&quot;</span> &lt;&lt; types.find(var)-&gt;second;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;                <span class="keywordflow">return</span> std::make_unique&lt;AstVariable&gt;(newVarName.str());</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;            }</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;            <span class="keywordflow">return</span> node;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;        }</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    };</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;    <span class="comment">/* Note:</span></div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;<span class="comment">     * Because the type of each argument is stored in the form [address -&gt; type-set],</span></div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;<span class="comment">     * the type-analysis result does not immediately apply to the clone due to differing</span></div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="comment">     * addresses.</span></div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;<span class="comment">     * Two ways around this:</span></div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<span class="comment">     *  (1) Perform the type-analysis again for the cloned clause</span></div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;<span class="comment">     *  (2) Keep track of the addresses of equivalent arguments in the cloned clause</span></div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;<span class="comment">     * Method (2) was chosen to avoid having to recompute the analysis each time.</span></div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    AstClause* annotatedClause = clause-&gt;clone();</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    <span class="comment">// Maps x -&gt; y, where x is the address of an argument in the original clause, and y</span></div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    <span class="comment">// is the address of the equivalent argument in the clone.</span></div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    std::map&lt;const AstArgument*, const AstArgument*&gt; memoryMap;</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    std::vector&lt;const AstArgument*&gt; originalAddresses;</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(*clause, [&amp;](<span class="keyword">const</span> AstArgument&amp; arg) { originalAddresses.push_back(&amp;arg); });</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    std::vector&lt;const AstArgument*&gt; cloneAddresses;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(*annotatedClause, [&amp;](<span class="keyword">const</span> AstArgument&amp; arg) { cloneAddresses.push_back(&amp;arg); });</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    assert(cloneAddresses.size() == originalAddresses.size());</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; originalAddresses.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;        memoryMap[originalAddresses[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>]] = cloneAddresses[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    }</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    <span class="comment">// Map the types to the clause clone</span></div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    std::map&lt;const AstArgument*, TypeSet&gt; cloneArgumentTypes;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; pair : argumentTypes) {</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;        cloneArgumentTypes[memoryMap[pair.first]] = pair.second;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    }</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    <span class="comment">// Create the type-annotated clause</span></div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    TypeAnnotator annotator(cloneArgumentTypes);</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    annotatedClause-&gt;apply(annotator);</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    <span class="keywordflow">return</span> annotatedClause;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;}</div><div class="ttc" id="_component_instantiation_transformer_8cpp_html_a769811c621f0af455fbefd863c0f1a0c"><div class="ttname"><a href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a></div><div class="ttdeci">std::vector&lt; std::unique_ptr&lt; AstType &gt; &gt; types</div><div class="ttdef"><b>Definition:</b> <a href="_component_instantiation_transformer_8cpp_source.html#l00046">ComponentInstantiationTransformer.cpp:46</a></div></div>
<div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a42eef65f1512c8189dc19ae26f200acc_cgraph.png" border="0" usemap="#namespacesouffle_a42eef65f1512c8189dc19ae26f200acc_cgraph" alt=""/></div>
<map name="namespacesouffle_a42eef65f1512c8189dc19ae26f200acc_cgraph" id="namespacesouffle_a42eef65f1512c8189dc19ae26f200acc_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_clause.html#ab7a5b630d02cd69873aab066c2bd9c46" title="Apply the mapper to all child nodes. " alt="" coords="251,5,389,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Create a clone (i.e. " alt="" coords="251,71,389,112"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="236,137,404,163"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="452,27,652,54"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="497,78,607,105"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="468,129,636,171"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="700,129,891,171"/>
</map>
</div>

</div>
</div>
<a id="a35f225657563da71823b14982922fcc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f225657563da71823b14982922fcc8">&#9670;&nbsp;</a></span>createBrieIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_interpreter_index.html">InterpreterIndex</a> &gt; souffle::createBrieIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_order.html">Order</a> &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interpreter_index_8cpp_source.html#l00695">695</a> of file <a class="el" href="_interpreter_index_8cpp_source.html">InterpreterIndex.cpp</a>.</p>

<p class="reference">References <a class="el" href="_interpreter_index_8h_source.html#l00133">souffle::Order::order</a>, and <a class="el" href="_interpreter_index_8cpp_source.html#l00046">souffle::Order::size()</a>.</p>
<div class="fragment"><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;                                                                    {</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;    <span class="keywordflow">switch</span> (order.size()) {</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;        <span class="keywordflow">case</span> 0:</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;NullaryIndex&gt;();</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;        <span class="keywordflow">case</span> 1:</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BrieIndex&lt;1&gt;&gt;(order);</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;        <span class="keywordflow">case</span> 2:</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BrieIndex&lt;2&gt;&gt;(order);</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;        <span class="keywordflow">case</span> 3:</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BrieIndex&lt;3&gt;&gt;(order);</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;        <span class="keywordflow">case</span> 4:</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BrieIndex&lt;4&gt;&gt;(order);</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;        <span class="keywordflow">case</span> 5:</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BrieIndex&lt;5&gt;&gt;(order);</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;        <span class="keywordflow">case</span> 6:</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BrieIndex&lt;6&gt;&gt;(order);</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;        <span class="keywordflow">case</span> 7:</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BrieIndex&lt;7&gt;&gt;(order);</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;        <span class="keywordflow">case</span> 8:</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BrieIndex&lt;8&gt;&gt;(order);</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;        <span class="keywordflow">case</span> 9:</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BrieIndex&lt;9&gt;&gt;(order);</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;        <span class="keywordflow">case</span> 10:</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BrieIndex&lt;10&gt;&gt;(order);</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;        <span class="keywordflow">case</span> 11:</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BrieIndex&lt;11&gt;&gt;(order);</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;        <span class="keywordflow">case</span> 12:</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BrieIndex&lt;12&gt;&gt;(order);</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;    }</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Requested arity not yet supported. Feel free to add it.&quot;</span>);</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;    <span class="keywordflow">return</span> {};</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a35f225657563da71823b14982922fcc8_cgraph.png" border="0" usemap="#namespacesouffle_a35f225657563da71823b14982922fcc8_cgraph" alt=""/></div>
<map name="namespacesouffle_a35f225657563da71823b14982922fcc8_cgraph" id="namespacesouffle_a35f225657563da71823b14982922fcc8_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_order.html#acba06648b910cba7978cca29cbf87ed1" title="souffle::Order::size" alt="" coords="231,5,375,32"/>
</map>
</div>

</div>
</div>
<a id="ac8909e0b79f3b2870f5fc76eb1b23d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8909e0b79f3b2870f5fc76eb1b23d12">&#9670;&nbsp;</a></span>createBTreeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_interpreter_index.html">InterpreterIndex</a> &gt; souffle::createBTreeIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_order.html">Order</a> &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interpreter_index_8cpp_source.html#l00626">626</a> of file <a class="el" href="_interpreter_index_8cpp_source.html">InterpreterIndex.cpp</a>.</p>

<p class="reference">References <a class="el" href="_interpreter_index_8h_source.html#l00133">souffle::Order::order</a>, and <a class="el" href="_interpreter_index_8cpp_source.html#l00046">souffle::Order::size()</a>.</p>
<div class="fragment"><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;                                                                     {</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;    <span class="keywordflow">switch</span> (order.size()) {</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;        <span class="keywordflow">case</span> 0:</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;NullaryIndex&gt;();</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;        <span class="keywordflow">case</span> 1:</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeIndex&lt;1&gt;&gt;(order);</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;        <span class="keywordflow">case</span> 2:</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeIndex&lt;2&gt;&gt;(order);</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        <span class="keywordflow">case</span> 3:</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeIndex&lt;3&gt;&gt;(order);</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;        <span class="keywordflow">case</span> 4:</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeIndex&lt;4&gt;&gt;(order);</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;        <span class="keywordflow">case</span> 5:</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeIndex&lt;5&gt;&gt;(order);</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;        <span class="keywordflow">case</span> 6:</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeIndex&lt;6&gt;&gt;(order);</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;        <span class="keywordflow">case</span> 7:</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeIndex&lt;7&gt;&gt;(order);</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;        <span class="keywordflow">case</span> 8:</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeIndex&lt;8&gt;&gt;(order);</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;        <span class="keywordflow">case</span> 9:</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeIndex&lt;9&gt;&gt;(order);</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;        <span class="keywordflow">case</span> 10:</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeIndex&lt;10&gt;&gt;(order);</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;        <span class="keywordflow">case</span> 11:</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeIndex&lt;11&gt;&gt;(order);</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;        <span class="keywordflow">case</span> 12:</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeIndex&lt;12&gt;&gt;(order);</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;    }</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Requested arity not yet supported. Feel free to add it.&quot;</span>);</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;    <span class="keywordflow">return</span> {};</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ac8909e0b79f3b2870f5fc76eb1b23d12_cgraph.png" border="0" usemap="#namespacesouffle_ac8909e0b79f3b2870f5fc76eb1b23d12_cgraph" alt=""/></div>
<map name="namespacesouffle_ac8909e0b79f3b2870f5fc76eb1b23d12_cgraph" id="namespacesouffle_ac8909e0b79f3b2870f5fc76eb1b23d12_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_order.html#acba06648b910cba7978cca29cbf87ed1" title="souffle::Order::size" alt="" coords="240,5,384,32"/>
</map>
</div>

</div>
</div>
<a id="acd9ba22f7f5dfc45efc499c6d9932b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9ba22f7f5dfc45efc499c6d9932b50">&#9670;&nbsp;</a></span>createBTreeProvenanceIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_interpreter_index.html">InterpreterIndex</a> &gt; souffle::createBTreeProvenanceIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_order.html">Order</a> &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interpreter_index_8cpp_source.html#l00659">659</a> of file <a class="el" href="_interpreter_index_8cpp_source.html">InterpreterIndex.cpp</a>.</p>

<p class="reference">References <a class="el" href="_interpreter_index_8h_source.html#l00133">souffle::Order::order</a>, and <a class="el" href="_interpreter_index_8cpp_source.html#l00046">souffle::Order::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_interpreter_generator_8h_source.html#l00628">souffle::NodeGenerator::createRelation()</a>.</p>
<div class="fragment"><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;                                                                               {</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;    <span class="keywordflow">switch</span> (order.size()) {</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;        <span class="keywordflow">case</span> 0:</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;        <span class="keywordflow">case</span> 1:</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;            assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Provenance relation with arity &lt; 2.&quot;</span>);</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;        <span class="keywordflow">case</span> 2:</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeProvenanceIndex&lt;2&gt;&gt;(order);</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;        <span class="keywordflow">case</span> 3:</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeProvenanceIndex&lt;3&gt;&gt;(order);</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;        <span class="keywordflow">case</span> 4:</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeProvenanceIndex&lt;4&gt;&gt;(order);</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;        <span class="keywordflow">case</span> 5:</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeProvenanceIndex&lt;5&gt;&gt;(order);</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;        <span class="keywordflow">case</span> 6:</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeProvenanceIndex&lt;6&gt;&gt;(order);</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;        <span class="keywordflow">case</span> 7:</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeProvenanceIndex&lt;7&gt;&gt;(order);</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;        <span class="keywordflow">case</span> 8:</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeProvenanceIndex&lt;8&gt;&gt;(order);</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;        <span class="keywordflow">case</span> 9:</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeProvenanceIndex&lt;9&gt;&gt;(order);</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;        <span class="keywordflow">case</span> 10:</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeProvenanceIndex&lt;10&gt;&gt;(order);</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;        <span class="keywordflow">case</span> 11:</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeProvenanceIndex&lt;11&gt;&gt;(order);</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;        <span class="keywordflow">case</span> 12:</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeProvenanceIndex&lt;12&gt;&gt;(order);</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;        <span class="keywordflow">case</span> 13:</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeProvenanceIndex&lt;13&gt;&gt;(order);</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;        <span class="keywordflow">case</span> 14:</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;            <span class="keywordflow">return</span> std::make_unique&lt;BTreeProvenanceIndex&lt;14&gt;&gt;(order);</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;    }</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Requested arity not yet supported. Feel free to add it.&quot;</span>);</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;    <span class="keywordflow">return</span> {};</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_acd9ba22f7f5dfc45efc499c6d9932b50_cgraph.png" border="0" usemap="#namespacesouffle_acd9ba22f7f5dfc45efc499c6d9932b50_cgraph" alt=""/></div>
<map name="namespacesouffle_acd9ba22f7f5dfc45efc499c6d9932b50_cgraph" id="namespacesouffle_acd9ba22f7f5dfc45efc499c6d9932b50_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_order.html#acba06648b910cba7978cca29cbf87ed1" title="souffle::Order::size" alt="" coords="280,13,424,39"/>
</map>
</div>

</div>
</div>
<a id="af5fab0957729cf0e7759095605a9b099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fab0957729cf0e7759095605a9b099">&#9670;&nbsp;</a></span>createEqrelIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_interpreter_index.html">InterpreterIndex</a> &gt; souffle::createEqrelIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_order.html">Order</a> &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interpreter_index_8cpp_source.html#l00733">733</a> of file <a class="el" href="_interpreter_index_8cpp_source.html">InterpreterIndex.cpp</a>.</p>

<p class="reference">References <a class="el" href="_interpreter_index_8h_source.html#l00133">souffle::Order::order</a>, and <a class="el" href="_interpreter_index_8cpp_source.html#l00046">souffle::Order::size()</a>.</p>
<div class="fragment"><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;                                                                     {</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;    assert(order.size() == 2 &amp;&amp; <span class="stringliteral">&quot;Eqrel index must have tuple of 2 arities&quot;</span>);</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;    <span class="keywordflow">return</span> std::make_unique&lt;EqrelIndex&gt;(order);</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_af5fab0957729cf0e7759095605a9b099_cgraph.png" border="0" usemap="#namespacesouffle_af5fab0957729cf0e7759095605a9b099_cgraph" alt=""/></div>
<map name="namespacesouffle_af5fab0957729cf0e7759095605a9b099_cgraph" id="namespacesouffle_af5fab0957729cf0e7759095605a9b099_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_order.html#acba06648b910cba7978cca29cbf87ed1" title="souffle::Order::size" alt="" coords="237,5,381,32"/>
</map>
</div>

</div>
</div>
<a id="a19f7b12aa9381c990b2355a126a5eb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f7b12aa9381c990b2355a126a5eb84">&#9670;&nbsp;</a></span>createIndirectIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_interpreter_index.html">InterpreterIndex</a> &gt; souffle::createIndirectIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_order.html">Order</a> &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interpreter_index_8cpp_source.html#l00728">728</a> of file <a class="el" href="_interpreter_index_8cpp_source.html">InterpreterIndex.cpp</a>.</p>

<p class="reference">References <a class="el" href="_interpreter_index_8h_source.html#l00169">souffle::Order::getOrder()</a>, and <a class="el" href="_interpreter_index_8cpp_source.html#l00046">souffle::Order::size()</a>.</p>
<div class="fragment"><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;                                                                        {</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;    assert(order.size() != 0 &amp;&amp; <span class="stringliteral">&quot;IndirectIndex does not work with nullary relation\n&quot;</span>);</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;    <span class="keywordflow">return</span> std::make_unique&lt;IndirectIndex&gt;(order.getOrder());</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a19f7b12aa9381c990b2355a126a5eb84_cgraph.png" border="0" usemap="#namespacesouffle_a19f7b12aa9381c990b2355a126a5eb84_cgraph" alt=""/></div>
<map name="namespacesouffle_a19f7b12aa9381c990b2355a126a5eb84_cgraph" id="namespacesouffle_a19f7b12aa9381c990b2355a126a5eb84_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_order.html#ae34df581d30a026d32576343720a0abe" title="souffle::Order::getOrder" alt="" coords="253,5,428,32"/>
<area shape="rect" id="node5" href="classsouffle_1_1_order.html#acba06648b910cba7978cca29cbf87ed1" title="souffle::Order::size" alt="" coords="269,56,413,83"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad8cf2396e4d4fb479990191006785299" title="souffle::operator\&lt;\&lt;" alt="" coords="476,5,627,32"/>
<area shape="rect" id="node4" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb" title="Creates an object to be forwarded to some output stream for printing sequences of elements interspers..." alt="" coords="675,5,773,32"/>
</map>
</div>

</div>
</div>
<a id="a2012cac577506e366ebdd0791b73ab28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2012cac577506e366ebdd0791b73ab28">&#9670;&nbsp;</a></span>createMagicIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> souffle::createMagicIdentifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>relationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outputNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00228">228</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_qualified_name_8h_source.html#l00046">souffle::AstQualifiedName::append()</a>, <a class="el" href="_ast_qualified_name_8h_source.html#l00061">souffle::AstQualifiedName::getQualifiers()</a>, and <a class="el" href="json11_8h_source.html#l00651">i</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                                                                                                  {</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    std::vector&lt;std::string&gt; relationNames = relationName.getQualifiers();</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <span class="comment">// change the base name to magic-relation format</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    std::stringstream newMainName;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    newMainName.str(<span class="stringliteral">&quot;&quot;</span>);</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    newMainName &lt;&lt; <span class="stringliteral">&quot;+m&quot;</span> &lt;&lt; outputNumber &lt;&lt; <span class="stringliteral">&quot;_&quot;</span> &lt;&lt; relationNames[0];  <span class="comment">// use &quot;+m&quot; to avoid conflicts</span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    AstQualifiedName newRelationName(newMainName.str());</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    <span class="comment">// copy over the other relation names</span></div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 1; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; relationNames.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        newRelationName.append(relationNames[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>]);</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    }</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    <span class="keywordflow">return</span> newRelationName;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a2012cac577506e366ebdd0791b73ab28_cgraph.png" border="0" usemap="#namespacesouffle_a2012cac577506e366ebdd0791b73ab28_cgraph" alt=""/></div>
<map name="namespacesouffle_a2012cac577506e366ebdd0791b73ab28_cgraph" id="namespacesouffle_a2012cac577506e366ebdd0791b73ab28_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_qualified_name.html#a6341a67891b6d0174b92264eb4dc5d43" title="append qualifiers " alt="" coords="264,5,456,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_qualified_name.html#a4b36798d8506689de4ec2794f4777bfa" title="get qualifiers " alt="" coords="264,71,456,112"/>
</map>
</div>

</div>
</div>
<a id="a8a4b601829be88a59d12c4acc9f3a87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4b601829be88a59d12c4acc9f3a87f">&#9670;&nbsp;</a></span>createMagicRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a>* souffle::createMagicRelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>magicPredName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00996">996</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00465">clone()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00962">extractAdornment()</a>, <a class="el" href="_ast_relation_8h_source.html#l00068">souffle::AstRelation::getArity()</a>, and <a class="el" href="_ast_relation_8h_source.html#l00073">souffle::AstRelation::getAttributes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;                                                                                               {</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;    <span class="comment">// get the adornment of this argument</span></div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;    std::string adornment = <a class="code" href="namespacesouffle.html#a014bc04f4629bd77f3a54c26fe9ea53d">extractAdornment</a>(magicPredName);</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;    <span class="comment">// create the relation</span></div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;    <span class="keyword">auto</span>* newMagicRelation = <span class="keyword">new</span> AstRelation();</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;    newMagicRelation-&gt;setQualifiedName(magicPredName);</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;    <span class="comment">// copy over (bound) attributes from the original relation</span></div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;    std::vector&lt;AstAttribute*&gt; attrs = original-&gt;getAttributes();</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> currentArg = 0; currentArg &lt; original-&gt;getArity(); currentArg++) {</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;        <span class="keywordflow">if</span> (adornment[currentArg] == <span class="charliteral">&#39;b&#39;</span>) {</div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;            newMagicRelation-&gt;addAttribute(std::unique_ptr&lt;AstAttribute&gt;(attrs[currentArg]-&gt;<a class="code" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f">clone</a>()));</div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;        }</div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;    }</div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;    <span class="keywordflow">return</span> newMagicRelation;</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a014bc04f4629bd77f3a54c26fe9ea53d"><div class="ttname"><a href="namespacesouffle.html#a014bc04f4629bd77f3a54c26fe9ea53d">souffle::extractAdornment</a></div><div class="ttdeci">std::string extractAdornment(const AstQualifiedName &amp;magicRelationName)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00962">MagicSet.cpp:962</a></div></div>
<div class="ttc" id="namespacesouffle_html_a018886d19f141b1cb565199a517c598f"><div class="ttname"><a href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f">souffle::clone</a></div><div class="ttdeci">std::unique_ptr&lt; A &gt; clone(const A *node)</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00465">Util.h:465</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8a4b601829be88a59d12c4acc9f3a87f_cgraph.png" border="0" usemap="#namespacesouffle_a8a4b601829be88a59d12c4acc9f3a87f_cgraph" alt=""/></div>
<map name="namespacesouffle_a8a4b601829be88a59d12c4acc9f3a87f_cgraph" id="namespacesouffle_a8a4b601829be88a59d12c4acc9f3a87f_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="301,5,411,32"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a014bc04f4629bd77f3a54c26fe9ea53d" title="souffle::extractAdornment" alt="" coords="260,56,452,83"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_relation.html#a54bd8f26d113f3141d49e926a030b52d" title="Return the arity of this relation. " alt="" coords="282,107,430,149"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_relation.html#ae27800d5845e8ac6df95b20bfc51aecf" title="Get relation attributes. " alt="" coords="282,173,430,214"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_qualified_name.html#a4b36798d8506689de4ec2794f4777bfa" title="get qualifiers " alt="" coords="500,19,692,61"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a620dc7687473311acaa752a76b5c9470" title="souffle::getEndpoint" alt="" coords="520,85,672,112"/>
<area shape="rect" id="node8" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="523,180,669,207"/>
</map>
</div>

</div>
</div>
<a id="ac9327b98da5d4ad231903d0bb9205bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9327b98da5d4ad231903d0bb9205bbc">&#9670;&nbsp;</a></span>createNewRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a>* souffle::createNewRelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>newName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00211">211</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_relation_8h_source.html#l00073">souffle::AstRelation::getAttributes()</a>, <a class="el" href="_ast_relation_8h_source.html#l00093">souffle::AstRelation::getRepresentation()</a>, <a class="el" href="_ast_node_8h_source.html#l00045">souffle::AstNode::getSrcLoc()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00176">nextSrcLoc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00899">separateDBs()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                                                                                       {</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <span class="keyword">auto</span>* newRelation = <span class="keyword">new</span> AstRelation();</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    newRelation-&gt;setSrcLoc(<a class="code" href="namespacesouffle.html#a70f903ef77f947a3123c891794322534">nextSrcLoc</a>(original-&gt;getSrcLoc()));</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    newRelation-&gt;setQualifiedName(newName);</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    <span class="comment">// copy over the attributes from the original relation</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    <span class="keywordflow">for</span> (AstAttribute* attr : original-&gt;getAttributes()) {</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        newRelation-&gt;addAttribute(std::unique_ptr&lt;AstAttribute&gt;(attr-&gt;clone()));</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    }</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    <span class="comment">// copy over internal representation</span></div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    newRelation-&gt;setRepresentation(original-&gt;getRepresentation());</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="keywordflow">return</span> newRelation;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a70f903ef77f947a3123c891794322534"><div class="ttname"><a href="namespacesouffle.html#a70f903ef77f947a3123c891794322534">souffle::nextSrcLoc</a></div><div class="ttdeci">SrcLocation nextSrcLoc(SrcLocation orig)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00176">MagicSet.cpp:176</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ac9327b98da5d4ad231903d0bb9205bbc_cgraph.png" border="0" usemap="#namespacesouffle_ac9327b98da5d4ad231903d0bb9205bbc_cgraph" alt=""/></div>
<map name="namespacesouffle_ac9327b98da5d4ad231903d0bb9205bbc_cgraph" id="namespacesouffle_ac9327b98da5d4ad231903d0bb9205bbc_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_relation.html#ae27800d5845e8ac6df95b20bfc51aecf" title="Get relation attributes. " alt="" coords="277,5,425,47"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_relation.html#ad2025f014882934287fbf5bf05a9ced7" title="Get relation representation. " alt="" coords="276,71,425,112"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="251,137,451,163"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a70f903ef77f947a3123c891794322534" title="souffle::nextSrcLoc" alt="" coords="278,187,423,214"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="499,13,645,39"/>
</map>
</div>

</div>
</div>
<a id="af55dc44cfd26c10c45a0546e88bf7787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55dc44cfd26c10c45a0546e88bf7787">&#9670;&nbsp;</a></span>createSubIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> souffle::createSubIdentifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>relationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00265">265</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_qualified_name_8h_source.html#l00046">souffle::AstQualifiedName::append()</a>, <a class="el" href="_ast_qualified_name_8h_source.html#l00061">souffle::AstQualifiedName::getQualifiers()</a>, and <a class="el" href="json11_8h_source.html#l00651">i</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                                                                                                        {</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    std::vector&lt;std::string&gt; relationNames = relationName.getQualifiers();</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    <span class="comment">// get the substring of the base name</span></div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    std::stringstream newMainName;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    newMainName.str(<span class="stringliteral">&quot;&quot;</span>);</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    newMainName &lt;&lt; relationNames[0].substr(start, length);</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    AstQualifiedName newRelationName(newMainName.str());</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    <span class="comment">// add in the remaining names</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 1; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; relationNames.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;        newRelationName.append(relationNames[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>]);</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    }</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    <span class="keywordflow">return</span> newRelationName;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_af55dc44cfd26c10c45a0546e88bf7787_cgraph.png" border="0" usemap="#namespacesouffle_af55dc44cfd26c10c45a0546e88bf7787_cgraph" alt=""/></div>
<map name="namespacesouffle_af55dc44cfd26c10c45a0546e88bf7787_cgraph" id="namespacesouffle_af55dc44cfd26c10c45a0546e88bf7787_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_qualified_name.html#a6341a67891b6d0174b92264eb4dc5d43" title="append qualifiers " alt="" coords="251,5,443,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_qualified_name.html#a4b36798d8506689de4ec2794f4777bfa" title="get qualifiers " alt="" coords="251,71,443,112"/>
</map>
</div>

</div>
</div>
<a id="aeb411c7585f438a75ef3de5b6ae2abc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb411c7585f438a75ef3de5b6ae2abc5">&#9670;&nbsp;</a></span>derefIter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_iter_deref_wrapper.html">IterDerefWrapper</a>&lt;Iter&gt; souffle::derefIter </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A factory function enabling the construction of a dereferencing iterator utilizing the automated deduction of template parameters. </p>

<p class="definition">Definition at line <a class="el" href="_iter_utils_8h_source.html#l00080">80</a> of file <a class="el" href="_iter_utils_8h_source.html">IterUtils.h</a>.</p>

<p class="reference">References <a class="el" href="_iter_utils_8h_source.html#l00033">souffle::IterDerefWrapper&lt; Iter, T &gt;::iter</a>.</p>

<p class="reference">Referenced by <a class="el" href="_type_system_8h_source.html#l00274">souffle::TypeSet::begin()</a>, and <a class="el" href="_type_system_8h_source.html#l00280">souffle::TypeSet::end()</a>.</p>
<div class="fragment"><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                                                   {</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keywordflow">return</span> IterDerefWrapper&lt;Iter&gt;(iter);</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a72e10d44624c80609e5c09b131ecf3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e10d44624c80609e5c09b131ecf3fb">&#9670;&nbsp;</a></span>dirName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::dirName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++-style dirname. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01115">1115</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_src_location_8cpp_source.html#l00027">getCurrentFilename()</a>.</p>
<div class="fragment"><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;                                                {</div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;    <span class="keywordflow">if</span> (name.empty()) {</div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;.&quot;</span>;</div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;    }</div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;    <span class="keywordtype">size_t</span> lastNotSlash = name.find_last_not_of(<span class="charliteral">&#39;/&#39;</span>);</div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;    <span class="comment">// All &#39;/&#39;</span></div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;    <span class="keywordflow">if</span> (lastNotSlash == std::string::npos) {</div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;/&quot;</span>;</div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;    }</div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;    <span class="keywordtype">size_t</span> leadingSlash = name.find_last_of(<span class="charliteral">&#39;/&#39;</span>, lastNotSlash);</div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;    <span class="comment">// No &#39;/&#39;</span></div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;    <span class="keywordflow">if</span> (leadingSlash == std::string::npos) {</div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;.&quot;</span>;</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;    }</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;    <span class="comment">// dirname is &#39;/&#39;</span></div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;    <span class="keywordflow">if</span> (leadingSlash == 0) {</div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;/&quot;</span>;</div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;    }</div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;    <span class="keywordflow">return</span> name.substr(0, leadingSlash);</div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a8ba27d2caf5a777268d89eaf5cbfed2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba27d2caf5a777268d89eaf5cbfed2a">&#9670;&nbsp;</a></span>duration_in_ns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long souffle::duration_in_ns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#a9eb29a1677ffbe44fe8663f881213f0e">time_point</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#a9eb29a1677ffbe44fe8663f881213f0e">time_point</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01047">1047</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;                                                                           {</div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(end - start).count());</div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="af3be713865e2b9922aa0eac1fb629041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3be713865e2b9922aa0eac1fb629041">&#9670;&nbsp;</a></span>duration_in_us()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long souffle::duration_in_us </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#a9eb29a1677ffbe44fe8663f881213f0e">time_point</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#a9eb29a1677ffbe44fe8663f881213f0e">time_point</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01042">1042</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;                                                                           {</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count());</div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a6e84ddff3bc168499fa141d3a3998494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e84ddff3bc168499fa141d3a3998494">&#9670;&nbsp;</a></span>endsWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::endsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given value string ends with the given end string. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00898">898</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;                                                                      {</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;    <span class="keywordflow">if</span> (value.size() &lt; ending.size()) {</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;    }</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;    <span class="keywordflow">return</span> std::equal(ending.rbegin(), ending.rend(), value.rbegin());</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a50022778409a94e92bcdc6e27f146161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50022778409a94e92bcdc6e27f146161">&#9670;&nbsp;</a></span>eqTypeTypeAttribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::eqTypeTypeAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a>&#160;</td>
          <td class="paramname"><em>ramType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a type analysis' result is equivalent to the given TypeAttribute. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8h_source.html#l00464">464</a> of file <a class="el" href="_type_system_8h_source.html">TypeSystem.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a22ae0e2b89e5e3d477f988cc36d3272b">Float</a>, <a class="el" href="_type_system_8cpp_source.html#l00331">isFloatType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00339">isNumberType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00363">isRecordType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00355">isSymbolType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00347">isUnsignedType()</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a6a0d9eaee314c567fd72fb97ee707a36">Record</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379">Signed</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a02c86eb2792f3262c21d030a87e19793">Symbol</a>, and <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0aa1a914735b205424ba6c40b85528d78a">Unsigned</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>.</p>
<div class="fragment"><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;                                                                     {</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    <span class="keywordflow">switch</span> (ramType) {</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        <span class="keywordflow">case</span> TypeAttribute::Signed:</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743">isNumberType</a>(type);</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        <span class="keywordflow">case</span> TypeAttribute::Unsigned:</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a5c4839a38da22a968ab01e81a67d793c">isUnsignedType</a>(type);</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;        <span class="keywordflow">case</span> TypeAttribute::Float:</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a1a7d8cb2f6a29f825e650a7c98487718">isFloatType</a>(type);</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        <span class="keywordflow">case</span> TypeAttribute::Symbol:</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b">isSymbolType</a>(type);</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;        <span class="keywordflow">case</span> TypeAttribute::Record:</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a34c8a82b8d9ed840b32e93186002d18c">isRecordType</a>(type);</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    }</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;unhandled `TypeAttribute`&quot;</span>);</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    exit(EXIT_FAILURE);</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a5c4839a38da22a968ab01e81a67d793c"><div class="ttname"><a href="namespacesouffle.html#a5c4839a38da22a968ab01e81a67d793c">souffle::isUnsignedType</a></div><div class="ttdeci">bool isUnsignedType(const Type &amp;type)</div><div class="ttdoc">Determines whether the given type is a number type. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00347">TypeSystem.cpp:347</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4e502e6abb9a3e9a8e4c1168dbf23743"><div class="ttname"><a href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743">souffle::isNumberType</a></div><div class="ttdeci">bool isNumberType(const Type &amp;type)</div><div class="ttdoc">Determines whether the given type is a number type. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00339">TypeSystem.cpp:339</a></div></div>
<div class="ttc" id="namespacesouffle_html_a1a7d8cb2f6a29f825e650a7c98487718"><div class="ttname"><a href="namespacesouffle.html#a1a7d8cb2f6a29f825e650a7c98487718">souffle::isFloatType</a></div><div class="ttdeci">bool isFloatType(const Type &amp;type)</div><div class="ttdoc">Determines whether the given type is a float type. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00331">TypeSystem.cpp:331</a></div></div>
<div class="ttc" id="namespacesouffle_html_a34c8a82b8d9ed840b32e93186002d18c"><div class="ttname"><a href="namespacesouffle.html#a34c8a82b8d9ed840b32e93186002d18c">souffle::isRecordType</a></div><div class="ttdeci">bool isRecordType(const Type &amp;type)</div><div class="ttdoc">Determines whether the given type is a record type. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00363">TypeSystem.cpp:363</a></div></div>
<div class="ttc" id="namespacesouffle_html_a11f6c352eec6bde7b5a0b143ffe64e3b"><div class="ttname"><a href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b">souffle::isSymbolType</a></div><div class="ttdeci">bool isSymbolType(const Type &amp;type)</div><div class="ttdoc">Determines whether the given type is a symbol type. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00355">TypeSystem.cpp:355</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a50022778409a94e92bcdc6e27f146161_cgraph.png" border="0" usemap="#namespacesouffle_a50022778409a94e92bcdc6e27f146161_cgraph" alt=""/></div>
<map name="namespacesouffle_a50022778409a94e92bcdc6e27f146161_cgraph" id="namespacesouffle_a50022778409a94e92bcdc6e27f146161_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a1a7d8cb2f6a29f825e650a7c98487718" title="Determines whether the given type is a float type. " alt="" coords="275,213,421,239"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="265,61,431,87"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a34c8a82b8d9ed840b32e93186002d18c" title="Determines whether the given type is a record type. " alt="" coords="269,263,427,290"/>
<area shape="rect" id="node12" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="266,111,430,138"/>
<area shape="rect" id="node14" href="namespacesouffle.html#a5c4839a38da22a968ab01e81a67d793c" title="Determines whether the given type is a number type. " alt="" coords="260,162,436,189"/>
<area shape="rect" id="node3" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="484,137,731,163"/>
<area shape="rect" id="node4" href="classsouffle_1_1_type_environment.html#a5569e54d58b6ca69f1fffbdd77143545" title="souffle::TypeEnvironment\l::getFloatType" alt="" coords="514,253,701,295"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="779,137,904,163"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="975,107,1079,134"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="952,159,1103,200"/>
<area shape="rect" id="node8" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1151,166,1297,193"/>
<area shape="rect" id="node10" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="514,5,701,47"/>
<area shape="rect" id="node13" href="classsouffle_1_1_type_environment.html#a72fa419d33bf813f22efabec629a4627" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="514,71,701,112"/>
<area shape="rect" id="node15" href="classsouffle_1_1_type_environment.html#a0b191b7782e170a23b54f7ec347a32ab" title="souffle::TypeEnvironment\l::getUnsignedType" alt="" coords="514,188,701,229"/>
</map>
</div>

</div>
</div>
<a id="ab097fb451e787a08a185a449bacde2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab097fb451e787a08a185a449bacde2db">&#9670;&nbsp;</a></span>equal_ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::equal_ptr </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two values referenced by a pointer where the case where both pointers are null is also considered equivalent. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00574">574</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00382">souffle::range&lt; Iter &gt;::b</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ram_statement_8h_source.html#l00083">souffle::RamRelationStatement::equal()</a>, <a class="el" href="_ram_operation_8h_source.html#l00113">souffle::RamNestedOperation::equal()</a>, <a class="el" href="_ram_condition_8h_source.html#l00131">souffle::RamConjunction::equal()</a>, <a class="el" href="_ram_program_8h_source.html#l00147">souffle::RamProgram::equal()</a>, <a class="el" href="_ast_literal_8h_source.html#l00156">souffle::AstNegation::equal()</a>, <a class="el" href="_ram_relation_8h_source.html#l00169">souffle::RamRelationReference::equal()</a>, <a class="el" href="_ram_condition_8h_source.html#l00180">souffle::RamNegation::equal()</a>, <a class="el" href="_ram_operation_8h_source.html#l00193">souffle::RamRelationOperation::equal()</a>, <a class="el" href="_ram_statement_8h_source.html#l00208">souffle::RamBinRelationStatement::equal()</a>, <a class="el" href="_ast_clause_8h_source.html#l00233">souffle::AstClause::equal()</a>, <a class="el" href="_ram_condition_8h_source.html#l00246">souffle::RamConstraint::equal()</a>, <a class="el" href="_ast_literal_8h_source.html#l00281">souffle::AstBinaryConstraint::equal()</a>, <a class="el" href="_ram_condition_8h_source.html#l00319">souffle::RamAbstractExistenceCheck::equal()</a>, <a class="el" href="_ram_statement_8h_source.html#l00331">souffle::RamQuery::equal()</a>, <a class="el" href="_ast_component_8h_source.html#l00373">souffle::AstComponent::equal()</a>, <a class="el" href="_ram_condition_8h_source.html#l00424">souffle::RamEmptinessCheck::equal()</a>, <a class="el" href="_ram_operation_8h_source.html#l00446">souffle::RamAbstractChoice::equal()</a>, <a class="el" href="_ast_argument_8h_source.html#l00469">souffle::AstTypeCast::equal()</a>, <a class="el" href="_ram_statement_8h_source.html#l00507">souffle::RamLoop::equal()</a>, <a class="el" href="_ram_statement_8h_source.html#l00556">souffle::RamExit::equal()</a>, <a class="el" href="_ast_argument_8h_source.html#l00580">souffle::AstAggregator::equal()</a>, <a class="el" href="_ram_statement_8h_source.html#l00597">souffle::RamAbstractLog::equal()</a>, <a class="el" href="_ram_operation_8h_source.html#l00727">souffle::RamAbstractAggregate::equal()</a>, <a class="el" href="_ram_operation_8h_source.html#l00905">souffle::RamUnpackRecord::equal()</a>, <a class="el" href="_ram_operation_8h_source.html#l00948">souffle::RamAbstractConditional::equal()</a>, <a class="el" href="_ram_operation_8h_source.html#l01085">souffle::RamProject::equal()</a>, and <a class="el" href="_util_8h_source.html#l00589">equal_ptr()</a>.</p>
<div class="fragment"><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;                                       {</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;    <span class="keywordflow">if</span> (a == <span class="keyword">nullptr</span> &amp;&amp; <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a> == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;    }</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;    <span class="keywordflow">if</span> (a != <span class="keyword">nullptr</span> &amp;&amp; <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a> != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;        <span class="keywordflow">return</span> *a == *<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>;</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;    }</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9b13dfdf28e89958f7adeaa43abbe34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b13dfdf28e89958f7adeaa43abbe34f">&#9670;&nbsp;</a></span>equal_ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::equal_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two values referenced by a pointer where the case where both pointers are null is also considered equivalent. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00589">589</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00574">equal_ptr()</a>.</p>
<div class="fragment"><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                                                                     {</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a9b13dfdf28e89958f7adeaa43abbe34f">equal_ptr</a>(a.get(), <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>.get());</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a9b13dfdf28e89958f7adeaa43abbe34f"><div class="ttname"><a href="namespacesouffle.html#a9b13dfdf28e89958f7adeaa43abbe34f">souffle::equal_ptr</a></div><div class="ttdeci">bool equal_ptr(const std::unique_ptr&lt; T &gt; &amp;a, const std::unique_ptr&lt; T &gt; &amp;b)</div><div class="ttdoc">Compares two values referenced by a pointer where the case where both pointers are null is also consi...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00589">Util.h:589</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a9b13dfdf28e89958f7adeaa43abbe34f_cgraph.png" border="0" usemap="#namespacesouffle_a9b13dfdf28e89958f7adeaa43abbe34f_cgraph" alt=""/></div>
<map name="namespacesouffle_a9b13dfdf28e89958f7adeaa43abbe34f_cgraph" id="namespacesouffle_a9b13dfdf28e89958f7adeaa43abbe34f_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ab097fb451e787a08a185a449bacde2db" title="Compares two values referenced by a pointer where the case where both pointers are null is also consi..." alt="" coords="188,5,323,32"/>
</map>
</div>

</div>
</div>
<a id="ae16e133691dd9963d4234b61e3cc203f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16e133691dd9963d4234b61e3cc203f">&#9670;&nbsp;</a></span>equal_targets() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::equal_targets </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Comparator &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function testing whether two containers are equal with the given Comparator. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00524">524</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ram_expression_8h_source.html#l00077">souffle::RamAbstractOperator::equal()</a>, <a class="el" href="_ast_literal_8h_source.html#l00112">souffle::AstAtom::equal()</a>, <a class="el" href="_ast_clause_8h_source.html#l00123">souffle::AstExecutionPlan::equal()</a>, <a class="el" href="_ram_program_8h_source.html#l00147">souffle::RamProgram::equal()</a>, <a class="el" href="_ast_relation_8h_source.html#l00150">souffle::AstRelation::equal()</a>, <a class="el" href="_ast_clause_8h_source.html#l00233">souffle::AstClause::equal()</a>, <a class="el" href="_ast_argument_8h_source.html#l00245">souffle::AstTerm::equal()</a>, <a class="el" href="_ast_program_8h_source.html#l00248">souffle::AstProgram::equal()</a>, <a class="el" href="_ram_condition_8h_source.html#l00319">souffle::RamAbstractExistenceCheck::equal()</a>, <a class="el" href="_ram_operation_8h_source.html#l00327">souffle::RamIndexOperation::equal()</a>, <a class="el" href="_ast_component_8h_source.html#l00373">souffle::AstComponent::equal()</a>, <a class="el" href="_ram_statement_8h_source.html#l00379">souffle::RamListStatement::equal()</a>, <a class="el" href="_ram_expression_8h_source.html#l00433">souffle::RamPackRecord::equal()</a>, <a class="el" href="_ast_argument_8h_source.html#l00580">souffle::AstAggregator::equal()</a>, <a class="el" href="_ram_operation_8h_source.html#l01085">souffle::RamProject::equal()</a>, <a class="el" href="_ram_operation_8h_source.html#l01156">souffle::RamSubroutineReturnValue::equal()</a>, <a class="el" href="_util_8h_source.html#l00544">equal_targets()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l00079">souffle::RemoveRelationCopiesTransformer::removeRelationCopies()</a>.</p>
<div class="fragment"><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;                                                                                   {</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    <span class="comment">// check reference</span></div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    <span class="keywordflow">if</span> (&amp;a == &amp;<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>) {</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    }</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    <span class="comment">// check size</span></div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;    <span class="keywordflow">if</span> (a.size() != <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>.size()) {</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;    }</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    <span class="comment">// check content</span></div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;    <span class="keywordflow">return</span> std::equal(a.begin(), a.end(), <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>.begin(), comp);</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="accb99b4f76eebd4491ad16473e4dda5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb99b4f76eebd4491ad16473e4dda5b">&#9670;&nbsp;</a></span>equal_targets() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; typename... &gt; class Container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::equal_targets </td>
          <td>(</td>
          <td class="paramtype">const Container&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function testing whether two containers of pointers are referencing equivalent targets. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00544">544</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00524">equal_targets()</a>.</p>
<div class="fragment"><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;                                                                   {</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a0b97dba4d2f55282e3383098bbea3aee">equal_targets</a>(a, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, comp_deref&lt;T*&gt;());</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a0b97dba4d2f55282e3383098bbea3aee"><div class="ttname"><a href="namespacesouffle.html#a0b97dba4d2f55282e3383098bbea3aee">souffle::equal_targets</a></div><div class="ttdeci">bool equal_targets(const std::map&lt; Key, std::unique_ptr&lt; Value &gt;&gt; &amp;a, const std::map&lt; Key, std::unique_ptr&lt; Value &gt;&gt; &amp;b)</div><div class="ttdoc">A function testing whether two maps of unique pointers are referencing to equivalent targets...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00562">Util.h:562</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_accb99b4f76eebd4491ad16473e4dda5b_cgraph.png" border="0" usemap="#namespacesouffle_accb99b4f76eebd4491ad16473e4dda5b_cgraph" alt=""/></div>
<map name="namespacesouffle_accb99b4f76eebd4491ad16473e4dda5b_cgraph" id="namespacesouffle_accb99b4f76eebd4491ad16473e4dda5b_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ae16e133691dd9963d4234b61e3cc203f" title="A function testing whether two containers are equal with the given Comparator. " alt="" coords="216,5,379,32"/>
</map>
</div>

</div>
</div>
<a id="af87752f386ec8b0ab3a1f943d4f29896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87752f386ec8b0ab3a1f943d4f29896">&#9670;&nbsp;</a></span>equal_targets() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; typename... &gt; class Container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::equal_targets </td>
          <td>(</td>
          <td class="paramtype">const Container&lt; std::unique_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container&lt; std::unique_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function testing whether two containers of unique pointers are referencing equivalent targets. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00553">553</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00382">souffle::range&lt; Iter &gt;::a</a>, <a class="el" href="_util_8h_source.html#l00382">souffle::range&lt; Iter &gt;::b</a>, and <a class="el" href="_util_8h_source.html#l00524">equal_targets()</a>.</p>
<div class="fragment"><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;                                                                                               {</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a0b97dba4d2f55282e3383098bbea3aee">equal_targets</a>(a, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, comp_deref&lt;std::unique_ptr&lt;T&gt;&gt;());</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a0b97dba4d2f55282e3383098bbea3aee"><div class="ttname"><a href="namespacesouffle.html#a0b97dba4d2f55282e3383098bbea3aee">souffle::equal_targets</a></div><div class="ttdeci">bool equal_targets(const std::map&lt; Key, std::unique_ptr&lt; Value &gt;&gt; &amp;a, const std::map&lt; Key, std::unique_ptr&lt; Value &gt;&gt; &amp;b)</div><div class="ttdoc">A function testing whether two maps of unique pointers are referencing to equivalent targets...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00562">Util.h:562</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_af87752f386ec8b0ab3a1f943d4f29896_cgraph.png" border="0" usemap="#namespacesouffle_af87752f386ec8b0ab3a1f943d4f29896_cgraph" alt=""/></div>
<map name="namespacesouffle_af87752f386ec8b0ab3a1f943d4f29896_cgraph" id="namespacesouffle_af87752f386ec8b0ab3a1f943d4f29896_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ae16e133691dd9963d4234b61e3cc203f" title="A function testing whether two containers are equal with the given Comparator. " alt="" coords="216,5,379,32"/>
</map>
</div>

</div>
</div>
<a id="a0b97dba4d2f55282e3383098bbea3aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b97dba4d2f55282e3383098bbea3aee">&#9670;&nbsp;</a></span>equal_targets() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::equal_targets </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Key, std::unique_ptr&lt; Value &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; Key, std::unique_ptr&lt; Value &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function testing whether two maps of unique pointers are referencing to equivalent targets. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00562">562</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00382">souffle::range&lt; Iter &gt;::a</a>, <a class="el" href="_util_8h_source.html#l00382">souffle::range&lt; Iter &gt;::b</a>, and <a class="el" href="_util_8h_source.html#l00524">equal_targets()</a>.</p>
<div class="fragment"><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;                                                                                                {</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;    <span class="keyword">auto</span> comp = comp_deref&lt;std::unique_ptr&lt;Value&gt;&gt;();</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a0b97dba4d2f55282e3383098bbea3aee">equal_targets</a>(</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;            a, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, [&amp;comp](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>) { <span class="keywordflow">return</span> a.first == <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>.first &amp;&amp; comp(a.second, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>.second); });</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a0b97dba4d2f55282e3383098bbea3aee"><div class="ttname"><a href="namespacesouffle.html#a0b97dba4d2f55282e3383098bbea3aee">souffle::equal_targets</a></div><div class="ttdeci">bool equal_targets(const std::map&lt; Key, std::unique_ptr&lt; Value &gt;&gt; &amp;a, const std::map&lt; Key, std::unique_ptr&lt; Value &gt;&gt; &amp;b)</div><div class="ttdoc">A function testing whether two maps of unique pointers are referencing to equivalent targets...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00562">Util.h:562</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a0b97dba4d2f55282e3383098bbea3aee_cgraph.png" border="0" usemap="#namespacesouffle_a0b97dba4d2f55282e3383098bbea3aee_cgraph" alt=""/></div>
<map name="namespacesouffle_a0b97dba4d2f55282e3383098bbea3aee_cgraph" id="namespacesouffle_a0b97dba4d2f55282e3383098bbea3aee_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ae16e133691dd9963d4234b61e3cc203f" title="A function testing whether two containers are equal with the given Comparator. " alt="" coords="216,5,379,32"/>
</map>
</div>

</div>
</div>
<a id="aad78346252bf890fbf93de92aa4a2f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad78346252bf890fbf93de92aa4a2f73">&#9670;&nbsp;</a></span>escape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::escape </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>inputString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01337">1337</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_synthesiser_8cpp_source.html#l00172">souffle::Synthesiser::emitCode()</a>, <a class="el" href="_synthesiser_8cpp_source.html#l01730">souffle::Synthesiser::generateCode()</a>, <a class="el" href="_ram_statement_8h_source.html#l00119">souffle::RamIO::print()</a>, and <a class="el" href="_event_processor_8h_source.html#l00068">souffle::profile::EventProcessorSingleton::process()</a>.</p>
<div class="fragment"><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;                                                                                             {</div><div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;    std::string result = inputString;</div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;    <span class="keywordtype">size_t</span> pos = 0;</div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;    <span class="keywordflow">while</span> ((pos = result.find(needle, pos)) != std::string::npos) {</div><div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;        result = result.replace(pos, needle.length(), replacement);</div><div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;        pos += replacement.length();</div><div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;    }</div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;    <span class="keywordflow">return</span> result;</div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a57b2a40d0e298261a99b89c04424ed56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b2a40d0e298261a99b89c04424ed56">&#9670;&nbsp;</a></span>escape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::escape </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>inputString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01348">1348</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;                                                      {</div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;    std::string escaped = <a class="code" href="namespacesouffle.html#a57b2a40d0e298261a99b89c04424ed56">escape</a>(inputString, <span class="stringliteral">&quot;\&quot;&quot;</span>, <span class="stringliteral">&quot;\\\&quot;&quot;</span>);</div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;    escaped = <a class="code" href="namespacesouffle.html#a57b2a40d0e298261a99b89c04424ed56">escape</a>(escaped, <span class="stringliteral">&quot;\t&quot;</span>, <span class="stringliteral">&quot;\\t&quot;</span>);</div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;    escaped = <a class="code" href="namespacesouffle.html#a57b2a40d0e298261a99b89c04424ed56">escape</a>(escaped, <span class="stringliteral">&quot;\r&quot;</span>, <span class="stringliteral">&quot;\\r&quot;</span>);</div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;    escaped = <a class="code" href="namespacesouffle.html#a57b2a40d0e298261a99b89c04424ed56">escape</a>(escaped, <span class="stringliteral">&quot;\n&quot;</span>, <span class="stringliteral">&quot;\\n&quot;</span>);</div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;    <span class="keywordflow">return</span> escaped;</div><div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a57b2a40d0e298261a99b89c04424ed56"><div class="ttname"><a href="namespacesouffle.html#a57b2a40d0e298261a99b89c04424ed56">souffle::escape</a></div><div class="ttdeci">std::string escape(const std::string &amp;inputString)</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01348">Util.h:1348</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1056c0ab323cd2951500d84bea3c0aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1056c0ab323cd2951500d84bea3c0aa1">&#9670;&nbsp;</a></span>escapeJSONstring()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::escapeJSONstring </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>JSONstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Escape JSON string. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01293">1293</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_synthesiser_8cpp_source.html#l01730">souffle::Synthesiser::generateCode()</a>.</p>
<div class="fragment"><div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;                                                            {</div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;    std::ostringstream destination;</div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;</div><div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;    <span class="comment">// Iterate over all characters except first and last</span></div><div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">char</span> c : JSONstr) {</div><div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;        <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;\&quot;&#39;</span>) {</div><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;            destination &lt;&lt; <span class="stringliteral">&quot;\\&quot;</span>;</div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;        }</div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;        destination &lt;&lt; c;</div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;    }</div><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;    <span class="keywordflow">return</span> destination.str();</div><div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5e22287be4345c05c5f70b1d37eaec77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e22287be4345c05c5f70b1d37eaec77">&#9670;&nbsp;</a></span>execStdOut() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream souffle::execStdOut </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01356">1356</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_debug_reporter_8h_source.html#l00067">souffle::DebugReporter::generateDiff()</a>.</p>
<div class="fragment"><div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;                                                   {</div><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;    FILE* in = popen(cmd, <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;    std::stringstream data;</div><div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;    <span class="keywordflow">while</span> (in != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;        <span class="keywordtype">char</span> c = fgetc(in);</div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;        <span class="keywordflow">if</span> (feof(in) != 0) {</div><div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;        }</div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;        data &lt;&lt; c;</div><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;    }</div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;    pclose(in);</div><div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;    <span class="keywordflow">return</span> data;</div><div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a720784b780e625da862d7f7f127f7afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720784b780e625da862d7f7f127f7afb">&#9670;&nbsp;</a></span>execStdOut() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream souffle::execStdOut </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01370">1370</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;                                                        {</div><div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a720784b780e625da862d7f7f127f7afb">execStdOut</a>(cmd.c_str());</div><div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a720784b780e625da862d7f7f127f7afb"><div class="ttname"><a href="namespacesouffle.html#a720784b780e625da862d7f7f127f7afb">souffle::execStdOut</a></div><div class="ttdeci">std::stringstream execStdOut(std::string const &amp;cmd)</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01370">Util.h:1370</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1752bf432062837ed19ae6ac73ab177c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1752bf432062837ed19ae6ac73ab177c">&#9670;&nbsp;</a></span>executeBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::executeBinary </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binaryFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a binary file. </p>

<p class="definition">Definition at line <a class="el" href="main_8cpp_source.html#l00063">63</a> of file <a class="el" href="main_8cpp_source.html">main.cpp</a>.</p>

<p class="reference">References <a class="el" href="_global_8h_source.html#l00135">souffle::Global::config()</a>, <a class="el" href="_util_8h_source.html#l01084">isExecutable()</a>, and <a class="el" href="_util_8h_source.html#l00908">splitString()</a>.</p>

<p class="reference">Referenced by <a class="el" href="main_8cpp_source.html#l00124">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;                                                    {</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    assert(!binaryFilename.empty() &amp;&amp; <span class="stringliteral">&quot;binary filename cannot be blank&quot;</span>);</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="comment">// check whether the executable exists</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">isExecutable</a>(binaryFilename)) {</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Generated executable &lt;&quot;</span> + binaryFilename + <span class="stringliteral">&quot;&gt; could not be found&quot;</span>);</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    }</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <span class="comment">// run the executable</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;library-dir&quot;</span>)) {</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        std::string ldPath;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> std::string&amp; library : <a class="code" href="namespacesouffle.html#a673608e9453179d30f6607384f54463a">splitString</a>(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;library-dir&quot;</span>), <span class="charliteral">&#39; &#39;</span>)) {</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            ldPath += library + <span class="charliteral">&#39;:&#39;</span>;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        }</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        ldPath.back() = <span class="charliteral">&#39; &#39;</span>;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        setenv(<span class="stringliteral">&quot;LD_LIBRARY_PATH&quot;</span>, ldPath.c_str(), 1);</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        setenv(<span class="stringliteral">&quot;DYLD_LIBRARY_PATH&quot;</span>, ldPath.c_str(), 1);</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    }</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="keywordtype">int</span> exitCode = system(binaryFilename.c_str());</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="keywordflow">if</span> (Global::config().get(<span class="stringliteral">&quot;dl-program&quot;</span>).empty()) {</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        <span class="keyword">remove</span>(binaryFilename.c_str());</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        <span class="keyword">remove</span>((binaryFilename + <span class="stringliteral">&quot;.cpp&quot;</span>).c_str());</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    }</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="comment">// exit with same code as executable</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="keywordflow">if</span> (exitCode != EXIT_SUCCESS) {</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        exit(exitCode);</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    }</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a64753e143a37bb9414121fc75987cb14"><div class="ttname"><a href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">souffle::isExecutable</a></div><div class="ttdeci">bool isExecutable(const std::string &amp;name)</div><div class="ttdoc">Check whether a given file exists and it is an executable. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01084">Util.h:1084</a></div></div>
<div class="ttc" id="namespacesouffle_html_a673608e9453179d30f6607384f54463a"><div class="ttname"><a href="namespacesouffle.html#a673608e9453179d30f6607384f54463a">souffle::splitString</a></div><div class="ttdeci">std::vector&lt; std::string &gt; splitString(const std::string &amp;str, char delimiter)</div><div class="ttdoc">Splits a string given a delimiter. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00908">Util.h:908</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a1752bf432062837ed19ae6ac73ab177c_cgraph.png" border="0" usemap="#namespacesouffle_a1752bf432062837ed19ae6ac73ab177c_cgraph" alt=""/></div>
<map name="namespacesouffle_a1752bf432062837ed19ae6ac73ab177c_cgraph" id="namespacesouffle_a1752bf432062837ed19ae6ac73ab177c_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_global.html#a2dcb257b0f98d0b882862427cc965640" title="souffle::Global::config" alt="" coords="221,5,384,32"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14" title="Check whether a given file exists and it is an executable. " alt="" coords="224,56,381,83"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a673608e9453179d30f6607384f54463a" title="Splits a string given a delimiter. " alt="" coords="233,107,373,133"/>
</map>
</div>

</div>
</div>
<a id="a79fa4170c4094bc943de6fa5acb5796e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fa4170c4094bc943de6fa5acb5796e">&#9670;&nbsp;</a></span>existDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::existDir </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a directory exists in the file system. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01071">1071</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="main_8cpp_source.html#l00124">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;                                            {</div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;    <span class="keyword">struct </span>stat buffer = {};</div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;    <span class="keywordflow">if</span> (stat(name.c_str(), &amp;buffer) == 0) {</div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;        <span class="keywordflow">if</span> ((buffer.st_mode &amp; S_IFDIR) != 0) {</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;        }</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;    }</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a69107e934a60222580ee8ba6882dc3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69107e934a60222580ee8ba6882dc3d3">&#9670;&nbsp;</a></span>existFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::existFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a file exists in the file system. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01058">1058</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_src_location_8cpp_source.html#l00027">getCurrentFilename()</a>, and <a class="el" href="main_8cpp_source.html#l00124">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;                                             {</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;    <span class="keyword">struct </span>stat buffer = {};</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;    <span class="keywordflow">if</span> (stat(name.c_str(), &amp;buffer) == 0) {</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;        <span class="keywordflow">if</span> ((buffer.st_mode &amp; S_IFMT) != 0) {</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;        }</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;    }</div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab5c20b82d0becb6b4e3b780c2c87cc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c20b82d0becb6b4e3b780c2c87cc62">&#9670;&nbsp;</a></span>explain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::explain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_souffle_program.html">SouffleProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ncurses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useSubtreelevels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_explain_8h_source.html#l00621">621</a> of file <a class="el" href="_explain_8h_source.html">Explain.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_explain_provenance_8h_source.html#l00151">souffle::ExplainProvenance::ExplainProvenance()</a>, <a class="el" href="main_8cpp_source.html#l00124">main()</a>, <a class="el" href="_explain_8h_source.html#l00292">souffle::Explain::parseTuple()</a>, <a class="el" href="_explain_8h_source.html#l00450">souffle::Explain::printError()</a>, and <a class="el" href="_explain_8h_source.html#l00071">souffle::Explain::processCommand()</a>.</p>
<div class="fragment"><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;                                                                               {</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;    ExplainProvenanceImpl prov(prog, useSubtreelevels);</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    <span class="keywordflow">if</span> (ncurses) {</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;<span class="preprocessor">#ifdef USE_NCURSES</span></div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;        ExplainNcurses exp(prov);</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;        exp.explain();</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;The ncurses-based interface is not enabled\n&quot;</span>;</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;        ExplainConsole exp(prov);</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;        exp.explain();</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;    }</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a014bc04f4629bd77f3a54c26fe9ea53d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014bc04f4629bd77f3a54c26fe9ea53d">&#9670;&nbsp;</a></span>extractAdornment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::extractAdornment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>magicRelationName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00962">962</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_magic_set_8cpp_source.html#l00069">getEndpoint()</a>, and <a class="el" href="_ast_qualified_name_8h_source.html#l00061">souffle::AstQualifiedName::getQualifiers()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00996">createMagicRelation()</a>.</p>
<div class="fragment"><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;                                                                      {</div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;    std::string baseRelationName = magicRelationName.getQualifiers()[0];</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;    <span class="keywordtype">int</span> endpt = <a class="code" href="namespacesouffle.html#a620dc7687473311acaa752a76b5c9470">getEndpoint</a>(baseRelationName);</div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;    std::string adornment = baseRelationName.substr(endpt + 1, baseRelationName.size() - (endpt + 1));</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;    <span class="keywordflow">return</span> adornment;</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a620dc7687473311acaa752a76b5c9470"><div class="ttname"><a href="namespacesouffle.html#a620dc7687473311acaa752a76b5c9470">souffle::getEndpoint</a></div><div class="ttdeci">int getEndpoint(std::string mainName)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00069">MagicSet.cpp:69</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a014bc04f4629bd77f3a54c26fe9ea53d_cgraph.png" border="0" usemap="#namespacesouffle_a014bc04f4629bd77f3a54c26fe9ea53d_cgraph" alt=""/></div>
<map name="namespacesouffle_a014bc04f4629bd77f3a54c26fe9ea53d_cgraph" id="namespacesouffle_a014bc04f4629bd77f3a54c26fe9ea53d_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a620dc7687473311acaa752a76b5c9470" title="souffle::getEndpoint" alt="" coords="265,5,417,32"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_qualified_name.html#a4b36798d8506689de4ec2794f4777bfa" title="get qualifiers " alt="" coords="245,57,437,98"/>
</map>
</div>

</div>
</div>
<a id="af9432bd085b7e03ea3e138804915e3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9432bd085b7e03ea3e138804915e3b4">&#9670;&nbsp;</a></span>extractConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a>* souffle::extractConstant </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>normalisedConstant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00970">970</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="classsouffle_1_1_ast_numeric_constant.html#a894651635f1b73b977664ca876ae0752a22ae0e2b89e5e3d477f988cc36d3272b">souffle::AstNumericConstant::Float</a>, <a class="el" href="classsouffle_1_1_ast_numeric_constant.html#a894651635f1b73b977664ca876ae0752a1686a6c336b71b36d77354cea19a8b52">souffle::AstNumericConstant::Int</a>, and <a class="el" href="classsouffle_1_1_ast_numeric_constant.html#a894651635f1b73b977664ca876ae0752afa28cf323a8d44edbf80f68165f4f75b">souffle::AstNumericConstant::Uint</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;                                                                  {</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;    <span class="comment">// strip off the prefix up to (and including) the first underscore</span></div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;    <span class="keywordtype">size_t</span> argStart = normalisedConstant.find(<span class="charliteral">&#39;_&#39;</span>);</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;    std::string arg = normalisedConstant.substr(argStart + 1, normalisedConstant.size());</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;    <span class="comment">// -- check if string or num constant --</span></div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;    <span class="keywordtype">char</span> indicatorChar = arg[arg.size() - 1];  <span class="comment">// &#39;n&#39; or &#39;s&#39;</span></div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;    std::string stringRep = arg.substr(0, arg.size() - 2);</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;</div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;    <span class="keywordflow">if</span> (indicatorChar == <span class="charliteral">&#39;s&#39;</span>) {</div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;        <span class="comment">// string argument</span></div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">new</span> AstStringConstant(stringRep);</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (indicatorChar == <span class="charliteral">&#39;n&#39;</span>) {</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;        <span class="comment">// numeric argument</span></div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">new</span> AstNumericConstant(stringRep, AstNumericConstant::Type::Int);</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (indicatorChar == <span class="charliteral">&#39;u&#39;</span>) {</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">new</span> AstNumericConstant(stringRep, AstNumericConstant::Type::Uint);</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (indicatorChar == <span class="charliteral">&#39;f&#39;</span>) {</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">new</span> AstNumericConstant(stringRep, AstNumericConstant::Type::Float);</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;        <span class="comment">// invalid format</span></div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;    }</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a63b103a79e1c9886c80cff614ba6ef93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b103a79e1c9886c80cff614ba6ef93">&#9670;&nbsp;</a></span>extractPermutations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;unsigned int&gt; &gt; souffle::extractPermutations </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; unsigned int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>permutationMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract valid permutations from a given permutation matrix of valid moves. </p>

<p class="definition">Definition at line <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00041">41</a> of file <a class="el" href="_minimise_program_transformer_8cpp_source.html">MinimiseProgramTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="json11_8h_source.html#l00651">i</a>, <a class="el" href="html_js_chartist_min_8h_source.html#l00015">j</a>, and <a class="el" href="_type_system_8cpp_source.html#l00173">seen</a>.</p>

<p class="reference">Referenced by <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00249">areBijectivelyEquivalent()</a>.</p>
<div class="fragment"><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                                                                     {</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <span class="keywordtype">size_t</span> clauseSize = permutationMatrix.size();</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="comment">// keep track of the possible end-positions of each atom in the first clause</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    std::vector&lt;std::vector&lt;unsigned int&gt;&gt; validMoves;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; clauseSize; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        std::vector&lt;unsigned int&gt; currentRow;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> = 0; <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> &lt; clauseSize; <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>++) {</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;            <span class="keywordflow">if</span> (permutationMatrix[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>][<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>] == 1) {</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                currentRow.push_back(<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>);</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;            }</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        }</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        validMoves.push_back(currentRow);</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    }</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="comment">// extract the possible permutations, DFS style</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    std::vector&lt;std::vector&lt;unsigned int&gt;&gt; permutations;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    std::vector&lt;unsigned int&gt; <a class="code" href="_type_system_8cpp.html#a157c8fc15ecc360f080bfd2d5d6ddbff">seen</a>(clauseSize);</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    std::vector&lt;unsigned int&gt; currentPermutation;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    std::stack&lt;std::vector&lt;unsigned int&gt;&gt; todoStack;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    todoStack.push(validMoves[0]);</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="keywordtype">size_t</span> currentIdx = 0;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">while</span> (!todoStack.empty()) {</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        <span class="keywordflow">if</span> (currentIdx == clauseSize) {</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;            <span class="comment">// permutation is complete</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;            permutations.push_back(currentPermutation);</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            <span class="keywordflow">if</span> (currentIdx == 0) {</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                <span class="comment">// already at starting position, so no more permutations possible</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;            }</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            <span class="comment">// undo the last number added to the permutation</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;            currentIdx--;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            <a class="code" href="_type_system_8cpp.html#a157c8fc15ecc360f080bfd2d5d6ddbff">seen</a>[currentPermutation[currentIdx]] = 0;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            currentPermutation.pop_back();</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            <span class="comment">// see if we can pick up other permutations</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        }</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        <span class="comment">// pull out the possibilities for the current point of the permutation</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        std::vector&lt;unsigned int&gt; possibilities = todoStack.top();</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        todoStack.pop();</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        <span class="keywordflow">if</span> (possibilities.empty()) {</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            <span class="comment">// no more possibilities at this point, so undo our last move</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            <span class="keywordflow">if</span> (currentIdx == 0) {</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;                <span class="comment">// already at starting position, so no more permutations possible</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;            }</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;            currentIdx--;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            <a class="code" href="_type_system_8cpp.html#a157c8fc15ecc360f080bfd2d5d6ddbff">seen</a>[currentPermutation[currentIdx]] = 0;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;            currentPermutation.pop_back();</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            <span class="comment">// continue looking for permutations</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        }</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        <span class="comment">// try the next possibility</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextNum = possibilities[0];</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <span class="comment">// update the possibility vector for the current position</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        possibilities.erase(possibilities.begin());</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        todoStack.push(possibilities);</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="_type_system_8cpp.html#a157c8fc15ecc360f080bfd2d5d6ddbff">seen</a>[nextNum] != 0u) {</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;            <span class="comment">// number already seen in this permutation</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;            <span class="comment">// number can be used</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;            <a class="code" href="_type_system_8cpp.html#a157c8fc15ecc360f080bfd2d5d6ddbff">seen</a>[nextNum] = 1;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;            currentPermutation.push_back(nextNum);</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;            currentIdx++;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;            <span class="comment">// if we havent reached the end of the permutation,</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;            <span class="comment">// push up the valid moves for the next position</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;            <span class="keywordflow">if</span> (currentIdx &lt; clauseSize) {</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                todoStack.push(validMoves[currentIdx]);</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;            }</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        }</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    }</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="comment">// found all permutations</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    <span class="keywordflow">return</span> permutations;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_aab858032a95af802114b255fac6f45f2"><div class="ttname"><a href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a></div><div class="ttdeci">var j</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="_type_system_8cpp_html_a157c8fc15ecc360f080bfd2d5d6ddbff"><div class="ttname"><a href="_type_system_8cpp.html#a157c8fc15ecc360f080bfd2d5d6ddbff">seen</a></div><div class="ttdeci">std::map&lt; const Type *, R &gt; seen</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00173">TypeSystem.cpp:173</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8e3419b4e4df09a580063d2f078a3774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3419b4e4df09a580063d2f078a3774">&#9670;&nbsp;</a></span>fileExtension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::fileExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>File extension, with all else removed. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01221">1221</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_synthesiser_8cpp_source.html#l00172">souffle::Synthesiser::emitCode()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l01518">souffle::AstTranslator::translateProgram()</a>.</p>
<div class="fragment"><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;                                                      {</div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;    std::string name = path;</div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> lastDot = name.find_last_of(<span class="charliteral">&#39;.&#39;</span>);</div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;    <span class="comment">// file has no extension</span></div><div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;    <span class="keywordflow">if</span> (lastDot == std::string::npos) {</div><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;        <span class="keywordflow">return</span> std::string();</div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;    }</div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> lastSlash = name.find_last_of(<span class="charliteral">&#39;/&#39;</span>);</div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;    <span class="comment">// last slash occurs after last dot, so no extension</span></div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;    <span class="keywordflow">if</span> (lastSlash != std::string::npos &amp;&amp; lastSlash &gt; lastDot) {</div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;        <span class="keywordflow">return</span> std::string();</div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;    }</div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;    <span class="comment">// last dot after last slash, or no slash</span></div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;    <span class="keywordflow">return</span> name.substr(lastDot + 1);</div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab51824bd98651cf614b712d360070e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51824bd98651cf614b712d360070e97">&#9670;&nbsp;</a></span>findInlineCycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a>&gt; souffle::findInlineCycle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_precedence_graph.html">PrecedenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>precedenceGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *, const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>origins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle.html#a851652d425321cd735fbe321f392fe85">AstRelationSet</a> &amp;&#160;</td>
          <td class="paramname"><em>unvisited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle.html#a851652d425321cd735fbe321f392fe85">AstRelationSet</a> &amp;&#160;</td>
          <td class="paramname"><em>visiting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle.html#a851652d425321cd735fbe321f392fe85">AstRelationSet</a> &amp;&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a cycle consisting entirely of inlined relations. </p>
<p>If no cycle exists, then an empty vector is returned. </p>

<p class="definition">Definition at line <a class="el" href="_ast_semantic_checker_8cpp_source.html#l01141">1141</a> of file <a class="el" href="_ast_semantic_checker_8cpp_source.html">AstSemanticChecker.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_relation_8h_source.html#l00052">souffle::AstRelation::getQualifiedName()</a>, <a class="el" href="_precedence_graph_8h_source.html#l00055">souffle::PrecedenceGraph::graph()</a>, and <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">INLINE</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l01219">souffle::AstSemanticChecker::checkInlining()</a>.</p>
<div class="fragment"><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;                                                                                      {</div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;    std::vector&lt;AstQualifiedName&gt; result;</div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;</div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;    <span class="keywordflow">if</span> (current == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;        <span class="comment">// Not looking at any nodes at the moment, so choose any node from the unvisited list</span></div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;</div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;        <span class="keywordflow">if</span> (unvisited.empty()) {</div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;            <span class="comment">// Nothing left to visit - so no cycles exist!</span></div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;            <span class="keywordflow">return</span> result;</div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;        }</div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;</div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;        <span class="comment">// Choose any element from the unvisited set</span></div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;        current = *unvisited.begin();</div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;        origins[current] = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;</div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;        <span class="comment">// Move it to &quot;currently visiting&quot;</span></div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;        unvisited.erase(current);</div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;        visiting.insert(current);</div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;</div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;        <span class="comment">// Check if we can find a cycle beginning from this node</span></div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;        std::vector&lt;AstQualifiedName&gt; subresult =</div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;                <a class="code" href="namespacesouffle.html#ab51824bd98651cf614b712d360070e97">findInlineCycle</a>(precedenceGraph, origins, current, unvisited, visiting, visited);</div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;</div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;        <span class="keywordflow">if</span> (subresult.empty()) {</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;            <span class="comment">// No cycle found, try again from another node</span></div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#ab51824bd98651cf614b712d360070e97">findInlineCycle</a>(precedenceGraph, origins, <span class="keyword">nullptr</span>, unvisited, visiting, visited);</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;            <span class="comment">// Cycle found! Return it</span></div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;            <span class="keywordflow">return</span> subresult;</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;        }</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;    }</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;    <span class="comment">// Check neighbours</span></div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespacesouffle.html#a851652d425321cd735fbe321f392fe85">AstRelationSet</a>&amp; successors = precedenceGraph.graph().successors(current);</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> AstRelation* successor : successors) {</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;        <span class="comment">// Only care about inlined neighbours in the graph</span></div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;        <span class="keywordflow">if</span> (successor-&gt;hasQualifier(RelationQualifier::INLINE)) {</div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;            <span class="keywordflow">if</span> (visited.find(successor) != visited.end()) {</div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;                <span class="comment">// The neighbour has already been visited, so move on</span></div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;                <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;            }</div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;            <span class="keywordflow">if</span> (visiting.find(successor) != visiting.end()) {</div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;                <span class="comment">// Found a cycle!!</span></div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;                <span class="comment">// Construct the cycle in reverse</span></div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;                <span class="keywordflow">while</span> (current != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;                    result.push_back(current-&gt;getQualifiedName());</div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;                    current = origins[current];</div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;                }</div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;                <span class="keywordflow">return</span> result;</div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;            }</div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;</div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;            <span class="comment">// Node has not been visited yet</span></div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;            origins[successor] = current;</div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;</div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;            <span class="comment">// Move from unvisited to visiting</span></div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;            unvisited.erase(successor);</div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;            visiting.insert(successor);</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;</div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;            <span class="comment">// Visit recursively and check if a cycle is formed</span></div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;            std::vector&lt;AstQualifiedName&gt; subgraphCycle =</div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;                    <a class="code" href="namespacesouffle.html#ab51824bd98651cf614b712d360070e97">findInlineCycle</a>(precedenceGraph, origins, successor, unvisited, visiting, visited);</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;</div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;            <span class="keywordflow">if</span> (!subgraphCycle.empty()) {</div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;                <span class="comment">// Found a cycle!</span></div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;                <span class="keywordflow">return</span> subgraphCycle;</div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;            }</div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;        }</div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;    }</div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;</div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;    <span class="comment">// Visited all neighbours with no cycle found, so done visiting this node.</span></div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;    visiting.erase(current);</div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;    visited.insert(current);</div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;    <span class="keywordflow">return</span> result;</div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_ab51824bd98651cf614b712d360070e97"><div class="ttname"><a href="namespacesouffle.html#ab51824bd98651cf614b712d360070e97">souffle::findInlineCycle</a></div><div class="ttdeci">std::vector&lt; AstQualifiedName &gt; findInlineCycle(const PrecedenceGraph &amp;precedenceGraph, std::map&lt; const AstRelation *, const AstRelation *&gt; &amp;origins, const AstRelation *current, AstRelationSet &amp;unvisited, AstRelationSet &amp;visiting, AstRelationSet &amp;visited)</div><div class="ttdoc">Find a cycle consisting entirely of inlined relations. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_semantic_checker_8cpp_source.html#l01141">AstSemanticChecker.cpp:1141</a></div></div>
<div class="ttc" id="namespacesouffle_html_a851652d425321cd735fbe321f392fe85"><div class="ttname"><a href="namespacesouffle.html#a851652d425321cd735fbe321f392fe85">souffle::AstRelationSet</a></div><div class="ttdeci">std::set&lt; const AstRelation *, AstNameComparison &gt; AstRelationSet</div><div class="ttdef"><b>Definition:</b> <a href="_ast_relation_8h_source.html#l00181">AstRelation.h:181</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ab51824bd98651cf614b712d360070e97_cgraph.png" border="0" usemap="#namespacesouffle_ab51824bd98651cf614b712d360070e97_cgraph" alt=""/></div>
<map name="namespacesouffle_ab51824bd98651cf614b712d360070e97_cgraph" id="namespacesouffle_ab51824bd98651cf614b712d360070e97_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_relation.html#a5db8b505969c2f75286a54875c4aaed1" title="get qualified relation name " alt="" coords="244,5,392,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1_precedence_graph.html#aeae99542b6e88834762fbef7e239a2b5" title="souffle::PrecedenceGraph\l::graph" alt="" coords="224,71,412,112"/>
</map>
</div>

</div>
</div>
<a id="af944f0c474df29e5c8e45e4b7df60be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af944f0c474df29e5c8e45e4b7df60be5">&#9670;&nbsp;</a></span>findTool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::findTool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01165">1165</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="main_8cpp_source.html#l00124">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;                                                                                               {</div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;    std::string dir = <a class="code" href="namespacesouffle.html#a72e10d44624c80609e5c09b131ecf3fb">dirName</a>(<a class="code" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a>);</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;    std::stringstream sstr(path);</div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;    std::string <a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>;</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;    <span class="keywordflow">while</span> (std::getline(sstr, sub, <span class="charliteral">&#39;:&#39;</span>)) {</div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;        std::string subpath = dir + <span class="stringliteral">&quot;/&quot;</span> + sub + <span class="charliteral">&#39;/&#39;</span> + tool;</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">isExecutable</a>(subpath)) {</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a8a2c294e3ff514cd4ca29b466ff3cab3">absPath</a>(subpath);</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;        }</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;    }</div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;    <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a72e10d44624c80609e5c09b131ecf3fb"><div class="ttname"><a href="namespacesouffle.html#a72e10d44624c80609e5c09b131ecf3fb">souffle::dirName</a></div><div class="ttdeci">std::string dirName(const std::string &amp;name)</div><div class="ttdoc">C++-style dirname. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01115">Util.h:1115</a></div></div>
<div class="ttc" id="namespacesouffle_html_a7f93cdf21f1a24b593da6691dc892828"><div class="ttname"><a href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">souffle::sub</a></div><div class="ttdeci">std::shared_ptr&lt; Constraint&lt; Var &gt; &gt; sub(const Var &amp;a, const Var &amp;b, const std::string &amp;symbol=&quot;⊑&quot;)</div><div class="ttdoc">A generic factory for constraints of the form. </div><div class="ttdef"><b>Definition:</b> <a href="_constraints_8h_source.html#l00221">Constraints.h:221</a></div></div>
<div class="ttc" id="_reader_8h_html_a4ce824b383e7379148b61ee135baac5a"><div class="ttname"><a href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a></div><div class="ttdeci">T &amp; base</div><div class="ttdef"><b>Definition:</b> <a href="_reader_8h_source.html#l00060">Reader.h:60</a></div></div>
<div class="ttc" id="namespacesouffle_html_a64753e143a37bb9414121fc75987cb14"><div class="ttname"><a href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">souffle::isExecutable</a></div><div class="ttdeci">bool isExecutable(const std::string &amp;name)</div><div class="ttdoc">Check whether a given file exists and it is an executable. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01084">Util.h:1084</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8a2c294e3ff514cd4ca29b466ff3cab3"><div class="ttname"><a href="namespacesouffle.html#a8a2c294e3ff514cd4ca29b466ff3cab3">souffle::absPath</a></div><div class="ttdeci">std::string absPath(const std::string &amp;path)</div><div class="ttdoc">C++-style realpath. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01139">Util.h:1139</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a857e90591811f5da8f9f86461c2f697c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857e90591811f5da8f9f86461c2f697c">&#9670;&nbsp;</a></span>formatCodeSection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_debug_report_section.html">DebugReportSection</a> souffle::formatCodeSection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_debug_reporter_8cpp_source.html#l00050">50</a> of file <a class="el" href="_debug_reporter_8cpp_source.html">DebugReporter.cpp</a>.</p>

<p class="reference">References <a class="el" href="json11_8h_source.html#l00651">i</a>.</p>
<div class="fragment"><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                                                                                                  {</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    std::stringstream codeHTML;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    std::string escapedCode = std::move(code);</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        <span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = escapedCode.find(<span class="stringliteral">&quot;&lt;&quot;</span>);</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keywordflow">if</span> (i == std::string::npos) {</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        }</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        escapedCode.replace(i, 1, <span class="stringliteral">&quot;&amp;lt;&quot;</span>);</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    }</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    codeHTML &lt;&lt; <span class="stringliteral">&quot;&lt;pre&gt;&quot;</span> &lt;&lt; escapedCode &lt;&lt; <span class="stringliteral">&quot;&lt;/pre&gt;\n&quot;</span>;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="keywordflow">return</span> DebugReportSection(<span class="keywordtype">id</span>, title, codeHTML.str());</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2e5ef82376f71d4d7ebfcfa64437d540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5ef82376f71d4d7ebfcfa64437d540">&#9670;&nbsp;</a></span>formNegatedLiterals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a>*&gt; &gt; souffle::formNegatedLiterals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&#160;</td>
          <td class="paramname"><em>atom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the bodies that will replace the negation of a given inlined atom. </p>
<p>E.g. a(x) &lt;- (a11(x), a12(x)) ; (a21(x), a22(x)) =&gt; !a(x) &lt;- (!a11(x), !a21(x)) ; (!a11(x), !a22(x)) ; ... Essentially, produce every combination (m_1 ^ m_2 ^ ...) where m_i is the negation of a literal in the ith rule of a. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00422">422</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00366">combineNegatedLiterals()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00042">getClauses()</a>, <a class="el" href="_ast_literal_8h_source.html#l00058">souffle::AstAtom::getQualifiedName()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00056">getRelation()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00057">souffle::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00281">inlineBodyLiterals()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00053">souffle::NullableVector&lt; T &gt;::isValid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00787">getInlinedLiteral()</a>.</p>
<div class="fragment"><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;                                                                                          {</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    <span class="comment">// Constraints added to unify atoms should not be negated and should be added to</span></div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    <span class="comment">// all the final rule combinations produced, and so should be stored separately.</span></div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    std::vector&lt;std::vector&lt;AstLiteral*&gt;&gt; addedBodyLiterals;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    std::vector&lt;std::vector&lt;AstBinaryConstraint*&gt;&gt; addedConstraints;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    <span class="comment">// Go through every possible clause associated with the given atom</span></div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <span class="keywordflow">for</span> (AstClause* inClause : <a class="code" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">getClauses</a>(program, *<a class="code" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">getRelation</a>(program, atom-&gt;getQualifiedName()))) {</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;        <span class="comment">// Form the replacement clause by inlining based on the current clause</span></div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;        std::pair&lt;NullableVector&lt;AstLiteral*&gt;, std::vector&lt;AstBinaryConstraint*&gt;&gt; inlineResult =</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;                <a class="code" href="namespacesouffle.html#a7dfca9e9addfda4f3e1ee38cbef0d7c0">inlineBodyLiterals</a>(atom, inClause);</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;        NullableVector&lt;AstLiteral*&gt; replacementBodyLiterals = inlineResult.first;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;        std::vector&lt;AstBinaryConstraint*&gt; currConstraints = inlineResult.second;</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;        <span class="keywordflow">if</span> (!replacementBodyLiterals.isValid()) {</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;            <span class="comment">// Failed to unify, so just move on</span></div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        }</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;        addedBodyLiterals.push_back(replacementBodyLiterals.getVector());</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        addedConstraints.push_back(currConstraints);</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    }</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    <span class="comment">// We now have a list of bodies needed to inline the given atom.</span></div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    <span class="comment">// We want to inline the negated version, however, which is done using De Morgan&#39;s Law.</span></div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    std::vector&lt;std::vector&lt;AstLiteral*&gt;&gt; negatedAddedBodyLiterals =</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;            <a class="code" href="namespacesouffle.html#a0e3e2145b6ac09dba3c7ba2e5535935f">combineNegatedLiterals</a>(addedBodyLiterals);</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    <span class="comment">// Add in the necessary constraints to all the body literals</span></div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; negatedAddedBodyLiteral : negatedAddedBodyLiterals) {</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;        <span class="keywordflow">for</span> (std::vector&lt;AstBinaryConstraint*&gt; constraintGroup : addedConstraints) {</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;            <span class="keywordflow">for</span> (AstBinaryConstraint* constraint : constraintGroup) {</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;                negatedAddedBodyLiteral.push_back(constraint-&gt;clone());</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;            }</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;        }</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    }</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <span class="comment">// Free up the old body literals and constraints</span></div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    <span class="keywordflow">for</span> (std::vector&lt;AstLiteral*&gt; litGroup : addedBodyLiterals) {</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;        <span class="keywordflow">for</span> (AstLiteral* lit : litGroup) {</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;            <span class="keyword">delete</span> lit;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;        }</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    }</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    <span class="keywordflow">for</span> (std::vector&lt;AstBinaryConstraint*&gt; consGroup : addedConstraints) {</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        <span class="keywordflow">for</span> (AstConstraint* cons : consGroup) {</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;            <span class="keyword">delete</span> cons;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        }</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    }</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    <span class="keywordflow">return</span> negatedAddedBodyLiterals;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a7dfca9e9addfda4f3e1ee38cbef0d7c0"><div class="ttname"><a href="namespacesouffle.html#a7dfca9e9addfda4f3e1ee38cbef0d7c0">souffle::inlineBodyLiterals</a></div><div class="ttdeci">std::pair&lt; NullableVector&lt; AstLiteral * &gt;, std::vector&lt; AstBinaryConstraint * &gt; &gt; inlineBodyLiterals(AstAtom *atom, AstClause *atomInlineClause)</div><div class="ttdoc">Inlines the given atom based on a given clause. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00281">InlineRelationsTransformer.cpp:281</a></div></div>
<div class="ttc" id="namespacesouffle_html_ada252aa15afbf7d703a11b000dfd4048"><div class="ttname"><a href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">souffle::getRelation</a></div><div class="ttdeci">AstRelation * getRelation(const AstProgram &amp;program, const AstQualifiedName &amp;name)</div><div class="ttdoc">Returns the relation with the given name in the program. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00056">AstUtils.cpp:56</a></div></div>
<div class="ttc" id="namespacesouffle_html_a0e3e2145b6ac09dba3c7ba2e5535935f"><div class="ttname"><a href="namespacesouffle.html#a0e3e2145b6ac09dba3c7ba2e5535935f">souffle::combineNegatedLiterals</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; AstLiteral * &gt; &gt; combineNegatedLiterals(std::vector&lt; std::vector&lt; AstLiteral *&gt;&gt; litGroups)</div><div class="ttdoc">Return the negated version of a disjunction of conjunctions. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00366">InlineRelationsTransformer.cpp:366</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4d9e53888640a9abfd7ea7c43715152a"><div class="ttname"><a href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">souffle::getClauses</a></div><div class="ttdeci">std::vector&lt; AstClause * &gt; getClauses(const AstProgram &amp;program, const AstQualifiedName &amp;relationName)</div><div class="ttdoc">Returns a vector of clauses in the program describing the relation with the given name...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00042">AstUtils.cpp:42</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a2e5ef82376f71d4d7ebfcfa64437d540_cgraph.png" border="0" usemap="#namespacesouffle_a2e5ef82376f71d4d7ebfcfa64437d540_cgraph" alt=""/></div>
<map name="namespacesouffle_a2e5ef82376f71d4d7ebfcfa64437d540_cgraph" id="namespacesouffle_a2e5ef82376f71d4d7ebfcfa64437d540_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a0e3e2145b6ac09dba3c7ba2e5535935f" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="261,187,495,213"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="793,980,939,1007"/>
<area shape="rect" id="node13" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="1009,259,1265,285"/>
<area shape="rect" id="node14" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="792,236,940,263"/>
<area shape="rect" id="node17" href="classsouffle_1_1_nullable_vector.html#ad94b793fbfe9e5d0175becd240539fbc" title="souffle::NullableVector\l::getVector" alt="" coords="293,505,463,546"/>
<area shape="rect" id="node20" href="namespacesouffle.html#a7dfca9e9addfda4f3e1ee38cbef0d7c0" title="Inlines the given atom based on a given clause. " alt="" coords="771,669,961,696"/>
<area shape="rect" id="node29" href="classsouffle_1_1_nullable_vector.html#ab04c65c2ed18c2756c463c50de1912e8" title="souffle::NullableVector\l::isValid" alt="" coords="1344,805,1513,846"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d" title="Returns the negated version of a given literal. " alt="" coords="553,119,713,145"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Create a clone (i.e. " alt="" coords="779,31,953,57"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_constraint.html#a4bc070302396ff2bee073f62c00b5e21" title="Create a clone (i.e. " alt="" coords="785,82,947,123"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a4a2b4fc7558b8bce98ff88f8e10b516e" title="Negate an ast constraint. " alt="" coords="773,148,959,175"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#acef18129b13ce45477044717ded051d2" title="souffle::AstAtom::AstAtom" alt="" coords="1040,5,1235,32"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="1329,309,1529,336"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="1031,107,1243,133"/>
<area shape="rect" id="node11" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="1353,947,1504,989"/>
<area shape="rect" id="node12" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1611,779,1757,805"/>
<area shape="rect" id="node15" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1085,157,1189,184"/>
<area shape="rect" id="node16" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="1353,222,1504,263"/>
<area shape="rect" id="node18" href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1" title="Tries to perform a single step of inlining on the given literal. " alt="" coords="543,540,723,567"/>
<area shape="rect" id="node19" href="classsouffle_1_1_ast_relation.html#a698481c4da3f71880cb2cf8c622a9cdc" title="check for a relation qualifier " alt="" coords="792,603,940,645"/>
<area shape="rect" id="node31" href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1" title="Returns a vector of atoms that should replace the given atom after one step of inlining. " alt="" coords="779,477,953,504"/>
<area shape="rect" id="node32" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2" title="Returns a vector of arguments that should replace the given argument after one step of inlining..." alt="" coords="1036,477,1239,504"/>
<area shape="rect" id="node21" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Create a clone (i.e. " alt="" coords="1068,411,1207,453"/>
<area shape="rect" id="node23" href="classsouffle_1_1_ast_clause.html#ab7a5b630d02cd69873aab066c2bd9c46" title="Apply the mapper to all child nodes. " alt="" coords="1068,746,1207,787"/>
<area shape="rect" id="node24" href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="1063,579,1212,605"/>
<area shape="rect" id="node28" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="1068,681,1207,722"/>
<area shape="rect" id="node30" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="1068,863,1207,905"/>
<area shape="rect" id="node22" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="1374,368,1483,395"/>
<area shape="rect" id="node25" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="1313,587,1544,613"/>
<area shape="rect" id="node26" href="namespacesouffle.html#a659ae2c89cfab47908f27a660f82c147" title="Reduces a vector of substitutions. " alt="" coords="1331,637,1527,664"/>
<area shape="rect" id="node27" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828" title="A generic factory for constraints of the form. " alt="" coords="1635,637,1733,664"/>
<area shape="rect" id="node33" href="classsouffle_1_1_ast_aggregator.html#a427d81a0d8eb9c03d0ab86ef3ef78d5d" title="souffle::AstAggregator\l::setBody" alt="" coords="1345,521,1512,562"/>
<area shape="rect" id="node34" href="namespacesouffle.html#a42c2f399b871f8fe7f0ba652812e2db5" title="souffle::combineAggregators" alt="" coords="1324,419,1533,445"/>
<area shape="rect" id="node38" href="classsouffle_1_1_ast_node.html#a0b664297f0971c6ce32ff2e0e4f2603f" title="Set source location for the AstNode. " alt="" coords="1329,469,1528,496"/>
<area shape="rect" id="node35" href="namespacesouffle.html#a1193e67992e4f0591e4011faccb4abe2" title="Checks whether a functor operation can have a given argument count. " alt="" coords="1593,382,1775,423"/>
<area shape="rect" id="node36" href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961" title="Renames all variables in a given argument uniquely. " alt="" coords="1592,448,1776,475"/>
<area shape="rect" id="node37" href="classsouffle_1_1_ast_node.html#ad7c4f8ce0322749e72ed60f543c6fd93" title="Apply the mapper to all child nodes. " alt="" coords="1824,448,1997,475"/>
</map>
</div>

</div>
</div>
<a id="a100b2775490c4c9f1d565290237ee51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100b2775490c4c9f1d565290237ee51a">&#9670;&nbsp;</a></span>functorOpArgType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> souffle::functorOpArgType </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the type of argument indicated by arg (0-indexed) of a functor op. </p>

<p class="definition">Definition at line <a class="el" href="_functor_ops_8h_source.html#l00362">362</a> of file <a class="el" href="_functor_ops_8h_source.html">FunctorOps.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9eeb52badb613229884838847294b90d">ADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aa8a5bbeedca093b94b7f0d3f185b98f7">BAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0fd78279a775c262180e0cfbad6fa9eb">BNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0adf6aac232504c55ea4202e09498bfd">BOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a88d973d6a866ababf2fb28a6112f8d46">BSHIFT_L</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9e74511ce5c138f374559a76abb6e209">BSHIFT_R</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3fdb4dd3e2677523449a3747923d4401">BSHIFT_R_UNSIGNED</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a21506bac4ecfbfe4272b9bf8185446b6">BXOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac01ae1a5f122f25ce5675f86028b536a">CAT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a29bbf66f7f8529ec47e394fb5a36c646">DIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc2cbacfa7c4ef9bc72773ebdd9fe166">FADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9abccb2b7436e0cbfb334fe07304fe28a6">FDIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a107c7a3cc48a0fe27d435e82c8679ef0">FEXP</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a22ae0e2b89e5e3d477f988cc36d3272b">Float</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1">FMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6">FMIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a26a83f923754f1e7aa12640b8bcca29a">FMUL</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a36da8d8fdce0e080abfcab7af41066c6">FNEG</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a06be1058e817f781f4e0f0641f436247">FSUB</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a81bf488d5db54d36a738384aaf845fdf">FTOI</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a89aa92cb66549459a7d407094aacbcef">FTOU</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc526b23b5b6d76a12984c29bf63c4a3">ITOF</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4c0f1a4930775ab571de3e85aedc623e">ITOU</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a479a809c0b6eaaefd3b1df16f976df06">LAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a81145009eec44ad2c399c9459a01d8f0">LNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ad3335c358811cfc353257e21b1d38229">LOR</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">MAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">MIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac5a28f4b35a2884fa3277150ac5d0967">MOD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2cdf52a55876063ec93b7d18bc741f6c">MUL</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a5dd68b1a7db42a1cce4dce09dbaa179e">NEG</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac23431d0209648a6b31fa837dd56d681">ORD</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a6a0d9eaee314c567fd72fb97ee707a36">Record</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379">Signed</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a00e365acdc6de6b62421116e865bd420">SMAX</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2d9174ad446fde0fc750265f9e075977">SMIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc37711c3936f2459ef27e1dbe4f6480">STRLEN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a241dd841abade20fcb27b8a9f494e1eb">SUB</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0f85e58dd75e7025beb47ee590ff7669">SUBSTR</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a02c86eb2792f3262c21d030a87e19793">Symbol</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aae9c007a17eb01f69e2dba22cf15cf30">TONUMBER</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a91b8cf1c9769ddb9cb64191c89becc1b">TOSTRING</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a1f0002abde2c29615d914ab0228c68d3">UADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ab5755f546c5f5ca6a3f1720ef8e642ef">UBAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac2fc8ad7a275c06c870529f9f9f07caa">UBNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4803dabeb7190f48195a26654eafaa42">UBOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a653789f2eb8bfa402c5f60ceceac247b">UBSHIFT_L</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aab623d5679ac1cc907cb363e2d51eb14">UBSHIFT_R</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a07da89f09f961f63a15696ac57bbc1c3">UBSHIFT_R_UNSIGNED</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a70f4367aed9601f37bfbdd4586b327df">UBXOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a56d5c96c848631ef14e1f2a6e0f15d49">UDIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a59407eef1229dea3aac5dc8d77d06c92">UEXP</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3d0f34d8e784f8a48332424dd598a27a">ULAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a7fdc4b2848234d42fe9a22b78fd68910">ULNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9addb2113545b6bd7fbe64ed7bff507964">ULOR</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059">UMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb">UMIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4bbe00e945b01d43cb7edecf51b0de5c">UMOD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ae89690f1278cca1400678daaa4a6a3b7">UMUL</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0aa1a914735b205424ba6c40b85528d78a">Unsigned</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9af8aba91736be4bad67181a8cce032337">USUB</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9d0ef69432b16260e9622b4f614bc9c5">UTOF</a>, and <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac059c9401f1af0e831f9f180f3c6bfef">UTOI</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_argument_8h_source.html#l00303">souffle::AstIntrinsicFunctor::getArgType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;                                                                            {</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    <span class="keywordflow">switch</span> (op) {</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        <span class="comment">// Special case</span></div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ORD:</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;            assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;ord is a special function that returns a Ram Representation of the element&quot;</span>);</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ITOF:</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ITOU:</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;        <span class="keywordflow">case</span> FunctorOp::NEG:</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BNOT:</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LNOT:</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        <span class="keywordflow">case</span> FunctorOp::TOSTRING:</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;            assert(arg == 0 &amp;&amp; <span class="stringliteral">&quot;unary functor out of bound&quot;</span>);</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Signed;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FNEG:</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FTOI:</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FTOU:</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;            assert(arg == 0 &amp;&amp; <span class="stringliteral">&quot;unary functor out of bound&quot;</span>);</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Float;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        <span class="keywordflow">case</span> FunctorOp::STRLEN:</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        <span class="keywordflow">case</span> FunctorOp::TONUMBER:</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;            assert(arg == 0 &amp;&amp; <span class="stringliteral">&quot;unary functor out of bound&quot;</span>);</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Symbol;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBNOT:</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ULNOT:</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UTOI:</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UTOF:</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;            assert(arg == 0 &amp;&amp; <span class="stringliteral">&quot;unary functor out of bound&quot;</span>);</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Unsigned;</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ADD:</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SUB:</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MUL:</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;        <span class="keywordflow">case</span> FunctorOp::DIV:</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;        <span class="keywordflow">case</span> FunctorOp::EXP:</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MOD:</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BAND:</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BOR:</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BXOR:</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_L:</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_R:</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_R_UNSIGNED:</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LAND:</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LOR:</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;            assert(arg &lt; 2 &amp;&amp; <span class="stringliteral">&quot;binary functor out of bound&quot;</span>);</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Signed;</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UADD:</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;        <span class="keywordflow">case</span> FunctorOp::USUB:</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMUL:</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UDIV:</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UEXP:</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMOD:</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBAND:</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBOR:</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBXOR:</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBSHIFT_L:</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBSHIFT_R:</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBSHIFT_R_UNSIGNED:</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ULAND:</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ULOR:</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;            assert(arg &lt; 2 &amp;&amp; <span class="stringliteral">&quot;binary functor out of bound&quot;</span>);</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Unsigned;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FADD:</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FSUB:</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FMUL:</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FDIV:</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FEXP:</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;            assert(arg &lt; 2 &amp;&amp; <span class="stringliteral">&quot;binary functor out of bound&quot;</span>);</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Float;</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SUBSTR:</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;            assert(arg &lt; 3 &amp;&amp; <span class="stringliteral">&quot;ternary functor out of bound&quot;</span>);</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;            <span class="keywordflow">if</span> (arg == 0) {</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;                <span class="keywordflow">return</span> TypeAttribute::Symbol;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;                <span class="keywordflow">return</span> TypeAttribute::Signed;  <span class="comment">// In the future: Change to unsigned</span></div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;            }</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MAX:</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MIN:</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Signed;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMAX:</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMIN:</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Unsigned;</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FMAX:</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FMIN:</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Float;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SMAX:</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SMIN:</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;        <span class="keywordflow">case</span> FunctorOp::CAT:</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Symbol;</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    }</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;unsupported operator&quot;</span>);</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    exit(EXIT_FAILURE);</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    <span class="keywordflow">return</span> TypeAttribute::Record;  <span class="comment">// silence warning.</span></div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a924f2efd1cd04ea4336ba44b6aa18e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924f2efd1cd04ea4336ba44b6aa18e72">&#9670;&nbsp;</a></span>functorReturnType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> souffle::functorReturnType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a>&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check a functor's return type (codomain). </p>

<p class="definition">Definition at line <a class="el" href="_functor_ops_8h_source.html#l00288">288</a> of file <a class="el" href="_functor_ops_8h_source.html">FunctorOps.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9eeb52badb613229884838847294b90d">ADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aa8a5bbeedca093b94b7f0d3f185b98f7">BAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0fd78279a775c262180e0cfbad6fa9eb">BNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0adf6aac232504c55ea4202e09498bfd">BOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a88d973d6a866ababf2fb28a6112f8d46">BSHIFT_L</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9e74511ce5c138f374559a76abb6e209">BSHIFT_R</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3fdb4dd3e2677523449a3747923d4401">BSHIFT_R_UNSIGNED</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a21506bac4ecfbfe4272b9bf8185446b6">BXOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac01ae1a5f122f25ce5675f86028b536a">CAT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a29bbf66f7f8529ec47e394fb5a36c646">DIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc2cbacfa7c4ef9bc72773ebdd9fe166">FADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9abccb2b7436e0cbfb334fe07304fe28a6">FDIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a107c7a3cc48a0fe27d435e82c8679ef0">FEXP</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a22ae0e2b89e5e3d477f988cc36d3272b">Float</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1">FMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6">FMIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a26a83f923754f1e7aa12640b8bcca29a">FMUL</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a36da8d8fdce0e080abfcab7af41066c6">FNEG</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a06be1058e817f781f4e0f0641f436247">FSUB</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a81bf488d5db54d36a738384aaf845fdf">FTOI</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a89aa92cb66549459a7d407094aacbcef">FTOU</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc526b23b5b6d76a12984c29bf63c4a3">ITOF</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4c0f1a4930775ab571de3e85aedc623e">ITOU</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a479a809c0b6eaaefd3b1df16f976df06">LAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a81145009eec44ad2c399c9459a01d8f0">LNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ad3335c358811cfc353257e21b1d38229">LOR</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">MAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">MIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac5a28f4b35a2884fa3277150ac5d0967">MOD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2cdf52a55876063ec93b7d18bc741f6c">MUL</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a5dd68b1a7db42a1cce4dce09dbaa179e">NEG</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac23431d0209648a6b31fa837dd56d681">ORD</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a6a0d9eaee314c567fd72fb97ee707a36">Record</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379">Signed</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a00e365acdc6de6b62421116e865bd420">SMAX</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2d9174ad446fde0fc750265f9e075977">SMIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc37711c3936f2459ef27e1dbe4f6480">STRLEN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a241dd841abade20fcb27b8a9f494e1eb">SUB</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0f85e58dd75e7025beb47ee590ff7669">SUBSTR</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a02c86eb2792f3262c21d030a87e19793">Symbol</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aae9c007a17eb01f69e2dba22cf15cf30">TONUMBER</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a91b8cf1c9769ddb9cb64191c89becc1b">TOSTRING</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a1f0002abde2c29615d914ab0228c68d3">UADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ab5755f546c5f5ca6a3f1720ef8e642ef">UBAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac2fc8ad7a275c06c870529f9f9f07caa">UBNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4803dabeb7190f48195a26654eafaa42">UBOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a653789f2eb8bfa402c5f60ceceac247b">UBSHIFT_L</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aab623d5679ac1cc907cb363e2d51eb14">UBSHIFT_R</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a07da89f09f961f63a15696ac57bbc1c3">UBSHIFT_R_UNSIGNED</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a70f4367aed9601f37bfbdd4586b327df">UBXOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a56d5c96c848631ef14e1f2a6e0f15d49">UDIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a59407eef1229dea3aac5dc8d77d06c92">UEXP</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3d0f34d8e784f8a48332424dd598a27a">ULAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a7fdc4b2848234d42fe9a22b78fd68910">ULNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9addb2113545b6bd7fbe64ed7bff507964">ULOR</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059">UMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb">UMIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4bbe00e945b01d43cb7edecf51b0de5c">UMOD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ae89690f1278cca1400678daaa4a6a3b7">UMUL</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0aa1a914735b205424ba6c40b85528d78a">Unsigned</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9af8aba91736be4bad67181a8cce032337">USUB</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9d0ef69432b16260e9622b4f614bc9c5">UTOF</a>, and <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac059c9401f1af0e831f9f180f3c6bfef">UTOI</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_argument_8h_source.html#l00298">souffle::AstIntrinsicFunctor::getReturnType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                                                           {</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <span class="keywordflow">switch</span> (op) {</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ORD:</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keywordflow">case</span> FunctorOp::STRLEN:</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        <span class="keywordflow">case</span> FunctorOp::NEG:</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BNOT:</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LNOT:</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        <span class="keywordflow">case</span> FunctorOp::TONUMBER:</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ADD:</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SUB:</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MUL:</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        <span class="keywordflow">case</span> FunctorOp::DIV:</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        <span class="keywordflow">case</span> FunctorOp::EXP:</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BAND:</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BOR:</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BXOR:</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_L:</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_R:</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_R_UNSIGNED:</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LAND:</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LOR:</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MOD:</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MAX:</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MIN:</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FTOI:</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UTOI:</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Signed;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBNOT:</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ITOU:</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FTOU:</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ULNOT:</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UADD:</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;        <span class="keywordflow">case</span> FunctorOp::USUB:</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMUL:</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UDIV:</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UEXP:</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMAX:</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMIN:</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMOD:</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBAND:</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBOR:</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBXOR:</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBSHIFT_L:</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBSHIFT_R:</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBSHIFT_R_UNSIGNED:</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ULAND:</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ULOR:</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Unsigned;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FMAX:</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FMIN:</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FNEG:</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FADD:</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FSUB:</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ITOF:</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UTOF:</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FMUL:</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FDIV:</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FEXP:</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Float;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SMAX:</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SMIN:</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        <span class="keywordflow">case</span> FunctorOp::TOSTRING:</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        <span class="keywordflow">case</span> FunctorOp::CAT:</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SUBSTR:</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Symbol;</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    }</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Bad functor return type query&quot;</span>);</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    exit(EXIT_FAILURE);</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="keywordflow">return</span> TypeAttribute::Record;  <span class="comment">// Silence warning.</span></div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ae8dc819c0300aaaafa4ef9c7cdd84d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8dc819c0300aaaafa4ef9c7cdd84d4d">&#9670;&nbsp;</a></span>genJsonRules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream&amp; souffle::genJsonRules </td>
          <td>(</td>
          <td class="paramtype">std::stringstream &amp;&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_tui_8h_source.html#l00322">322</a> of file <a class="el" href="_tui_8h_source.html">Tui.h</a>.</p>

<p class="reference">References <a class="el" href="_string_utils_8h_source.html#l00247">souffle::profile::Tools::cleanJsonOut()</a>, <a class="el" href="_output_processor_8h_source.html#l00040">souffle::profile::OutputProcessor::getProgramRun()</a>, <a class="el" href="profile_2_table_8h_source.html#l00033">souffle::profile::Table::getRows()</a>, <a class="el" href="_output_processor_8h_source.html#l00273">souffle::profile::OutputProcessor::getVersions()</a>, <a class="el" href="json11_8h_source.html#l00651">i</a>, <a class="el" href="_table_8h_source.html#l00100">souffle::Table&lt; T, blockSize &gt;::size()</a>, <a class="el" href="_string_utils_8h_source.html#l00177">souffle::profile::Tools::split()</a>, <a class="el" href="_tui_8h_source.html#l00319">souffle::profile::ss</a>, and <a class="el" href="_util_8h_source.html#l00793">toString()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_tui_8h_source.html#l00532">genJsonAtoms()</a>.</p>
<div class="fragment"><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                                                                                              {</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        <span class="keyword">const</span> std::shared_ptr&lt;ProgramRun&gt;&amp; run = out.getProgramRun();</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        <span class="keyword">auto</span> comma = [&amp;<a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a>](<span class="keywordtype">bool</span>&amp; first, <span class="keyword">const</span> std::string&amp; delimiter = <span class="stringliteral">&quot;, &quot;</span>) {</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;            <span class="keywordflow">if</span> (!first) {</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; delimiter;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                first = <span class="keyword">false</span>;</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;            }</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;        };</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; <span class="charliteral">&#39;&quot;&#39;</span> &lt;&lt; name &lt;&lt; R<span class="stringliteral">&quot;_(&quot;:{)_&quot;;</span></div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="stringliteral">        </span><span class="keywordtype">bool</span> firstRow = <span class="keyword">true</span>;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        <span class="keyword">auto</span> rows = ruleTable.getRows();</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        std::stable_sort(rows.begin(), rows.end(), [](std::shared_ptr&lt;Row&gt; left, std::shared_ptr&lt;Row&gt; right) {</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;            <span class="keywordflow">return</span> (*left)[0]-&gt;getDoubleVal() &gt; (*right)[0]-&gt;getDoubleVal();</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        });</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        maxRows = std::min(rows.size(), maxRows);</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; maxRows; ++<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>) {</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;            Row&amp; row = *rows[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;            std::vector&lt;std::string&gt; part = <a class="code" href="namespacesouffle.html#a2925d5d1ec64b003a6b111ed29a2392b">Tools::split</a>(row[6]-&gt;<a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(0), <span class="stringliteral">&quot;.&quot;</span>);</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;            std::string strRel = <span class="stringliteral">&quot;R&quot;</span> + part[0].substr(1);</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;            Table versionTable = out.getVersions(strRel, row[6]-&gt;<a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(0));</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;            std::string src;</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;            <span class="keywordflow">if</span> (versionTable.rows.size() &gt; 0) {</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                <span class="keywordflow">if</span> (versionTable.rows[0]-&gt;cells[9] != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                    src = (*versionTable.rows[0])[9]-&gt;<a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(0);</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;                    src = <span class="stringliteral">&quot;-&quot;</span>;</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                }</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                src = row[10]-&gt;toString(-1);</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;            }</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;            comma(firstRow);</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;            <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; <span class="stringliteral">&quot;\n &quot;</span>;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;            <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; <span class="charliteral">&#39;&quot;&#39;</span> &lt;&lt; row[6]-&gt;toString(0) &lt;&lt; R<span class="stringliteral">&quot;_(&quot;: [)_&quot;;</span></div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="stringliteral">            <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; </span><span class="charliteral">&#39;&quot;&#39;</span> &lt;&lt; <a class="code" href="namespacesouffle_1_1profile_1_1_tools.html#a65cd76e226eb994f292d7323815e865d">Tools::cleanJsonOut</a>(row[5]-&gt;<a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(0)) &lt;&lt; R<span class="stringliteral">&quot;_(&quot;, )_&quot;;</span></div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="stringliteral">            <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; </span><span class="charliteral">&#39;&quot;&#39;</span> &lt;&lt; <a class="code" href="namespacesouffle_1_1profile_1_1_tools.html#a65cd76e226eb994f292d7323815e865d">Tools::cleanJsonOut</a>(row[6]-&gt;<a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(0)) &lt;&lt; R<span class="stringliteral">&quot;_(&quot;, )_&quot;;</span></div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="stringliteral">            <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; row[0]-&gt;getDoubleVal() &lt;&lt; </span><span class="stringliteral">&quot;, &quot;</span>;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;            <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; row[1]-&gt;getDoubleVal() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;            <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; row[2]-&gt;getDoubleVal() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;            <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; row[4]-&gt;getLongVal() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;            <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; <span class="charliteral">&#39;&quot;&#39;</span> &lt;&lt; src &lt;&lt; R<span class="stringliteral">&quot;_(&quot;, )_&quot;;</span></div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;<span class="stringliteral">            <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; </span><span class="stringliteral">&quot;[&quot;</span>;</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;            <span class="keywordtype">bool</span> has_ver = <span class="keyword">false</span>;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;            <span class="keywordtype">bool</span> firstCol = <span class="keyword">true</span>;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; _ver_row : versionTable.getRows()) {</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;                comma(firstCol);</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;                has_ver = <span class="keyword">true</span>;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;                Row ver_row = *_ver_row;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;                <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; <span class="charliteral">&#39;[&#39;</span>;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;                <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; <span class="charliteral">&#39;&quot;&#39;</span> &lt;&lt; <a class="code" href="namespacesouffle_1_1profile_1_1_tools.html#a65cd76e226eb994f292d7323815e865d">Tools::cleanJsonOut</a>(ver_row[5]-&gt;<a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(0)) &lt;&lt; R<span class="stringliteral">&quot;_(&quot;, )_&quot;;</span></div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;<span class="stringliteral">                <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; </span><span class="charliteral">&#39;&quot;&#39;</span> &lt;&lt; <a class="code" href="namespacesouffle_1_1profile_1_1_tools.html#a65cd76e226eb994f292d7323815e865d">Tools::cleanJsonOut</a>(ver_row[6]-&gt;<a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(0)) &lt;&lt; R<span class="stringliteral">&quot;_(&quot;, )_&quot;;</span></div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<span class="stringliteral">                <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; ver_row[0]-&gt;getDoubleVal() &lt;&lt; </span><span class="stringliteral">&quot;, &quot;</span>;</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;                <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; ver_row[1]-&gt;getDoubleVal() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;                <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; ver_row[2]-&gt;getDoubleVal() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;                <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; ver_row[4]-&gt;getLongVal() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;                <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; <span class="charliteral">&#39;&quot;&#39;</span> &lt;&lt; src &lt;&lt; R<span class="stringliteral">&quot;_(&quot;, )_&quot;;</span></div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="stringliteral">                <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; ver_row[8]-&gt;getLongVal();</span></div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;<span class="stringliteral">                <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; </span><span class="charliteral">&#39;]&#39;</span>;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;            }</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;            <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; <span class="stringliteral">&quot;], &quot;</span>;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;            <span class="keywordflow">if</span> (row[6]-&gt;<a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(0).at(0) != <span class="charliteral">&#39;C&#39;</span>) {</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;                <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; <span class="stringliteral">&quot;{}, {}]&quot;</span>;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;                <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; R<span class="stringliteral">&quot;_({&quot;tot_t&quot;: [)_&quot;;</span></div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="stringliteral">                std::vector&lt;uint64_t&gt; iteration_tuples;</span></div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;<span class="stringliteral">                </span><span class="keywordtype">bool</span> firstCol = <span class="keyword">true</span>;</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> : run-&gt;getRelation(row[7]-&gt;toString(0))-&gt;getIterations()) {</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                    <span class="keywordtype">bool</span> add = <span class="keyword">false</span>;</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                    std::chrono::microseconds totalTime{};</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;                    uint64_t totalSize = 0L;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;                    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; rul : <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>-&gt;getRules()) {</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;                        <span class="keywordflow">if</span> (rul.second-&gt;getId() == row[6]-&gt;toString(0)) {</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;                            totalTime += rul.second-&gt;<a class="code" href="classsouffle_1_1profile_1_1_tui.html#a4ec0e628b05f91ca1734b7ea6ffc6f07">getRuntime</a>();</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;                            totalSize += rul.second-&gt;size();</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;                            add = <span class="keyword">true</span>;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;                        }</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;                    }</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;                    <span class="keywordflow">if</span> (add) {</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;                        comma(firstCol);</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;                        <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; totalTime.count();</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;                        iteration_tuples.push_back(totalSize);</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;                    }</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;                }</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;                <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; R<span class="stringliteral">&quot;_(], &quot;tuples&quot;: [)_&quot;;</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="stringliteral">                firstCol = </span><span class="keyword">true</span>;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> : iteration_tuples) {</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;                    comma(firstCol);</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;                    <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;                }</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;                <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; <span class="stringliteral">&quot;]}, {&quot;</span>;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;                <span class="keywordflow">if</span> (has_ver) {</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;                    <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; R<span class="stringliteral">&quot;_(&quot;tot_t&quot;: [)_&quot;;</span></div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="stringliteral">                    firstCol = </span><span class="keyword">true</span>;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;                    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; row : versionTable.rows) {</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;                        comma(firstCol);</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;                        <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; (*row)[0]-&gt;getDoubleVal();</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;                    }</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;                    <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; R<span class="stringliteral">&quot;_(], &quot;tuples&quot;: [)_&quot;;</span></div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;<span class="stringliteral">                    firstCol = </span><span class="keyword">true</span>;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;                    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; row : versionTable.rows) {</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                        comma(firstCol);</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;                        <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; (*row)[4]-&gt;getLongVal();</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;                    }</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;                    <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; <span class="charliteral">&#39;]&#39;</span>;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;                }</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;                <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; <span class="stringliteral">&quot;}]&quot;</span>;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;            }</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;        }</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;        <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a> &lt;&lt; <span class="stringliteral">&quot;\n}&quot;</span>;</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a>;</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    }</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    std::stringstream&amp; genJsonUsage(std::stringstream&amp; <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a>) {</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;        <span class="keyword">const</span> std::shared_ptr&lt;ProgramRun&gt;&amp; run = out.getProgramRun();</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;        <span class="keyword">auto</span> comma = [&amp;<a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a>](<span class="keywordtype">bool</span>&amp; first, <span class="keyword">const</span> std::string&amp; delimiter = <span class="stringliteral">&quot;, &quot;</span>) {</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;            <span class="keywordflow">if</span> (!first) {</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;                ss &lt;&lt; delimiter;</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;                first = <span class="keyword">false</span>;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;            }</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;        };</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;        std::string source_loc = (*relationTable.getRows()[0])[7]-&gt;getStringVal();</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;        std::string source_file_loc = <a class="code" href="namespacesouffle.html#a2925d5d1ec64b003a6b111ed29a2392b">Tools::split</a>(source_loc, <span class="stringliteral">&quot; &quot;</span>).at(0);</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;        std::ifstream source_file(source_file_loc);</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        <span class="keywordflow">if</span> (!source_file.is_open()) {</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;Error opening \&quot;&quot;</span> &lt;&lt; source_file_loc &lt;&lt; <span class="stringliteral">&quot;\&quot;, creating GUI without source locator.&quot;</span></div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;                      &lt;&lt; std::endl;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="ttc" id="namespacesouffle_1_1profile_html_a6b765acdf677f188e059ac9860c5046d"><div class="ttname"><a href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">souffle::profile::ss</a></div><div class="ttdeci">class souffle::profile::Tui ss</div><div class="ttdef"><b>Definition:</b> <a href="_tui_8h_source.html#l00319">Tui.h:319</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="namespacesouffle_html_aecc08c83ad9634fc515b7aa094702949"><div class="ttname"><a href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">souffle::toString</a></div><div class="ttdeci">const std::string &amp; toString(const std::string &amp;str)</div><div class="ttdoc">A generic function converting strings into strings (trivial case). </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00793">Util.h:793</a></div></div>
<div class="ttc" id="namespacesouffle_1_1profile_1_1_tools_html_a65cd76e226eb994f292d7323815e865d"><div class="ttname"><a href="namespacesouffle_1_1profile_1_1_tools.html#a65cd76e226eb994f292d7323815e865d">souffle::profile::Tools::cleanJsonOut</a></div><div class="ttdeci">std::string cleanJsonOut(std::string value)</div><div class="ttdoc">escape escapes and quotes, and remove surrounding quotes </div><div class="ttdef"><b>Definition:</b> <a href="_string_utils_8h_source.html#l00247">StringUtils.h:247</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2925d5d1ec64b003a6b111ed29a2392b"><div class="ttname"><a href="namespacesouffle.html#a2925d5d1ec64b003a6b111ed29a2392b">souffle::split</a></div><div class="ttdeci">std::vector&lt; std::string &gt; split(const std::string &amp;s, char delim, int times=-1)</div><div class="ttdoc">utility function to split a string </div><div class="ttdef"><b>Definition:</b> <a href="_explain_provenance_8h_source.html#l00130">ExplainProvenance.h:130</a></div></div>
<div class="ttc" id="classsouffle_1_1profile_1_1_tui_html_a4ec0e628b05f91ca1734b7ea6ffc6f07"><div class="ttname"><a href="classsouffle_1_1profile_1_1_tui.html#a4ec0e628b05f91ca1734b7ea6ffc6f07">souffle::profile::Tui::getRuntime</a></div><div class="ttdeci">ss&lt;&lt; R&quot;_({&quot;tot_t&quot;: [)_&quot;;firstCol=true;for(auto &amp;i :iter) { comma(firstCol);ss&lt;&lt; i-&gt; getRuntime().count()</div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ae8dc819c0300aaaafa4ef9c7cdd84d4d_cgraph.png" border="0" usemap="#namespacesouffle_ae8dc819c0300aaaafa4ef9c7cdd84d4d_cgraph" alt=""/></div>
<map name="namespacesouffle_ae8dc819c0300aaaafa4ef9c7cdd84d4d_cgraph" id="namespacesouffle_ae8dc819c0300aaaafa4ef9c7cdd84d4d_cgraph">
<area shape="rect" id="node2" href="namespacesouffle_1_1profile_1_1_tools.html#a65cd76e226eb994f292d7323815e865d" title="escape escapes and quotes, and remove surrounding quotes " alt="" coords="232,136,388,177"/>
<area shape="rect" id="node3" href="classsouffle_1_1profile_1_1_output_processor.html#a3e9eb169f1e5833392a062c84b41e5bc" title="souffle::profile::Output\lProcessor::getProgramRun" alt="" coords="213,201,407,243"/>
<area shape="rect" id="node9" href="classsouffle_1_1profile_1_1_output_processor.html#affab09ed060294b5cdf7112cc25bec96" title="souffle::profile::Output\lProcessor::getVersions" alt="" coords="472,332,641,373"/>
<area shape="rect" id="node11" href="classsouffle_1_1profile_1_1_table.html#ad5808507021b6f9cdd5641aac825f29e" title="souffle::profile::Table\l::getRows" alt="" coords="231,319,389,360"/>
<area shape="rect" id="node12" href="classsouffle_1_1_table.html#a88231c129c15ab846c85d3b493bdb8e3" title="souffle::Table::size" alt="" coords="239,385,381,411"/>
<area shape="rect" id="node13" href="namespacesouffle_1_1profile_1_1_tools.html#a2a26cf00df092cbd565298fcd045a0d2" title="split on the delimiter " alt="" coords="232,436,388,477"/>
<area shape="rect" id="node14" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949" title="A generic function converting strings into strings (trivial case). " alt="" coords="247,502,373,529"/>
<area shape="rect" id="node4" href="classsouffle_1_1profile_1_1_output_processor.html#a949dcbd9624c108584c3ac5cad32a448" title="souffle::profile::Output\lProcessor::getRelTable" alt="" coords="473,5,641,47"/>
<area shape="rect" id="node6" href="classsouffle_1_1profile_1_1_output_processor.html#aa996994e1685ee24446556d98b8c7ae7" title="souffle::profile::Output\lProcessor::getRulTable" alt="" coords="473,71,641,112"/>
<area shape="rect" id="node7" href="classsouffle_1_1profile_1_1_output_processor.html#a0b1b87d45038d57e7fb16ba943f893c7" title="souffle::profile::Output\lProcessor::getSubrulTable" alt="" coords="462,136,651,177"/>
<area shape="rect" id="node8" href="classsouffle_1_1profile_1_1_output_processor.html#a17bb5ea546bf6b9d61e02a18cbafc9ac" title="souffle::profile::Output\lProcessor::getAtomTable" alt="" coords="465,201,648,243"/>
<area shape="rect" id="node10" href="classsouffle_1_1profile_1_1_output_processor.html#abbfb4d5864dd1e5e79d2c9da6f3da11d" title="souffle::profile::Output\lProcessor::getVersionAtoms" alt="" coords="455,267,659,308"/>
<area shape="rect" id="node5" href="classsouffle_1_1profile_1_1_table.html#ac99e71fd2b566a2e68a72da291a86aa5" title="souffle::profile::Table\l::addRow" alt="" coords="707,169,864,211"/>
</map>
</div>

</div>
</div>
<a id="ab18cbb3adc2ab328de0db30a3fddf7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18cbb3adc2ab328de0db30a3fddf7e0">&#9670;&nbsp;</a></span>getAtomRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> * souffle::getAtomRelation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&#160;</td>
          <td class="paramname"><em>atom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *&#160;</td>
          <td class="paramname"><em>program</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the relation referenced by the given atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atom</td><td>the atom </td></tr>
    <tr><td class="paramname">program</td><td>the program containing the relations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>relation referenced by the atom </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00075">75</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_literal_8h_source.html#l00058">souffle::AstAtom::getQualifiedName()</a>, and <a class="el" href="_ast_utils_8cpp_source.html#l00056">getRelation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_type_analysis_8cpp_source.html#l00517">souffle::TypeAnalysis::analyseTypes()</a>, <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00083">getBodyRelations()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00079">getHeadRelation()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00129">hasClauseWithAggregatedRelation()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00116">hasClauseWithNegatedRelation()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00406">souffle::RemoveEmptyRelationsTransformer::removeEmptyRelations()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00435">souffle::RemoveEmptyRelationsTransformer::removeEmptyRelationUses()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l01448">souffle::AstExecutionPlanChecker::transform()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l01061">souffle::AstTranslator::translateRecursiveRelation()</a>.</p>
<div class="fragment"><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;                                                                                   {</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">getRelation</a>(*program, atom-&gt;getQualifiedName());</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_ada252aa15afbf7d703a11b000dfd4048"><div class="ttname"><a href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">souffle::getRelation</a></div><div class="ttdeci">AstRelation * getRelation(const AstProgram &amp;program, const AstQualifiedName &amp;name)</div><div class="ttdoc">Returns the relation with the given name in the program. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00056">AstUtils.cpp:56</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ab18cbb3adc2ab328de0db30a3fddf7e0_cgraph.png" border="0" usemap="#namespacesouffle_ab18cbb3adc2ab328de0db30a3fddf7e0_cgraph" alt=""/></div>
<map name="namespacesouffle_ab18cbb3adc2ab328de0db30a3fddf7e0_cgraph" id="namespacesouffle_ab18cbb3adc2ab328de0db30a3fddf7e0_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="236,5,492,32"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="290,56,438,83"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="563,27,667,53"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="540,78,691,119"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="739,85,885,112"/>
</map>
</div>

</div>
</div>
<a id="a805c988064a360bd5c8bdbc84ae541ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805c988064a360bd5c8bdbc84ae541ae">&#9670;&nbsp;</a></span>getBinaryConstraintTypes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a>&gt; souffle::getBinaryConstraintTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a>&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get type binary constraint operates on. </p>

<p class="definition">Definition at line <a class="el" href="_binary_constraint_ops_8h_source.html#l00313">313</a> of file <a class="el" href="_binary_constraint_ops_8h_source.html">BinaryConstraintOps.h</a>.</p>

<p class="reference">References <a class="el" href="_binary_constraint_ops_8h.html#a80c20e894fcf2ddc675ef9a025e066d4">COMPARE_EQUALS</a>, <a class="el" href="_binary_constraint_ops_8h.html#a2e263559638dfe8ea9f4da70e0c50baa">COMPARE_OP</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b">CONTAINS</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">GE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">GT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">LE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">LT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a">MATCH</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">NE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0">NOT_CONTAINS</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01">NOT_MATCH</a>, and <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a02c86eb2792f3262c21d030a87e19793">Symbol</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>.</p>
<div class="fragment"><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                                                                                      {</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    <span class="comment">// clang-format off</span></div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="preprocessor">#define COMPARE_EQUALS(op)                                                             \</span></div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="preprocessor">    case BinaryConstraintOp::F##op: return { TypeAttribute::Float };                   \</span></div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="preprocessor">    case BinaryConstraintOp::   op:                                                    \</span></div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="preprocessor">        return { TypeAttribute::Signed, TypeAttribute::Unsigned, TypeAttribute::Float, \</span></div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<span class="preprocessor">                 TypeAttribute::Symbol, TypeAttribute::Record };</span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="preprocessor">#define COMPARE_OP(op)                                                  \</span></div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;<span class="preprocessor">    case BinaryConstraintOp::   op: return { TypeAttribute::Signed   }; \</span></div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;<span class="preprocessor">    case BinaryConstraintOp::U##op: return { TypeAttribute::Unsigned }; \</span></div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="preprocessor">    case BinaryConstraintOp::F##op: return { TypeAttribute::Float    }; \</span></div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="preprocessor">    case BinaryConstraintOp::S##op: return { TypeAttribute::Symbol   };</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    <span class="comment">// clang-format on</span></div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    <span class="keywordflow">switch</span> (op) {</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        <a class="code" href="_binary_constraint_ops_8h.html#a80c20e894fcf2ddc675ef9a025e066d4">COMPARE_EQUALS</a>(EQ)</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;        <a class="code" href="_binary_constraint_ops_8h.html#a80c20e894fcf2ddc675ef9a025e066d4">COMPARE_EQUALS</a>(NE)</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;        <a class="code" href="_binary_constraint_ops_8h.html#a2e263559638dfe8ea9f4da70e0c50baa">COMPARE_OP</a>(LT)</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;        <a class="code" href="_binary_constraint_ops_8h.html#a2e263559638dfe8ea9f4da70e0c50baa">COMPARE_OP</a>(LE)</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;        <a class="code" href="_binary_constraint_ops_8h.html#a2e263559638dfe8ea9f4da70e0c50baa">COMPARE_OP</a>(GT)</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        <a class="code" href="_binary_constraint_ops_8h.html#a2e263559638dfe8ea9f4da70e0c50baa">COMPARE_OP</a>(GE)</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::MATCH:</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NOT_MATCH:</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::CONTAINS:</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NOT_CONTAINS:</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;            <span class="keywordflow">return</span> {TypeAttribute::Symbol};</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    }</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Uncovered case!&quot;</span>);</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    exit(EXIT_FAILURE);</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="preprocessor">#undef COMPARE_EQUALS</span></div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="preprocessor">#undef COMPARE_OP</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;}</div><div class="ttc" id="_binary_constraint_ops_8h_html_a80c20e894fcf2ddc675ef9a025e066d4"><div class="ttname"><a href="_binary_constraint_ops_8h.html#a80c20e894fcf2ddc675ef9a025e066d4">COMPARE_EQUALS</a></div><div class="ttdeci">#define COMPARE_EQUALS(op)</div></div>
<div class="ttc" id="_binary_constraint_ops_8h_html_a2e263559638dfe8ea9f4da70e0c50baa"><div class="ttname"><a href="_binary_constraint_ops_8h.html#a2e263559638dfe8ea9f4da70e0c50baa">COMPARE_OP</a></div><div class="ttdeci">#define COMPARE_OP(op)</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a96c0ee8e7896baeb355bd776229e1142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c0ee8e7896baeb355bd776229e1142">&#9670;&nbsp;</a></span>getBodyLiterals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T*&gt; souffle::getBodyLiterals </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>clause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns literals of a particular type in the body of a clause. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>clause </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of body literals of the specified type </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8h_source.html#l00068">68</a> of file <a class="el" href="_ast_utils_8h_source.html">AstUtils.h</a>.</p>

<p class="reference">References <a class="el" href="_ast_utils_8cpp_source.html#l00179">cloneHead()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00075">getAtomRelation()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00083">getBodyRelations()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00096">getClauseNum()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00042">getClauses()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00064">getFunctorDeclaration()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00079">getHeadRelation()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00056">getRelation()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00060">getType()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00129">hasClauseWithAggregatedRelation()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00116">hasClauseWithNegatedRelation()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00159">isFact()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00148">isRecursiveClause()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00175">isRule()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00222">negateConstraint()</a>, <a class="el" href="_reader_8h_source.html#l00130">relation</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00069">removeRelationClauses()</a>, and <a class="el" href="_ast_utils_8cpp_source.html#l00189">reorderAtoms()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_clause_8h_source.html#l00219">souffle::AstClause::print()</a>.</p>
<div class="fragment"><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;                                               {</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    std::vector&lt;T*&gt; res;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; lit : clause.getBodyLiterals()) {</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        <span class="keywordflow">if</span> (T* t = dynamic_cast&lt;T*&gt;(lit)) {</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;            res.push_back(t);</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        }</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    }</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <span class="keywordflow">return</span> res;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a96c0ee8e7896baeb355bd776229e1142_cgraph.png" border="0" usemap="#namespacesouffle_a96c0ee8e7896baeb355bd776229e1142_cgraph" alt=""/></div>
<map name="namespacesouffle_a96c0ee8e7896baeb355bd776229e1142_cgraph" id="namespacesouffle_a96c0ee8e7896baeb355bd776229e1142_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a6aa6d61f4a71ddbb2458d23ce24dbced" title="Returns a clause which contains head of the given clause. " alt="" coords="559,122,701,149"/>
<area shape="rect" id="node10" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0" title="Returns the relation referenced by the given atom. " alt="" coords="539,862,721,889"/>
<area shape="rect" id="node12" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="838,942,986,969"/>
<area shape="rect" id="node16" href="namespacesouffle.html#a598a4ed07c31abae549ab7461fb9b7ee" title="Returns the relations referenced in the body of the given clause. " alt="" coords="259,738,447,765"/>
<area shape="rect" id="node22" href="namespacesouffle.html#ac4f78efaeb4338f70e2dcab6bd0638d2" title="Returns the index of a clause within its relation, ignoring facts. " alt="" coords="267,789,438,815"/>
<area shape="rect" id="node23" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="557,1014,703,1041"/>
<area shape="rect" id="node25" href="namespacesouffle.html#ae4b6e248ec714e64f38ce032caf5f477" title="Returns whether the given clause is a fact. " alt="" coords="575,558,685,585"/>
<area shape="rect" id="node26" href="namespacesouffle.html#a68ec038f787c926d16d63206d73d4724" title="Returns the functor declaration with the given name in the program. " alt="" coords="803,993,1021,1019"/>
<area shape="rect" id="node28" href="namespacesouffle.html#ae5266d9360a88847a65d1c581f778d89" title="Returns the relation referenced by the head of the given clause. " alt="" coords="261,637,444,663"/>
<area shape="rect" id="node29" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="849,1047,975,1074"/>
<area shape="rect" id="node31" href="namespacesouffle.html#aae039656df27f6089ef34a0a4455dce5" title="Returns whether the given relation has any clauses which contain an aggregation over of a specific re..." alt="" coords="229,891,476,932"/>
<area shape="rect" id="node32" href="namespacesouffle.html#ab93b9d78c10c77c6d4ab227d5f9b389a" title="Returns whether the given relation has any clauses which contain a negation of a specific relation..." alt="" coords="239,956,466,997"/>
<area shape="rect" id="node33" href="namespacesouffle.html#aa32d170d4eebb7da45f9322e8b548aa8" title="Returns whether the given clause is recursive. " alt="" coords="534,609,726,635"/>
<area shape="rect" id="node34" href="namespacesouffle.html#ad9a7da374b6da781f82cdc09d5fe0d38" title="Returns whether the given clause is a rule. " alt="" coords="296,535,409,562"/>
<area shape="rect" id="node35" href="namespacesouffle.html#a4a2b4fc7558b8bce98ff88f8e10b516e" title="Negate an ast constraint. " alt="" coords="259,1283,446,1310"/>
<area shape="rect" id="node37" href="namespacesouffle.html#a503032b9def6267059072aea913780bc" title="Removes the set of clauses with the given relation name. " alt="" coords="239,1073,467,1099"/>
<area shape="rect" id="node39" href="namespacesouffle.html#ae77f3374134c13b638bf7644fcebb5ef" title="Reorders the atoms of a clause to be in the given order. " alt="" coords="271,246,434,273"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Create a clone (i.e. " alt="" coords="825,71,999,98"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="1103,122,1303,149"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_execution_plan.html#ac657ffa016ae777656585a56fc9a899c" title="Create a clone (i.e. " alt="" coords="819,173,1005,215"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="857,239,967,266"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_clause.html#aa943423c45971e70c837da5b88c8fc04" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="841,5,983,47"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="843,449,981,491"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_atom.html#acef18129b13ce45477044717ded051d2" title="souffle::AstAtom::AstAtom" alt="" coords="1106,71,1301,98"/>
<area shape="rect" id="node11" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="784,811,1040,838"/>
<area shape="rect" id="node13" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1151,989,1255,1015"/>
<area shape="rect" id="node14" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="1128,857,1279,899"/>
<area shape="rect" id="node15" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1389,897,1535,923"/>
<area shape="rect" id="node17" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="843,601,981,643"/>
<area shape="rect" id="node18" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="828,697,996,723"/>
<area shape="rect" id="node21" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="1088,773,1319,799"/>
<area shape="rect" id="node19" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="1119,689,1287,731"/>
<area shape="rect" id="node20" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="1367,689,1557,731"/>
<area shape="rect" id="node24" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="1128,1105,1279,1147"/>
<area shape="rect" id="node27" href="classsouffle_1_1_ast_program.html#a69ceb64c50b5e47518d505416e4579fa" title="get functor declarations " alt="" coords="1113,923,1293,964"/>
<area shape="rect" id="node30" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="1128,1040,1279,1081"/>
<area shape="rect" id="node36" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="524,1283,736,1310"/>
<area shape="rect" id="node38" href="classsouffle_1_1_ast_program.html#a0bde67af569811987d8e21929163d132" title="remove a clause " alt="" coords="555,1065,705,1107"/>
<area shape="rect" id="node40" href="classsouffle_1_1_ast_clause.html#ac5e3416082d23734d1277daa5c9dee81" title="Add a Literal to the body of the clause. " alt="" coords="561,173,699,215"/>
<area shape="rect" id="node41" href="classsouffle_1_1_ast_literal.html#a8e7b7424c40acb87df022913c5928fd8" title="Create a clone (i.e. " alt="" coords="562,239,698,280"/>
</map>
</div>

</div>
</div>
<a id="a598a4ed07c31abae549ab7461fb9b7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598a4ed07c31abae549ab7461fb9b7ee">&#9670;&nbsp;</a></span>getBodyRelations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> * &gt; souffle::getBodyRelations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *&#160;</td>
          <td class="paramname"><em>program</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the relations referenced in the body of the given clause. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clause</td><td>the clause </td></tr>
    <tr><td class="paramname">program</td><td>the program containing the relations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>relation referenced in the clause body </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00083">83</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_literal_8h_source.html#l00078">souffle::AstAtom::getArguments()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00075">getAtomRelation()</a>, <a class="el" href="_ast_clause_8h_source.html#l00171">souffle::AstClause::getBodyLiterals()</a>, <a class="el" href="_ast_clause_8h_source.html#l00166">souffle::AstClause::getHead()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>, and <a class="el" href="_precedence_graph_8cpp_source.html#l00106">souffle::PrecedenceGraph::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                                                                                                {</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    std::set&lt;const AstRelation*&gt; bodyRelations;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; lit : clause-&gt;getBodyLiterals()) {</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                *lit, [&amp;](<span class="keyword">const</span> AstAtom&amp; atom) { bodyRelations.insert(<a class="code" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">getAtomRelation</a>(&amp;atom, program)); });</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    }</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; arg : clause-&gt;getHead()-&gt;getArguments()) {</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;                *arg, [&amp;](<span class="keyword">const</span> AstAtom&amp; atom) { bodyRelations.insert(<a class="code" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">getAtomRelation</a>(&amp;atom, program)); });</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    }</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keywordflow">return</span> bodyRelations;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab18cbb3adc2ab328de0db30a3fddf7e0"><div class="ttname"><a href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">souffle::getAtomRelation</a></div><div class="ttdeci">const AstRelation * getAtomRelation(const AstAtom *atom, const AstProgram *program)</div><div class="ttdoc">Returns the relation referenced by the given atom. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00075">AstUtils.cpp:75</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a598a4ed07c31abae549ab7461fb9b7ee_cgraph.png" border="0" usemap="#namespacesouffle_a598a4ed07c31abae549ab7461fb9b7ee_cgraph" alt=""/></div>
<map name="namespacesouffle_a598a4ed07c31abae549ab7461fb9b7ee_cgraph" id="namespacesouffle_a598a4ed07c31abae549ab7461fb9b7ee_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="485,5,715,32"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0" title="Returns the relation referenced by the given atom. " alt="" coords="241,111,424,137"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="802,170,941,211"/>
<area shape="rect" id="node10" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="263,213,402,254"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="249,279,417,305"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1015,112,1161,139"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="472,60,728,87"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="526,111,674,137"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="819,53,923,80"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="796,105,947,146"/>
<area shape="rect" id="node12" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="516,271,684,313"/>
<area shape="rect" id="node13" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="776,271,967,313"/>
</map>
</div>

</div>
</div>
<a id="ac4f78efaeb4338f70e2dcab6bd0638d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f78efaeb4338f70e2dcab6bd0638d2">&#9670;&nbsp;</a></span>getClauseNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t souffle::getClauseNum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td>
          <td class="paramname"><em>clause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of a clause within its relation, ignoring facts. </p>
<p>Used in provenance as a unique ID for clauses within their relations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>the program </td></tr>
    <tr><td class="paramname">clause</td><td>the clause to get the index of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the clause ignoring facts; 0 for facts </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00096">96</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_utils_8cpp_source.html#l00042">getClauses()</a>, <a class="el" href="_ast_clause_8h_source.html#l00166">souffle::AstClause::getHead()</a>, <a class="el" href="_ast_literal_8h_source.html#l00058">souffle::AstAtom::getQualifiedName()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00056">getRelation()</a>, and <a class="el" href="_ast_utils_8cpp_source.html#l00159">isFact()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>, <a class="el" href="_provenance_transformer_8cpp_source.html#l00387">souffle::ProvenanceTransformer::transformMaxHeight()</a>, <a class="el" href="_provenance_transformer_8cpp_source.html#l00249">souffle::ProvenanceTransformer::transformSubtreeHeights()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l01518">souffle::AstTranslator::translateProgram()</a>.</p>
<div class="fragment"><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                                                                        {</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="comment">// TODO (azreika): This number might change between the provenance transformer and the AST-&gt;RAM</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <span class="comment">// translation. Might need a better way to assign IDs to clauses... (see PR #1288).</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keyword">const</span> AstRelation* rel = <a class="code" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">getRelation</a>(*program, clause-&gt;getHead()-&gt;getQualifiedName());</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    assert(rel != <span class="keyword">nullptr</span> &amp;&amp; <span class="stringliteral">&quot;clause relation does not exist&quot;</span>);</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keywordtype">size_t</span> clauseNum = 1;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* cur : <a class="code" href="namespacesouffle.html#a4ca5420316b1f3e64bc8f87a26a0c05c">getClauses</a>(*program, *rel)) {</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        <span class="keywordtype">bool</span> <a class="code" href="namespacesouffle.html#ae4b6e248ec714e64f38ce032caf5f477">isFact</a> = cur-&gt;getBodyLiterals().empty();</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        <span class="keywordflow">if</span> (cur == clause) {</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;            <span class="keywordflow">return</span> isFact ? 0 : clauseNum;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        }</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        <span class="keywordflow">if</span> (!isFact) {</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            clauseNum++;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        }</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    }</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;clause does not exist&quot;</span>);</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_ae4b6e248ec714e64f38ce032caf5f477"><div class="ttname"><a href="namespacesouffle.html#ae4b6e248ec714e64f38ce032caf5f477">souffle::isFact</a></div><div class="ttdeci">bool isFact(const AstClause &amp;clause)</div><div class="ttdoc">Returns whether the given clause is a fact. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00159">AstUtils.cpp:159</a></div></div>
<div class="ttc" id="namespacesouffle_html_ada252aa15afbf7d703a11b000dfd4048"><div class="ttname"><a href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">souffle::getRelation</a></div><div class="ttdeci">AstRelation * getRelation(const AstProgram &amp;program, const AstQualifiedName &amp;name)</div><div class="ttdoc">Returns the relation with the given name in the program. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00056">AstUtils.cpp:56</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4ca5420316b1f3e64bc8f87a26a0c05c"><div class="ttname"><a href="namespacesouffle.html#a4ca5420316b1f3e64bc8f87a26a0c05c">souffle::getClauses</a></div><div class="ttdeci">std::vector&lt; AstClause * &gt; getClauses(const AstProgram &amp;program, const AstRelation &amp;rel)</div><div class="ttdoc">Returns a vector of clauses in the program describing the given relation. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00052">AstUtils.cpp:52</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ac4f78efaeb4338f70e2dcab6bd0638d2_cgraph.png" border="0" usemap="#namespacesouffle_ac4f78efaeb4338f70e2dcab6bd0638d2_cgraph" alt=""/></div>
<map name="namespacesouffle_ac4f78efaeb4338f70e2dcab6bd0638d2_cgraph" id="namespacesouffle_ac4f78efaeb4338f70e2dcab6bd0638d2_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="279,50,425,77"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="543,305,681,347"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="224,326,480,353"/>
<area shape="rect" id="node7" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="278,137,426,163"/>
<area shape="rect" id="node10" href="namespacesouffle.html#ae4b6e248ec714e64f38ce032caf5f477" title="Returns whether the given clause is a fact. " alt="" coords="297,225,407,251"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="537,5,687,47"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="755,78,901,105"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="560,137,664,163"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="537,71,687,112"/>
<area shape="rect" id="node11" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="543,188,681,229"/>
<area shape="rect" id="node12" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="528,254,696,281"/>
<area shape="rect" id="node13" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="744,247,912,288"/>
<area shape="rect" id="node14" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="960,247,1151,288"/>
</map>
</div>

</div>
</div>
<a id="a4d9e53888640a9abfd7ea7c43715152a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9e53888640a9abfd7ea7c43715152a">&#9670;&nbsp;</a></span>getClauses() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> * &gt; souffle::getClauses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>relationName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of clauses in the program describing the relation with the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>the program </td></tr>
    <tr><td class="paramname">name</td><td>the name of the relation to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of clauses describing the relation with the given name </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00042">42</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_component_instantiation_transformer_8cpp_source.html#l00049">clauses</a>, and <a class="el" href="_ast_program_8h_source.html#l00062">souffle::AstProgram::getClauses()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00297">addBackwardDependencies()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00337">addForwardDependencies()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00594">bindComposites()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l01219">souffle::AstSemanticChecker::checkInlining()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00726">souffle::AstSemanticChecker::checkRelation()</a>, <a class="el" href="_aux_arity_analysis_8cpp_source.html#l00028">souffle::AuxiliaryArity::computeArity()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00422">formNegatedLiterals()</a>, <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00096">getClauseNum()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00052">getClauses()</a>, <a class="el" href="_precedence_graph_8h_source.html#l00132">souffle::RelationDetailCache::getClauses()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00787">getInlinedLiteral()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00129">hasClauseWithAggregatedRelation()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00116">hasClauseWithNegatedRelation()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00068">normaliseInlinedHeads()</a>, <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00324">reduceLocallyEquivalentClauses()</a>, <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00372">reduceSingletonRelations()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00406">souffle::RemoveEmptyRelationsTransformer::removeEmptyRelations()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00069">removeRelationClauses()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00079">souffle::RemoveRelationCopiesTransformer::removeRelationCopies()</a>, <a class="el" href="_magic_set_8cpp_source.html#l01017">replaceUnderscores()</a>, <a class="el" href="_ast_type_analysis_8cpp_source.html#l00479">souffle::TypeAnalysis::run()</a>, <a class="el" href="_precedence_graph_8cpp_source.html#l00106">souffle::PrecedenceGraph::run()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00695">souffle::Adornment::run()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00899">separateDBs()</a>, <a class="el" href="_resolve_aliases_transformer_8cpp_source.html#l00437">souffle::ResolveAliasesTransformer::transform()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l01448">souffle::AstExecutionPlanChecker::transform()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00516">souffle::RemoveBooleanConstraintsTransformer::transform()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l01006">souffle::InlineRelationsTransformer::transform()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00822">souffle::ReduceExistentialsTransformer::transform()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00973">souffle::ReplaceSingletonVariablesTransformer::transform()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l01043">souffle::NameUnnamedVariablesTransformer::transform()</a>, <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00355">souffle::ReorderLiteralsTransformer::transform()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l01118">souffle::NormaliseConstraintsTransformer::transform()</a>, <a class="el" href="_provenance_transformer_8cpp_source.html#l00387">souffle::ProvenanceTransformer::transformMaxHeight()</a>, <a class="el" href="_provenance_transformer_8cpp_source.html#l00249">souffle::ProvenanceTransformer::transformSubtreeHeights()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00960">souffle::AstTranslator::translateNonRecursiveRelation()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l01061">souffle::AstTranslator::translateRecursiveRelation()</a>.</p>
<div class="fragment"><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                                                                                                  {</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    std::vector&lt;AstClause*&gt; <a class="code" href="_component_instantiation_transformer_8cpp.html#ad635e064aa16d49969a2d994cb5a2d24">clauses</a>;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="keywordflow">for</span> (AstClause* clause : program.getClauses()) {</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        <span class="keywordflow">if</span> (clause-&gt;getHead()-&gt;getQualifiedName() == relationName) {</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;            clauses.push_back(clause);</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        }</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    }</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="_component_instantiation_transformer_8cpp.html#ad635e064aa16d49969a2d994cb5a2d24">clauses</a>;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;}</div><div class="ttc" id="_component_instantiation_transformer_8cpp_html_ad635e064aa16d49969a2d994cb5a2d24"><div class="ttname"><a href="_component_instantiation_transformer_8cpp.html#ad635e064aa16d49969a2d994cb5a2d24">clauses</a></div><div class="ttdeci">std::vector&lt; std::unique_ptr&lt; AstClause &gt; &gt; clauses</div><div class="ttdef"><b>Definition:</b> <a href="_component_instantiation_transformer_8cpp_source.html#l00049">ComponentInstantiationTransformer.cpp:49</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a4d9e53888640a9abfd7ea7c43715152a_cgraph.png" border="0" usemap="#namespacesouffle_a4d9e53888640a9abfd7ea7c43715152a_cgraph" alt=""/></div>
<map name="namespacesouffle_a4d9e53888640a9abfd7ea7c43715152a_cgraph" id="namespacesouffle_a4d9e53888640a9abfd7ea7c43715152a_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="200,5,351,47"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="399,13,545,39"/>
</map>
</div>

</div>
</div>
<a id="a4ca5420316b1f3e64bc8f87a26a0c05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca5420316b1f3e64bc8f87a26a0c05c">&#9670;&nbsp;</a></span>getClauses() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> * &gt; souffle::getClauses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> &amp;&#160;</td>
          <td class="paramname"><em>rel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of clauses in the program describing the given relation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>the program </td></tr>
    <tr><td class="paramname">rel</td><td>the relation to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of clauses describing the given relation </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00052">52</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_utils_8cpp_source.html#l00042">getClauses()</a>, and <a class="el" href="_ast_relation_8h_source.html#l00052">souffle::AstRelation::getQualifiedName()</a>.</p>
<div class="fragment"><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                                                                                    {</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a4ca5420316b1f3e64bc8f87a26a0c05c">getClauses</a>(program, rel.getQualifiedName());</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a4ca5420316b1f3e64bc8f87a26a0c05c"><div class="ttname"><a href="namespacesouffle.html#a4ca5420316b1f3e64bc8f87a26a0c05c">souffle::getClauses</a></div><div class="ttdeci">std::vector&lt; AstClause * &gt; getClauses(const AstProgram &amp;program, const AstRelation &amp;rel)</div><div class="ttdoc">Returns a vector of clauses in the program describing the given relation. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00052">AstUtils.cpp:52</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a4ca5420316b1f3e64bc8f87a26a0c05c_cgraph.png" border="0" usemap="#namespacesouffle_a4ca5420316b1f3e64bc8f87a26a0c05c_cgraph" alt=""/></div>
<map name="namespacesouffle_a4ca5420316b1f3e64bc8f87a26a0c05c_cgraph" id="namespacesouffle_a4ca5420316b1f3e64bc8f87a26a0c05c_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="201,13,347,39"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_relation.html#a5db8b505969c2f75286a54875c4aaed1" title="get qualified relation name " alt="" coords="200,64,348,105"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="396,5,547,47"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="595,13,741,39"/>
</map>
</div>

</div>
</div>
<a id="aaefdc21106bf028c4de1db83d933d0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaefdc21106bf028c4de1db83d933d0b4">&#9670;&nbsp;</a></span>getCurrentFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::getCurrentFilename </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filenames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_src_location_8cpp_source.html#l00027">27</a> of file <a class="el" href="_src_location_8cpp_source.html">SrcLocation.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l01182">baseName()</a>, <a class="el" href="_util_8h_source.html#l01115">dirName()</a>, and <a class="el" href="_util_8h_source.html#l01058">existFile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_src_location_8cpp_source.html#l00087">souffle::SrcLocation::extloc()</a>, <a class="el" href="_src_location_8cpp_source.html#l00048">souffle::SrcLocation::operator&lt;()</a>, and <a class="el" href="_src_location_8cpp_source.html#l00131">souffle::SrcLocation::print()</a>.</p>
<div class="fragment"><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;                                                                    {</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <span class="keywordflow">if</span> (filenames.empty()) {</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    }</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    std::string path = <span class="stringliteral">&quot;.&quot;</span>;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="keywordflow">for</span> (std::string filename : filenames) {</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        <span class="keywordflow">if</span> (!filename.empty() &amp;&amp; filename[0] == <span class="charliteral">&#39;/&#39;</span>) {</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;            path = <a class="code" href="namespacesouffle.html#a72e10d44624c80609e5c09b131ecf3fb">dirName</a>(filename);</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">existFile</a>(path + <span class="stringliteral">&quot;/&quot;</span> + filename)) {</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;            path = <a class="code" href="namespacesouffle.html#a72e10d44624c80609e5c09b131ecf3fb">dirName</a>(path + <span class="stringliteral">&quot;/&quot;</span> + filename);</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">existFile</a>(filename)) {</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;            path = <a class="code" href="namespacesouffle.html#a72e10d44624c80609e5c09b131ecf3fb">dirName</a>(filename);</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;            path = <span class="stringliteral">&quot;.&quot;</span>;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        }</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    }</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordflow">return</span> path + <span class="stringliteral">&quot;/&quot;</span> + <a class="code" href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4">baseName</a>(filenames.back());</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a72e10d44624c80609e5c09b131ecf3fb"><div class="ttname"><a href="namespacesouffle.html#a72e10d44624c80609e5c09b131ecf3fb">souffle::dirName</a></div><div class="ttdeci">std::string dirName(const std::string &amp;name)</div><div class="ttdoc">C++-style dirname. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01115">Util.h:1115</a></div></div>
<div class="ttc" id="namespacesouffle_html_a69107e934a60222580ee8ba6882dc3d3"><div class="ttname"><a href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">souffle::existFile</a></div><div class="ttdeci">bool existFile(const std::string &amp;name)</div><div class="ttdoc">Check whether a file exists in the file system. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01058">Util.h:1058</a></div></div>
<div class="ttc" id="namespacesouffle_html_a9fbc2262a6164b62766f6fcb67f12ae4"><div class="ttname"><a href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4">souffle::baseName</a></div><div class="ttdeci">std::string baseName(const std::string &amp;filename)</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01182">Util.h:1182</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aaefdc21106bf028c4de1db83d933d0b4_cgraph.png" border="0" usemap="#namespacesouffle_aaefdc21106bf028c4de1db83d933d0b4_cgraph" alt=""/></div>
<map name="namespacesouffle_aaefdc21106bf028c4de1db83d933d0b4_cgraph" id="namespacesouffle_aaefdc21106bf028c4de1db83d933d0b4_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4" title="souffle::baseName" alt="" coords="256,5,400,32"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a72e10d44624c80609e5c09b131ecf3fb" title="C++&#45;style dirname. " alt="" coords="263,56,393,83"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3" title="Check whether a file exists in the file system. " alt="" coords="264,107,392,133"/>
</map>
</div>

</div>
</div>
<a id="a620dc7687473311acaa752a76b5c9470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620dc7687473311acaa752a76b5c9470">&#9670;&nbsp;</a></span>getEndpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int souffle::getEndpoint </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>mainName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00069">69</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00962">extractAdornment()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                                    {</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keywordtype">int</span> endpt = mainName.size() - 1;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <span class="keywordflow">while</span> (endpt &gt;= 0 &amp;&amp; mainName[endpt] != <span class="charliteral">&#39;_&#39;</span>) {</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        endpt--;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    }</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <span class="keywordflow">if</span> (endpt == -1) {</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        endpt = mainName.size();</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    }</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="keywordflow">return</span> endpt;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a68ec038f787c926d16d63206d73d4724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ec038f787c926d16d63206d73d4724">&#9670;&nbsp;</a></span>getFunctorDeclaration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsouffle_1_1_ast_functor_declaration.html">AstFunctorDeclaration</a> * souffle::getFunctorDeclaration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the functor declaration with the given name in the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>the program </td></tr>
    <tr><td class="paramname">name</td><td>the name of the functor declaration to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the functor declaration if it exists; nullptr otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00064">64</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_program_8h_source.html#l00067">souffle::AstProgram::getFunctorDeclarations()</a>, and <a class="el" href="_util_8h_source.html#l00318">getIf()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_parser_driver_8cpp_source.html#l00098">souffle::ParserDriver::addFunctorDeclaration()</a>, <a class="el" href="_ast_program_8h_source.html#l00300">souffle::AstProgram::addFunctorDeclaration()</a>, <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l01375">souffle::AstUserDefinedFunctorsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;                                                                                                     {</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa">getIf</a>(program.getFunctorDeclarations(),</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;            [&amp;](<span class="keyword">const</span> AstFunctorDeclaration* f) { <span class="keywordflow">return</span> f-&gt;getName() == name; });</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a62f80c157a6a365d78a43592732a8efa"><div class="ttname"><a href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa">souffle::getIf</a></div><div class="ttdeci">C::value_type getIf(const C &amp;container, std::function&lt; bool(const typename C::value_type)&gt; pred)</div><div class="ttdoc">Returns the first element in a container that satisfies a given predicate, nullptr otherwise...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00318">Util.h:318</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a68ec038f787c926d16d63206d73d4724_cgraph.png" border="0" usemap="#namespacesouffle_a68ec038f787c926d16d63206d73d4724_cgraph" alt=""/></div>
<map name="namespacesouffle_a68ec038f787c926d16d63206d73d4724_cgraph" id="namespacesouffle_a68ec038f787c926d16d63206d73d4724_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_program.html#a69ceb64c50b5e47518d505416e4579fa" title="get functor declarations " alt="" coords="271,5,451,47"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="309,71,413,98"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="499,13,645,39"/>
</map>
</div>

</div>
</div>
<a id="abb20659f25b4513908b813cfdbf43e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb20659f25b4513908b813cfdbf43e23">&#9670;&nbsp;</a></span>getGreatestCommonSubtypes() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> souffle::getGreatestCommonSubtypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the greatest common sub types of the two given types. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00540">540</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="html_js_chartist_min_8h_source.html#l00015">b</a>, <a class="el" href="_type_system_8h_source.html#l00128">souffle::UnionType::getElementTypes()</a>, <a class="el" href="_type_system_8h_source.html#l00051">souffle::Type::getTypeEnvironment()</a>, <a class="el" href="_type_system_8h_source.html#l00229">souffle::TypeSet::insert()</a>, <a class="el" href="_type_system_8cpp_source.html#l00401">isSubtypeOf()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00081">souffle::TypeEnvironment::isType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_type_system_8cpp_source.html#l00588">getGreatestCommonSubtypes()</a>, and <a class="el" href="_type_system_8h_source.html#l00618">getLeastCommonSupertypes()</a>.</p>
<div class="fragment"><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;                                                                {</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;    <span class="comment">// make sure they are in the same type environment</span></div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;    assert(a.getTypeEnvironment().isType(a) &amp;&amp; a.getTypeEnvironment().isType(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>));</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;    <span class="comment">// if they are equal it is easy</span></div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;    <span class="keywordflow">if</span> (a == <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>) {</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;        <span class="keywordflow">return</span> TypeSet(a);</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    }</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;    <span class="comment">// equally simple - check whether one is a sub-type of the other</span></div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(a, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)) {</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;        <span class="keywordflow">return</span> TypeSet(a);</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;    }</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, a)) {</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;        <span class="keywordflow">return</span> TypeSet(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>);</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;    }</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;    <span class="comment">// last option: if both are unions with common sub-types</span></div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;    TypeSet res;</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;    <span class="keywordflow">if</span> (isUnion(a) &amp;&amp; isUnion(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)) {</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;        <span class="comment">// collect common sub-types of union types</span></div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;        <span class="keyword">struct </span>collector : <span class="keyword">public</span> TypeVisitor&lt;void&gt; {</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;            <span class="keyword">const</span> Type&amp; <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>;</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;            TypeSet&amp; res;</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;            collector(<span class="keyword">const</span> Type&amp; b, TypeSet&amp; res) : b(b), res(res) {}</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;            <span class="keywordtype">void</span> visit(<span class="keyword">const</span> Type&amp; type)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(type, b)) {</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;                    res.insert(type);</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;                } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;                    TypeVisitor&lt;void&gt;::visit(type);</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;                }</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;            }</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;            <span class="keywordtype">void</span> visitUnionType(<span class="keyword">const</span> UnionType&amp; type)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cur : type.getElementTypes()) {</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;                    visit(*cur);</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;                }</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;            }</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;        };</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;        <span class="comment">// collect all common sub-types</span></div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;        collector(b, res).visit(a);</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;    }</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;    <span class="comment">// otherwise there is no common super type</span></div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;    <span class="keywordflow">return</span> res;</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8cc19c66d9d13ce64e65f14dcabb43b3"><div class="ttname"><a href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">souffle::isSubtypeOf</a></div><div class="ttdeci">bool isSubtypeOf(const Type &amp;a, const Type &amp;b)</div><div class="ttdoc">Determines whether type a is a subtype of type b. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00401">TypeSystem.cpp:401</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_abb20659f25b4513908b813cfdbf43e23_cgraph.png" border="0" usemap="#namespacesouffle_abb20659f25b4513908b813cfdbf43e23_cgraph" alt=""/></div>
<map name="namespacesouffle_abb20659f25b4513908b813cfdbf43e23_cgraph" id="namespacesouffle_abb20659f25b4513908b813cfdbf43e23_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_union_type.html#a0175bce933a70c1d3691114860ac17fc" title="souffle::UnionType\l::getElementTypes" alt="" coords="278,78,421,119"/>
<area shape="rect" id="node4" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="717,300,964,327"/>
<area shape="rect" id="node5" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="264,493,435,520"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="273,249,426,276"/>
<area shape="rect" id="node7" href="classsouffle_1_1_type_environment.html#a5ead83575e9abfebb3a0b180a33a7d96" title="souffle::TypeEnvironment\l::isType" alt="" coords="483,377,669,418"/>
<area shape="rect" id="node3" href="classsouffle_1_1_type.html#a00437c665d598367ff16229c823c728f" title="souffle::Type::print" alt="" coords="505,5,647,32"/>
<area shape="rect" id="node8" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="747,207,934,249"/>
<area shape="rect" id="node13" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="493,275,659,301"/>
<area shape="rect" id="node14" href="classsouffle_1_1_type_environment.html#a72fa419d33bf813f22efabec629a4627" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="747,142,934,183"/>
<area shape="rect" id="node15" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="494,224,658,251"/>
<area shape="rect" id="node16" href="classsouffle_1_1_subset_type.html#ac5c52e503cbce42370d6ada3f050773d" title="souffle::SubsetType\l::getBaseType" alt="" coords="502,57,650,98"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="1012,183,1137,209"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1209,153,1313,180"/>
<area shape="rect" id="node11" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="1185,205,1336,246"/>
<area shape="rect" id="node12" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1384,212,1531,239"/>
</map>
</div>

</div>
</div>
<a id="a3c2a47b9395910d9fc183cf16ec0ed38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2a47b9395910d9fc183cf16ec0ed38">&#9670;&nbsp;</a></span>getGreatestCommonSubtypes() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> souffle::getGreatestCommonSubtypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the greatest common sub types of all the types in the given set. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00588">588</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_type_system_8h_source.html#l00274">souffle::TypeSet::begin()</a>, <a class="el" href="_type_system_8cpp_source.html#l00540">getGreatestCommonSubtypes()</a>, and <a class="el" href="_type_system_8h_source.html#l00229">souffle::TypeSet::insert()</a>.</p>
<div class="fragment"><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;                                                      {</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    <span class="comment">// handle the empty set</span></div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">set</span>.empty()) {</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">set</span>;</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;    }</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;    <span class="comment">// handle the all set =&gt; empty set (since no common sub-type)</span></div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">set</span>.isAll()) {</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;        <span class="keywordflow">return</span> TypeSet();</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    }</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    TypeSet res;</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;    <span class="keyword">auto</span> it = <span class="keyword">set</span>.begin();</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;    res.insert(*it);</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;    ++it;</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;    <span class="comment">// refine sub-set step by step</span></div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;    <span class="keywordflow">for</span> (; it != <span class="keyword">set</span>.end(); ++it) {</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;        TypeSet tmp;</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; cur : res) {</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;            tmp.insert(<a class="code" href="namespacesouffle.html#aed5ab68f123baedeb78d6c94920deb5d">getGreatestCommonSubtypes</a>(cur, *it));</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;        }</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;        res = tmp;</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    }</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;    <span class="comment">// done</span></div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;    <span class="keywordflow">return</span> res;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_aed5ab68f123baedeb78d6c94920deb5d"><div class="ttname"><a href="namespacesouffle.html#aed5ab68f123baedeb78d6c94920deb5d">souffle::getGreatestCommonSubtypes</a></div><div class="ttdeci">TypeSet getGreatestCommonSubtypes(const TypeSet &amp;a, const TypeSet &amp;b)</div><div class="ttdoc">The set of pair-wise greatest common sub types of the types in the two given sets. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00617">TypeSystem.cpp:617</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a3c2a47b9395910d9fc183cf16ec0ed38_cgraph.png" border="0" usemap="#namespacesouffle_a3c2a47b9395910d9fc183cf16ec0ed38_cgraph" alt=""/></div>
<map name="namespacesouffle_a3c2a47b9395910d9fc183cf16ec0ed38_cgraph" id="namespacesouffle_a3c2a47b9395910d9fc183cf16ec0ed38_cgraph">
<area shape="rect" id="node2" href="structsouffle_1_1_type_set.html#a6a55651b4f3aafc2dd60280ed38e1918" title="Allows to iterate over the types contained in this set (only if not universal) " alt="" coords="285,253,454,279"/>
<area shape="rect" id="node4" href="namespacesouffle.html#abb20659f25b4513908b813cfdbf43e23" title="Computes the greatest common sub types of the two given types. " alt="" coords="264,384,475,425"/>
<area shape="rect" id="node8" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="523,509,693,535"/>
<area shape="rect" id="node3" href="namespacesouffle.html#aeb411c7585f438a75ef3de5b6ae2abc5" title="A factory function enabling the construction of a dereferencing iterator utilizing the automated dedu..." alt="" coords="543,173,673,199"/>
<area shape="rect" id="node5" href="classsouffle_1_1_union_type.html#a0175bce933a70c1d3691114860ac17fc" title="souffle::UnionType\l::getElementTypes" alt="" coords="537,443,679,484"/>
<area shape="rect" id="node7" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="976,249,1223,275"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="531,223,685,250"/>
<area shape="rect" id="node10" href="classsouffle_1_1_type_environment.html#a5ead83575e9abfebb3a0b180a33a7d96" title="souffle::TypeEnvironment\l::isType" alt="" coords="741,325,928,367"/>
<area shape="rect" id="node6" href="classsouffle_1_1_type.html#a00437c665d598367ff16229c823c728f" title="souffle::Type::print" alt="" coords="763,450,906,477"/>
<area shape="rect" id="node11" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="1006,91,1193,132"/>
<area shape="rect" id="node16" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="751,173,918,199"/>
<area shape="rect" id="node17" href="classsouffle_1_1_type_environment.html#a72fa419d33bf813f22efabec629a4627" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="1006,156,1193,197"/>
<area shape="rect" id="node18" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="753,223,917,250"/>
<area shape="rect" id="node19" href="classsouffle_1_1_subset_type.html#ac5c52e503cbce42370d6ada3f050773d" title="souffle::SubsetType\l::getBaseType" alt="" coords="761,5,909,47"/>
<area shape="rect" id="node12" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="1271,131,1396,158"/>
<area shape="rect" id="node13" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1467,102,1571,129"/>
<area shape="rect" id="node14" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="1444,153,1595,195"/>
<area shape="rect" id="node15" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1643,161,1789,187"/>
</map>
</div>

</div>
</div>
<a id="aed5ab68f123baedeb78d6c94920deb5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5ab68f123baedeb78d6c94920deb5d">&#9670;&nbsp;</a></span>getGreatestCommonSubtypes() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> souffle::getGreatestCommonSubtypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The set of pair-wise greatest common sub types of the types in the two given sets. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00617">617</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="html_js_chartist_min_8h_source.html#l00015">b</a>, <a class="el" href="_type_system_8h_source.html#l00208">souffle::TypeSet::empty()</a>, <a class="el" href="_type_system_8cpp_source.html#l00540">getGreatestCommonSubtypes()</a>, <a class="el" href="_type_system_8h_source.html#l00229">souffle::TypeSet::insert()</a>, and <a class="el" href="_type_system_8h_source.html#l00213">souffle::TypeSet::isAll()</a>.</p>
<div class="fragment"><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;                                                                      {</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;    <span class="comment">// special cases</span></div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;    <span class="keywordflow">if</span> (a.empty()) {</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;        <span class="keywordflow">return</span> a;</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;    }</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>.empty()) {</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>;</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    }</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;    <span class="keywordflow">if</span> (a.isAll()) {</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>;</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;    }</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>.isAll()) {</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;        <span class="keywordflow">return</span> a;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;    }</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;    <span class="comment">// compute pairwise greatest common sub types</span></div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;    TypeSet res;</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; x : a) {</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; y : <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>) {</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;            res.insert(<a class="code" href="namespacesouffle.html#aed5ab68f123baedeb78d6c94920deb5d">getGreatestCommonSubtypes</a>(x, y));</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;        }</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;    }</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;    <span class="keywordflow">return</span> res;</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_aed5ab68f123baedeb78d6c94920deb5d"><div class="ttname"><a href="namespacesouffle.html#aed5ab68f123baedeb78d6c94920deb5d">souffle::getGreatestCommonSubtypes</a></div><div class="ttdeci">TypeSet getGreatestCommonSubtypes(const TypeSet &amp;a, const TypeSet &amp;b)</div><div class="ttdoc">The set of pair-wise greatest common sub types of the types in the two given sets. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00617">TypeSystem.cpp:617</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aed5ab68f123baedeb78d6c94920deb5d_cgraph.png" border="0" usemap="#namespacesouffle_aed5ab68f123baedeb78d6c94920deb5d_cgraph" alt=""/></div>
<map name="namespacesouffle_aed5ab68f123baedeb78d6c94920deb5d_cgraph" id="namespacesouffle_aed5ab68f123baedeb78d6c94920deb5d_cgraph">
<area shape="rect" id="node2" href="structsouffle_1_1_type_set.html#a2110dea550ae2c1eaf6ef65e2854f925" title="Emptiness check. " alt="" coords="282,296,457,323"/>
<area shape="rect" id="node3" href="namespacesouffle.html#abb20659f25b4513908b813cfdbf43e23" title="Computes the greatest common sub types of the two given types. " alt="" coords="264,347,475,389"/>
<area shape="rect" id="node7" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="523,493,693,520"/>
<area shape="rect" id="node19" href="structsouffle_1_1_type_set.html#ae26622401685d8ac9080b2f5a83d7eaa" title="Universality check. " alt="" coords="289,464,450,491"/>
<area shape="rect" id="node4" href="classsouffle_1_1_union_type.html#a0175bce933a70c1d3691114860ac17fc" title="souffle::UnionType\l::getElementTypes" alt="" coords="537,18,679,59"/>
<area shape="rect" id="node6" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="976,228,1223,255"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="531,255,685,281"/>
<area shape="rect" id="node9" href="classsouffle_1_1_type_environment.html#a5ead83575e9abfebb3a0b180a33a7d96" title="souffle::TypeEnvironment\l::isType" alt="" coords="741,57,928,98"/>
<area shape="rect" id="node5" href="classsouffle_1_1_type.html#a00437c665d598367ff16229c823c728f" title="souffle::Type::print" alt="" coords="763,5,906,32"/>
<area shape="rect" id="node10" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="1006,162,1193,203"/>
<area shape="rect" id="node15" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="751,173,918,200"/>
<area shape="rect" id="node16" href="classsouffle_1_1_type_environment.html#a72fa419d33bf813f22efabec629a4627" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="1006,279,1193,321"/>
<area shape="rect" id="node17" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="753,275,917,301"/>
<area shape="rect" id="node18" href="classsouffle_1_1_subset_type.html#ac5c52e503cbce42370d6ada3f050773d" title="souffle::SubsetType\l::getBaseType" alt="" coords="761,377,909,418"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="1271,228,1396,255"/>
<area shape="rect" id="node12" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1467,199,1571,225"/>
<area shape="rect" id="node13" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="1444,250,1595,291"/>
<area shape="rect" id="node14" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1643,257,1789,284"/>
</map>
</div>

</div>
</div>
<a id="ae842d250436dbed4b6479bf915fcf363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae842d250436dbed4b6479bf915fcf363">&#9670;&nbsp;</a></span>getGreatestCommonSubtypes() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> souffle::getGreatestCommonSubtypes </td>
          <td>(</td>
          <td class="paramtype">const Types &amp;...&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the greatest common sub types of the given types. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8h_source.html#l00643">643</a> of file <a class="el" href="_type_system_8h_source.html">TypeSystem.h</a>.</p>

<p class="reference">References <a class="el" href="_type_system_8cpp_source.html#l00540">getGreatestCommonSubtypes()</a>.</p>
<div class="fragment"><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;                                                         {</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#ae842d250436dbed4b6479bf915fcf363">getGreatestCommonSubtypes</a>(TypeSet(<a class="code" href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>...));</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;}</div><div class="ttc" id="_component_instantiation_transformer_8cpp_html_a769811c621f0af455fbefd863c0f1a0c"><div class="ttname"><a href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a></div><div class="ttdeci">std::vector&lt; std::unique_ptr&lt; AstType &gt; &gt; types</div><div class="ttdef"><b>Definition:</b> <a href="_component_instantiation_transformer_8cpp_source.html#l00046">ComponentInstantiationTransformer.cpp:46</a></div></div>
<div class="ttc" id="namespacesouffle_html_ae842d250436dbed4b6479bf915fcf363"><div class="ttname"><a href="namespacesouffle.html#ae842d250436dbed4b6479bf915fcf363">souffle::getGreatestCommonSubtypes</a></div><div class="ttdeci">TypeSet getGreatestCommonSubtypes(const Types &amp;... types)</div><div class="ttdoc">Computes the greatest common sub types of the given types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8h_source.html#l00643">TypeSystem.h:643</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ae842d250436dbed4b6479bf915fcf363_cgraph.png" border="0" usemap="#namespacesouffle_ae842d250436dbed4b6479bf915fcf363_cgraph" alt=""/></div>
<map name="namespacesouffle_ae842d250436dbed4b6479bf915fcf363_cgraph" id="namespacesouffle_ae842d250436dbed4b6479bf915fcf363_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#abb20659f25b4513908b813cfdbf43e23" title="Computes the greatest common sub types of the two given types. " alt="" coords="264,377,475,418"/>
<area shape="rect" id="node3" href="classsouffle_1_1_union_type.html#a0175bce933a70c1d3691114860ac17fc" title="souffle::UnionType\l::getElementTypes" alt="" coords="537,78,679,119"/>
<area shape="rect" id="node5" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="976,300,1223,327"/>
<area shape="rect" id="node6" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="523,493,693,520"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="531,249,685,276"/>
<area shape="rect" id="node8" href="classsouffle_1_1_type_environment.html#a5ead83575e9abfebb3a0b180a33a7d96" title="souffle::TypeEnvironment\l::isType" alt="" coords="741,377,928,418"/>
<area shape="rect" id="node4" href="classsouffle_1_1_type.html#a00437c665d598367ff16229c823c728f" title="souffle::Type::print" alt="" coords="763,5,906,32"/>
<area shape="rect" id="node9" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="1006,207,1193,249"/>
<area shape="rect" id="node14" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="751,275,918,301"/>
<area shape="rect" id="node15" href="classsouffle_1_1_type_environment.html#a72fa419d33bf813f22efabec629a4627" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="1006,142,1193,183"/>
<area shape="rect" id="node16" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="753,224,917,251"/>
<area shape="rect" id="node17" href="classsouffle_1_1_subset_type.html#ac5c52e503cbce42370d6ada3f050773d" title="souffle::SubsetType\l::getBaseType" alt="" coords="761,57,909,98"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="1271,183,1396,209"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1467,153,1571,180"/>
<area shape="rect" id="node12" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="1444,205,1595,246"/>
<area shape="rect" id="node13" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1643,212,1789,239"/>
</map>
</div>

</div>
</div>
<a id="a247fd46943465169ffe79f25628e5dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247fd46943465169ffe79f25628e5dad">&#9670;&nbsp;</a></span>getGroundedTerms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *, bool &gt; souffle::getGroundedTerms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyse the given clause and computes for each contained argument whether it is a grounded value or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clause</td><td>the clause to be analyzed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a map mapping each contained argument to a boolean indicating whether the argument represents a grounded value or not </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_ground_analysis_8cpp_source.html#l00148">148</a> of file <a class="el" href="_ast_ground_analysis_8cpp_source.html">AstGroundAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_literal_8h_source.html#l00078">souffle::AstAtom::getArguments()</a>, <a class="el" href="_ast_argument_8h_source.html#l00221">souffle::AstTerm::getArguments()</a>, <a class="el" href="_ast_literal_8h_source.html#l00133">souffle::AstNegation::getAtom()</a>, <a class="el" href="_ast_clause_8h_source.html#l00166">souffle::AstClause::getHead()</a>, <a class="el" href="_ast_literal_8h_source.html#l00239">souffle::AstBinaryConstraint::getLHS()</a>, <a class="el" href="_ast_literal_8h_source.html#l00249">souffle::AstBinaryConstraint::getOperator()</a>, <a class="el" href="_ast_literal_8h_source.html#l00244">souffle::AstBinaryConstraint::getRHS()</a>, <a class="el" href="_ast_argument_8h_source.html#l00434">souffle::AstTypeCast::getValue()</a>, <a class="el" href="_binary_constraint_ops_8h_source.html#l00061">isEqConstraint()</a>, <a class="el" href="_resolve_aliases_transformer_8cpp_source.html#l00160">lhs</a>, and <a class="el" href="_resolve_aliases_transformer_8cpp_source.html#l00161">rhs</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l01566">souffle::ResolveAnonymousRecordsAliases::findVariablesRecordMapping()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00484">souffle::AstSemanticChecker::isDependent()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00224">souffle::MaterializeAggregationQueriesTransformer::materializeAggregationQueries()</a>, and <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00985">usesInvalidWitness()</a>.</p>
<div class="fragment"><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                                                                           {</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="keyword">struct </span>Analysis : <span class="keyword">public</span> AstConstraintAnalysis&lt;BoolDisjunctVar&gt; {</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        std::set&lt;const AstAtom*&gt; ignore;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        <span class="comment">// atoms are producing grounded variables</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        <span class="keywordtype">void</span> visitAtom(<span class="keyword">const</span> AstAtom&amp; cur)<span class="keyword"> override </span>{</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;            <span class="comment">// some atoms need to be skipped (head or negation)</span></div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            <span class="keywordflow">if</span> (ignore.find(&amp;cur) != ignore.end()) {</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                <span class="keywordflow">return</span>;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;            }</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;            <span class="comment">// all arguments are grounded</span></div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; arg : cur.getArguments()) {</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                addConstraint(isTrue(getVar(arg)));</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            }</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        }</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        <span class="comment">// negations need to be skipped</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        <span class="keywordtype">void</span> visitNegation(<span class="keyword">const</span> AstNegation&amp; cur)<span class="keyword"> override </span>{</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            <span class="comment">// add nested atom to black-list</span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;            ignore.insert(cur.getAtom());</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        }</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="comment">// also skip head</span></div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        <span class="keywordtype">void</span> visitClause(<span class="keyword">const</span> AstClause&amp; clause)<span class="keyword"> override </span>{</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            <span class="comment">// ignore head</span></div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            ignore.insert(clause.getHead());</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        }</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        <span class="comment">// binary equality relations propagates groundness</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        <span class="keywordtype">void</span> visitBinaryConstraint(<span class="keyword">const</span> AstBinaryConstraint&amp; cur)<span class="keyword"> override </span>{</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;            <span class="comment">// only target equality</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;            <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a6befeedfd76433e1bd51a1f6cd42afec">isEqConstraint</a>(cur.getOperator())) {</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                <span class="keywordflow">return</span>;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;            }</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            <span class="comment">// if equal, link right and left side</span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;            <span class="keyword">auto</span> <a class="code" href="_resolve_aliases_transformer_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a> = getVar(cur.getLHS());</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;            <span class="keyword">auto</span> <a class="code" href="_resolve_aliases_transformer_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a> = getVar(cur.getRHS());</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;            addConstraint(imply(<a class="code" href="_resolve_aliases_transformer_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>, rhs));</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;            addConstraint(imply(rhs, <a class="code" href="_resolve_aliases_transformer_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>));</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        }</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        <span class="comment">// record init nodes</span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        <span class="keywordtype">void</span> visitRecordInit(<span class="keyword">const</span> AstRecordInit&amp; init)<span class="keyword"> override </span>{</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;            <span class="keyword">auto</span> cur = getVar(init);</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;            std::vector&lt;BoolDisjunctVar&gt; vars;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;            <span class="comment">// if record is grounded, so are all its arguments</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; arg : init.getArguments()) {</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                <span class="keyword">auto</span> arg_var = getVar(arg);</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                addConstraint(imply(cur, arg_var));</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;                vars.push_back(arg_var);</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;            }</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;            <span class="comment">// if all arguments are grounded, so is the record</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;            addConstraint(imply(vars, cur));</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        }</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        <span class="comment">// constants are also sources of grounded values</span></div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        <span class="keywordtype">void</span> visitConstant(<span class="keyword">const</span> AstConstant&amp; c)<span class="keyword"> override </span>{</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;            addConstraint(isTrue(getVar(c)));</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        }</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        <span class="comment">// aggregators are grounding values</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <span class="keywordtype">void</span> visitAggregator(<span class="keyword">const</span> AstAggregator&amp; c)<span class="keyword"> override </span>{</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;            addConstraint(isTrue(getVar(c)));</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        }</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        <span class="comment">// functors with grounded values are grounded values</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        <span class="keywordtype">void</span> visitFunctor(<span class="keyword">const</span> AstFunctor&amp; cur)<span class="keyword"> override </span>{</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;            <span class="keyword">auto</span> fun = getVar(cur);</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;            std::vector&lt;BoolDisjunctVar&gt; varArgs;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; arg : cur.getArguments()) {</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                varArgs.push_back(getVar(arg));</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;            }</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;            addConstraint(imply(varArgs, fun));</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        }</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        <span class="comment">// casts propogate groundedness in and out</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        <span class="keywordtype">void</span> visitTypeCast(<span class="keyword">const</span> AstTypeCast&amp; cast)<span class="keyword"> override </span>{</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;            addConstraint(imply(getVar(cast.getValue()), getVar(cast)));</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        }</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    };</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <span class="comment">// run analysis on given clause</span></div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    <span class="keywordflow">return</span> Analysis().analyse(clause);</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;}</div><div class="ttc" id="_resolve_aliases_transformer_8cpp_html_a99d7476d0087a8405f52a79852efa6eb"><div class="ttname"><a href="_resolve_aliases_transformer_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; rhs</div><div class="ttdef"><b>Definition:</b> <a href="_resolve_aliases_transformer_8cpp_source.html#l00161">ResolveAliasesTransformer.cpp:161</a></div></div>
<div class="ttc" id="namespacesouffle_html_a6befeedfd76433e1bd51a1f6cd42afec"><div class="ttname"><a href="namespacesouffle.html#a6befeedfd76433e1bd51a1f6cd42afec">souffle::isEqConstraint</a></div><div class="ttdeci">bool isEqConstraint(const BinaryConstraintOp constraintOp)</div><div class="ttdef"><b>Definition:</b> <a href="_binary_constraint_ops_8h_source.html#l00061">BinaryConstraintOps.h:61</a></div></div>
<div class="ttc" id="_resolve_aliases_transformer_8cpp_html_aae193eebe112e754a082b152fb272018"><div class="ttname"><a href="_resolve_aliases_transformer_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; lhs</div><div class="ttdef"><b>Definition:</b> <a href="_resolve_aliases_transformer_8cpp_source.html#l00160">ResolveAliasesTransformer.cpp:160</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a247fd46943465169ffe79f25628e5dad_cgraph.png" border="0" usemap="#namespacesouffle_a247fd46943465169ffe79f25628e5dad_cgraph" alt=""/></div>
<map name="namespacesouffle_a247fd46943465169ffe79f25628e5dad_cgraph" id="namespacesouffle_a247fd46943465169ffe79f25628e5dad_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="251,5,481,32"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_term.html#a5bf9145afa6b327c21e3393123c292c3" title="get arguments " alt="" coords="253,56,479,83"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_negation.html#a587c8d4fdcfc28f128cc3ff2cf97895c" title="get negated atom " alt="" coords="289,107,443,149"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="297,173,435,214"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_binary_constraint.html#a72b9e10473e1748d720bbf68a3e7f471" title="get LHS argument " alt="" coords="264,238,468,279"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_binary_constraint.html#aec8d30b8684b3a2f5f715204999776a0" title="get binary operator " alt="" coords="264,303,468,345"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_binary_constraint.html#a61055c91c04bcbe4d03873044c6bf4b8" title="get RHS argument " alt="" coords="264,369,468,410"/>
<area shape="rect" id="node10" href="classsouffle_1_1_ast_type_cast.html#a4fe729dc92cd0e38102249123acbc317" title="Get value. " alt="" coords="289,434,443,475"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a6befeedfd76433e1bd51a1f6cd42afec" title="souffle::isEqConstraint" alt="" coords="282,500,450,527"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="529,31,676,57"/>
</map>
</div>

</div>
</div>
<a id="ae5266d9360a88847a65d1c581f778d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5266d9360a88847a65d1c581f778d89">&#9670;&nbsp;</a></span>getHeadRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> * souffle::getHeadRelation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *&#160;</td>
          <td class="paramname"><em>program</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the relation referenced by the head of the given clause. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clause</td><td>the clause </td></tr>
    <tr><td class="paramname">program</td><td>the program containing the relations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>relation referenced by the clause head </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00079">79</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_utils_8cpp_source.html#l00075">getAtomRelation()</a>, and <a class="el" href="_ast_clause_8h_source.html#l00166">souffle::AstClause::getHead()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_precedence_graph_8cpp_source.html#l00231">souffle::RecursiveClauses::computeIsRecursive()</a>, and <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>.</p>
<div class="fragment"><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                                                                                       {</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">getAtomRelation</a>(clause-&gt;getHead(), program);</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_ab18cbb3adc2ab328de0db30a3fddf7e0"><div class="ttname"><a href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">souffle::getAtomRelation</a></div><div class="ttdeci">const AstRelation * getAtomRelation(const AstAtom *atom, const AstProgram *program)</div><div class="ttdoc">Returns the relation referenced by the given atom. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00075">AstUtils.cpp:75</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ae5266d9360a88847a65d1c581f778d89_cgraph.png" border="0" usemap="#namespacesouffle_ae5266d9360a88847a65d1c581f778d89_cgraph" alt=""/></div>
<map name="namespacesouffle_ae5266d9360a88847a65d1c581f778d89_cgraph" id="namespacesouffle_ae5266d9360a88847a65d1c581f778d89_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0" title="Returns the relation referenced by the given atom. " alt="" coords="236,31,419,57"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="258,82,397,123"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="467,5,723,32"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="521,56,669,83"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="794,27,898,53"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="771,78,921,119"/>
<area shape="rect" id="node7" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="969,85,1116,112"/>
</map>
</div>

</div>
</div>
<a id="a62f80c157a6a365d78a43592732a8efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f80c157a6a365d78a43592732a8efa">&#9670;&nbsp;</a></span>getIf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">C::value_type souffle::getIf </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const typename C::value_type)&gt;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first element in a container that satisfies a given predicate, nullptr otherwise. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00318">318</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_utils_8cpp_source.html#l00064">getFunctorDeclaration()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00056">getRelation()</a>, and <a class="el" href="_ast_utils_8cpp_source.html#l00060">getType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                                                                                                   {</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    <span class="keyword">auto</span> res = std::find_if(container.begin(), container.end(),</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;            [&amp;](<span class="keyword">const</span> <span class="keyword">typename</span> C::value_type item) { <span class="keywordflow">return</span> pred(item); });</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    <span class="keywordflow">return</span> res == container.end() ? nullptr : *res;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aeddc699418d426e1ffcb965e37ccb3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeddc699418d426e1ffcb965e37ccb3a2">&#9670;&nbsp;</a></span>getInlinedArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt;<a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a>*&gt; souffle::getInlinedArgument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of arguments that should replace the given argument after one step of inlining. </p>
<p>Note: This function is currently generalised to perform any required inlining within aggregators as well, making it simple to extend to this later on if desired (and the semantic check is removed). </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00529">529</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9eeb52badb613229884838847294b90d">ADD</a>, <a class="el" href="_util_8h_source.html#l00465">clone()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00504">combineAggregators()</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a4905ac9d6a22bdfc1ae096094ce6248d">COUNT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc2cbacfa7c4ef9bc72773ebdd9fe166">FADD</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1">FMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6">FMIN</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a0645fcc11b74dbdbf2d7501942fa6f6f">FSUM</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00787">getInlinedLiteral()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00057">souffle::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="json11_8h_source.html#l00651">i</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00053">souffle::NullableVector&lt; T &gt;::isValid()</a>, <a class="el" href="html_js_chartist_min_8h_source.html#l00015">j</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">MAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a4ea6d1161ea24d7599365f574aff6610">MEAN</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">MIN</a>, <a class="el" href="_ast_argument_8h_source.html#l00509">souffle::AstAggregator::setBody()</a>, <a class="el" href="_ast_node_8h_source.html#l00050">souffle::AstNode::setSrcLoc()</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a6970bdc2201030b9c03fbdcf3973858a">SUM</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a1f0002abde2c29615d914ab0228c68d3">UADD</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059">UMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb">UMIN</a>, and <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ae6246115490f016a4ecb2604ba5fc2ed">USUM</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00731">getInlinedAtom()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00787">getInlinedLiteral()</a>.</p>
<div class="fragment"><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;                                                                                             {</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;    std::vector&lt;AstArgument*&gt; versions;</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;    <span class="comment">// Each argument has to be handled differently - essentially, want to go down to</span></div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;    <span class="comment">// nested aggregators, and inline their bodies if needed.</span></div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* aggr = dynamic_cast&lt;const AstAggregator*&gt;(arg)) {</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;        <span class="comment">// First try inlining the target expression if necessary</span></div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;        <span class="keywordflow">if</span> (aggr-&gt;getTargetExpression() != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;            NullableVector&lt;AstArgument*&gt; argumentVersions =</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;                    <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, aggr-&gt;getTargetExpression());</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;            <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;                <span class="comment">// An element in the target expression can be inlined!</span></div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;                changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;                <span class="comment">// Create a new aggregator per version of the target expression</span></div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;                <span class="keywordflow">for</span> (AstArgument* newArg : argumentVersions.getVector()) {</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;                    <span class="keyword">auto</span>* newAggr =</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;                            <span class="keyword">new</span> AstAggregator(aggr-&gt;getOperator(), std::unique_ptr&lt;AstArgument&gt;(newArg));</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;                    std::vector&lt;std::unique_ptr&lt;AstLiteral&gt;&gt; newBody;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                    <span class="keywordflow">for</span> (AstLiteral* lit : aggr-&gt;getBodyLiterals()) {</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;                        newBody.push_back(std::unique_ptr&lt;AstLiteral&gt;(lit-&gt;clone()));</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;                    }</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;                    newAggr-&gt;setBody(std::move(newBody));</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;                    versions.push_back(newAggr);</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;                }</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;            }</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;        }</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;        <span class="comment">// Try inlining body arguments if the target expression has not been changed.</span></div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;        <span class="comment">// (At this point we only handle one step of inlining at a time)</span></div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;        <span class="keywordflow">if</span> (!changed) {</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;            std::vector&lt;AstLiteral*&gt; bodyLiterals = aggr-&gt;getBodyLiterals();</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; bodyLiterals.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;                AstLiteral* currLit = bodyLiterals[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;                NullableVector&lt;std::vector&lt;AstLiteral*&gt;&gt; literalVersions =</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;                        <a class="code" href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1">getInlinedLiteral</a>(program, currLit);</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;                <span class="keywordflow">if</span> (literalVersions.isValid()) {</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;                    <span class="comment">// Literal can be inlined!</span></div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;                    changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;                    <a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">AggregateOp</a> op = aggr-&gt;getOperator();</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;                    <span class="comment">// Create an aggregator (with the same operation) for each possible body</span></div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;                    std::vector&lt;AstAggregator*&gt; aggrVersions;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;                    <span class="keywordflow">for</span> (std::vector&lt;AstLiteral*&gt; inlineVersions : literalVersions.getVector()) {</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;                        std::unique_ptr&lt;AstArgument&gt; target;</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;                        <span class="keywordflow">if</span> (aggr-&gt;getTargetExpression() != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;                            target = std::unique_ptr&lt;AstArgument&gt;(aggr-&gt;getTargetExpression()-&gt;clone());</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;                        }</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;                        <span class="keyword">auto</span>* newAggr = <span class="keyword">new</span> AstAggregator(aggr-&gt;getOperator(), std::move(target));</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;                        std::vector&lt;std::unique_ptr&lt;AstLiteral&gt;&gt; newBody;</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;                        <span class="comment">// Add in everything except the current literal being replaced</span></div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;                        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> = 0; <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> &lt; bodyLiterals.size(); <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>++) {</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;                            <span class="keywordflow">if</span> (<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> != <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>) {</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;                                newBody.push_back(std::unique_ptr&lt;AstLiteral&gt;(bodyLiterals[<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>]-&gt;<a class="code" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f">clone</a>()));</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                            }</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;                        }</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;                        <span class="comment">// Add in everything new that replaces that literal</span></div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;                        <span class="keywordflow">for</span> (AstLiteral* addedLit : inlineVersions) {</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;                            newBody.push_back(std::unique_ptr&lt;AstLiteral&gt;(addedLit));</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;                        }</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;                        newAggr-&gt;setBody(std::move(newBody));</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;                        aggrVersions.push_back(newAggr);</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;                    }</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;                    <span class="comment">// Utility lambda: get functor used to tie aggregators together.</span></div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;                    <span class="keyword">auto</span> aggregateToFunctor = [](<a class="code" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">AggregateOp</a> op) {</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;                        <span class="keywordflow">switch</span> (op) {</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::MIN:</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;                                <span class="keywordflow">return</span> FunctorOp::MIN;</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::FMIN:</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;                                <span class="keywordflow">return</span> FunctorOp::FMIN;</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::UMIN:</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;                                <span class="keywordflow">return</span> FunctorOp::UMIN;</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::MAX:</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;                                <span class="keywordflow">return</span> FunctorOp::MAX;</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::FMAX:</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;                                <span class="keywordflow">return</span> FunctorOp::FMAX;</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::UMAX:</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;                                <span class="keywordflow">return</span> FunctorOp::UMAX;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::SUM:</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;                                <span class="keywordflow">return</span> FunctorOp::ADD;</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::FSUM:</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;                                <span class="keywordflow">return</span> FunctorOp::FADD;</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::USUM:</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;                                <span class="keywordflow">return</span> FunctorOp::UADD;</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::COUNT:</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;                                <span class="keywordflow">return</span> FunctorOp::ADD;</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;                            <span class="keywordflow">case</span> AggregateOp::MEAN:</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;                                assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;no translation&quot;</span>);</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;                            <span class="keywordflow">default</span>:</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;                                assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported aggregate operation&quot;</span>);</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;                        }</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;                    };</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;                    <span class="comment">// Create the actual overall aggregator that ties the replacement aggregators together.</span></div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;                    <span class="comment">// example: min x : { a(x) }. &lt;=&gt; min ( min x : { a1(x) }, min x : { a2(x) }, ... )</span></div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;                    <span class="keywordflow">if</span> (op != AggregateOp::MEAN) {</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;                        versions.push_back(<a class="code" href="namespacesouffle.html#a42c2f399b871f8fe7f0ba652812e2db5">combineAggregators</a>(aggrVersions, aggregateToFunctor(op)));</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;                    }</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;                }</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;                <span class="comment">// Only perform one stage of inlining at a time.</span></div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;                <span class="keywordflow">if</span> (changed) {</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;                }</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;            }</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;        }</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* functor = dynamic_cast&lt;const AstFunctor*&gt;(arg)) {</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;        <span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0;</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> funArg : functor-&gt;getArguments()) {</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;            <span class="comment">// TODO (azreika): use unique pointers</span></div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;            <span class="comment">// try inlining each argument from left to right</span></div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;            NullableVector&lt;AstArgument*&gt; argumentVersions = <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, funArg);</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;            <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;                changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;                <span class="keywordflow">for</span> (AstArgument* newArgVersion : argumentVersions.getVector()) {</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;                    <span class="comment">// same functor but with new argument version</span></div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;                    std::vector&lt;std::unique_ptr&lt;AstArgument&gt;&gt; argsCopy;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;                    <span class="keywordtype">size_t</span> <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> = 0;</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;                    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; functorArg : functor-&gt;getArguments()) {</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;                        <span class="keywordflow">if</span> (j == i) {</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;                            argsCopy.emplace_back(newArgVersion);</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;                            argsCopy.emplace_back(functorArg-&gt;clone());</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;                        }</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;                        ++<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>;</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;                    }</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;                    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* intrFunc = dynamic_cast&lt;const AstIntrinsicFunctor*&gt;(arg)) {</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;                        <span class="keyword">auto</span>* newFunctor =</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;                                <span class="keyword">new</span> AstIntrinsicFunctor(intrFunc-&gt;getFunction(), std::move(argsCopy));</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;                        newFunctor-&gt;setSrcLoc(functor-&gt;getSrcLoc());</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;                        versions.push_back(newFunctor);</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* userFunc = dynamic_cast&lt;const AstUserDefinedFunctor*&gt;(arg)) {</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;                        <span class="keyword">auto</span>* newFunctor =</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;                                <span class="keyword">new</span> AstUserDefinedFunctor(userFunc-&gt;getName(), std::move(argsCopy));</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;                        newFunctor-&gt;setSrcLoc(userFunc-&gt;getSrcLoc());</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;                        versions.push_back(newFunctor);</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;                    }</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;                }</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;                <span class="comment">// only one step at a time</span></div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;            }</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;            ++<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;        }</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* cast = dynamic_cast&lt;const AstTypeCast*&gt;(arg)) {</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;        NullableVector&lt;AstArgument*&gt; argumentVersions = <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, cast-&gt;getValue());</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;        <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;            changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;            <span class="keywordflow">for</span> (AstArgument* newArg : argumentVersions.getVector()) {</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;                AstArgument* newTypeCast =</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;                        <span class="keyword">new</span> AstTypeCast(std::unique_ptr&lt;AstArgument&gt;(newArg), cast-&gt;getType());</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;                versions.push_back(newTypeCast);</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;            }</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;        }</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* record = dynamic_cast&lt;const AstRecordInit*&gt;(arg)) {</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;        std::vector&lt;AstArgument*&gt; recordArguments = record-&gt;getArguments();</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; recordArguments.size(); i++) {</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;            AstArgument* currentRecArg = recordArguments[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;            NullableVector&lt;AstArgument*&gt; argumentVersions = <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, currentRecArg);</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;            <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;                changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;                <span class="keywordflow">for</span> (AstArgument* newArgumentVersion : argumentVersions.getVector()) {</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;                    <span class="keyword">auto</span>* newRecordArg = <span class="keyword">new</span> AstRecordInit();</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; recordArguments.size(); j++) {</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;                        <span class="keywordflow">if</span> (i == j) {</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;                            newRecordArg-&gt;addArgument(std::unique_ptr&lt;AstArgument&gt;(newArgumentVersion));</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;                        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;                            newRecordArg-&gt;addArgument(</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;                                    std::unique_ptr&lt;AstArgument&gt;(recordArguments[j]-&gt;<a class="code" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f">clone</a>()));</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;                        }</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;                    }</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;                    versions.push_back(newRecordArg);</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;                }</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;            }</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;            <span class="comment">// Only perform one stage of inlining at a time.</span></div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;            <span class="keywordflow">if</span> (changed) {</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;            }</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;        }</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;    }</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;    <span class="keywordflow">if</span> (changed) {</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;        <span class="comment">// Return a valid vector - replacements need to be made!</span></div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;AstArgument*&gt;(versions);</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;        <span class="comment">// Return an invalid vector - no inlining has occurred</span></div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;AstArgument*&gt;();</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;    }</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_aa26a7e6147aca5568158e38f08ffcf21"><div class="ttname"><a href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">souffle::AggregateOp</a></div><div class="ttdeci">AggregateOp</div><div class="ttdoc">Types of aggregation functions. </div><div class="ttdef"><b>Definition:</b> <a href="_aggregate_op_8h_source.html#l00024">AggregateOp.h:24</a></div></div>
<div class="ttc" id="namespacesouffle_html_a018886d19f141b1cb565199a517c598f"><div class="ttname"><a href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f">souffle::clone</a></div><div class="ttdeci">std::unique_ptr&lt; A &gt; clone(const A *node)</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00465">Util.h:465</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="namespacesouffle_html_aeddc699418d426e1ffcb965e37ccb3a2"><div class="ttname"><a href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">souffle::getInlinedArgument</a></div><div class="ttdeci">NullableVector&lt; AstArgument * &gt; getInlinedArgument(AstProgram &amp;program, const AstArgument *arg)</div><div class="ttdoc">Returns a vector of arguments that should replace the given argument after one step of inlining...</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00529">InlineRelationsTransformer.cpp:529</a></div></div>
<div class="ttc" id="namespacesouffle_html_a42c2f399b871f8fe7f0ba652812e2db5"><div class="ttname"><a href="namespacesouffle.html#a42c2f399b871f8fe7f0ba652812e2db5">souffle::combineAggregators</a></div><div class="ttdeci">AstArgument * combineAggregators(std::vector&lt; AstAggregator *&gt; aggrs, FunctorOp fun)</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00504">InlineRelationsTransformer.cpp:504</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_aab858032a95af802114b255fac6f45f2"><div class="ttname"><a href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a></div><div class="ttdeci">var j</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a25b07f1c5efea50145140a31f755e0d1"><div class="ttname"><a href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1">souffle::getInlinedLiteral</a></div><div class="ttdeci">NullableVector&lt; std::vector&lt; AstLiteral * &gt; &gt; getInlinedLiteral(AstProgram &amp;, AstLiteral *)</div><div class="ttdoc">Tries to perform a single step of inlining on the given literal. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00787">InlineRelationsTransformer.cpp:787</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aeddc699418d426e1ffcb965e37ccb3a2_cgraph.png" border="0" usemap="#namespacesouffle_aeddc699418d426e1ffcb965e37ccb3a2_cgraph" alt=""/></div>
<map name="namespacesouffle_aeddc699418d426e1ffcb965e37ccb3a2_cgraph" id="namespacesouffle_aeddc699418d426e1ffcb965e37ccb3a2_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="1415,239,1525,266"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a42c2f399b871f8fe7f0ba652812e2db5" title="souffle::combineAggregators" alt="" coords="256,71,465,98"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1" title="Tries to perform a single step of inlining on the given literal. " alt="" coords="271,546,451,573"/>
<area shape="rect" id="node24" href="classsouffle_1_1_nullable_vector.html#ab04c65c2ed18c2756c463c50de1912e8" title="souffle::NullableVector\l::isValid" alt="" coords="1094,173,1263,215"/>
<area shape="rect" id="node25" href="classsouffle_1_1_nullable_vector.html#ad94b793fbfe9e5d0175becd240539fbc" title="souffle::NullableVector\l::getVector" alt="" coords="1094,944,1263,985"/>
<area shape="rect" id="node37" href="classsouffle_1_1_ast_aggregator.html#a427d81a0d8eb9c03d0ab86ef3ef78d5d" title="souffle::AstAggregator\l::setBody" alt="" coords="277,597,444,639"/>
<area shape="rect" id="node38" href="classsouffle_1_1_ast_node.html#a0b664297f0971c6ce32ff2e0e4f2603f" title="Set source location for the AstNode. " alt="" coords="261,663,460,690"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a1193e67992e4f0591e4011faccb4abe2" title="Checks whether a functor operation can have a given argument count. " alt="" coords="526,5,709,47"/>
<area shape="rect" id="node5" href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961" title="Renames all variables in a given argument uniquely. " alt="" coords="525,71,709,98"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_node.html#ad7c4f8ce0322749e72ed60f543c6fd93" title="Apply the mapper to all child nodes. " alt="" coords="799,71,973,98"/>
<area shape="rect" id="node8" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="812,685,960,711"/>
<area shape="rect" id="node12" href="classsouffle_1_1_ast_relation.html#a698481c4da3f71880cb2cf8c622a9cdc" title="check for a relation qualifier " alt="" coords="543,568,691,609"/>
<area shape="rect" id="node13" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="813,735,959,762"/>
<area shape="rect" id="node15" href="namespacesouffle.html#a7dfca9e9addfda4f3e1ee38cbef0d7c0" title="Inlines the given atom based on a given clause. " alt="" coords="791,581,981,607"/>
<area shape="rect" id="node27" href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1" title="Returns a vector of atoms that should replace the given atom after one step of inlining. " alt="" coords="799,390,973,417"/>
<area shape="rect" id="node29" href="namespacesouffle.html#a2e5ef82376f71d4d7ebfcfa64437d540" title="Forms the bodies that will replace the negation of a given inlined atom. " alt="" coords="513,634,721,661"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1127,791,1231,818"/>
<area shape="rect" id="node10" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="1395,851,1545,892"/>
<area shape="rect" id="node11" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1666,711,1813,738"/>
<area shape="rect" id="node14" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="1395,916,1545,957"/>
<area shape="rect" id="node16" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Create a clone (i.e. " alt="" coords="1109,508,1248,549"/>
<area shape="rect" id="node18" href="classsouffle_1_1_ast_clause.html#ab7a5b630d02cd69873aab066c2bd9c46" title="Apply the mapper to all child nodes. " alt="" coords="1109,573,1248,615"/>
<area shape="rect" id="node19" href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="1104,639,1253,666"/>
<area shape="rect" id="node23" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="1109,443,1248,484"/>
<area shape="rect" id="node26" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="1401,668,1539,709"/>
<area shape="rect" id="node17" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="1639,465,1839,491"/>
<area shape="rect" id="node20" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="1355,566,1585,593"/>
<area shape="rect" id="node21" href="namespacesouffle.html#a659ae2c89cfab47908f27a660f82c147" title="Reduces a vector of substitutions. " alt="" coords="1372,515,1568,542"/>
<area shape="rect" id="node22" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828" title="A generic factory for constraints of the form. " alt="" coords="1691,515,1788,542"/>
<area shape="rect" id="node28" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="1051,391,1307,418"/>
<area shape="rect" id="node30" href="namespacesouffle.html#a0e3e2145b6ac09dba3c7ba2e5535935f" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="769,634,1003,661"/>
<area shape="rect" id="node31" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d" title="Returns the negated version of a given literal. " alt="" coords="1099,741,1259,767"/>
<area shape="rect" id="node32" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Create a clone (i.e. " alt="" coords="1383,617,1557,643"/>
<area shape="rect" id="node34" href="classsouffle_1_1_ast_constraint.html#a4bc070302396ff2bee073f62c00b5e21" title="Create a clone (i.e. " alt="" coords="1389,733,1551,775"/>
<area shape="rect" id="node35" href="namespacesouffle.html#a4a2b4fc7558b8bce98ff88f8e10b516e" title="Negate an ast constraint. " alt="" coords="1377,799,1563,826"/>
<area shape="rect" id="node33" href="classsouffle_1_1_ast_atom.html#acef18129b13ce45477044717ded051d2" title="souffle::AstAtom::AstAtom" alt="" coords="1642,617,1837,643"/>
<area shape="rect" id="node36" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="1633,799,1845,826"/>
</map>
</div>

</div>
</div>
<a id="a8ae2dc0fd43bd8abb26027c3f2f448d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae2dc0fd43bd8abb26027c3f2f448d1">&#9670;&nbsp;</a></span>getInlinedAtom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt;<a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a>*&gt; souffle::getInlinedAtom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> &amp;&#160;</td>
          <td class="paramname"><em>atom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of atoms that should replace the given atom after one step of inlining. </p>
<p>Assumes the relation the atom belongs to is not inlined itself. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00731">731</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00465">clone()</a>, <a class="el" href="_ast_literal_8h_source.html#l00078">souffle::AstAtom::getArguments()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00529">getInlinedArgument()</a>, <a class="el" href="_ast_literal_8h_source.html#l00058">souffle::AstAtom::getQualifiedName()</a>, <a class="el" href="_ast_node_8h_source.html#l00045">souffle::AstNode::getSrcLoc()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00057">souffle::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="json11_8h_source.html#l00651">i</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00053">souffle::NullableVector&lt; T &gt;::isValid()</a>, and <a class="el" href="html_js_chartist_min_8h_source.html#l00015">j</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00915">getInlinedClause()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00787">getInlinedLiteral()</a>.</p>
<div class="fragment"><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;                                                                            {</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;    std::vector&lt;AstAtom*&gt; versions;</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;    <span class="comment">// Try to inline each of the atom&#39;s arguments</span></div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;    std::vector&lt;AstArgument*&gt; arguments = atom.getArguments();</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; arguments.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;        AstArgument* arg = arguments[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;        NullableVector&lt;AstArgument*&gt; argumentVersions = <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, arg);</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;        <span class="keywordflow">if</span> (argumentVersions.isValid()) {</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;            <span class="comment">// Argument has replacements</span></div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;            changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;            <span class="comment">// Create a new atom per new version of the argument</span></div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;            <span class="keywordflow">for</span> (AstArgument* newArgument : argumentVersions.getVector()) {</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;                <span class="keyword">auto</span> args = atom.getArguments();</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;                std::vector&lt;std::unique_ptr&lt;AstArgument&gt;&gt; newArgs;</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> = 0; <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> &lt; args.size(); <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>++) {</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;                    <span class="keywordflow">if</span> (<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> == <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>) {</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;                        newArgs.emplace_back(newArgument);</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;                    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;                        newArgs.emplace_back(args[<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>]-&gt;<a class="code" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f">clone</a>());</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;                    }</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;                }</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;                <span class="keyword">auto</span>* newAtom = <span class="keyword">new</span> AstAtom(atom.getQualifiedName(), std::move(newArgs), atom.getSrcLoc());</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;                versions.push_back(newAtom);</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;            }</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;        }</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;        <span class="comment">// Only perform one stage of inlining at a time.</span></div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;        <span class="keywordflow">if</span> (changed) {</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;        }</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;    }</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;    <span class="keywordflow">if</span> (changed) {</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;        <span class="comment">// Return a valid vector - replacements need to be made!</span></div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;AstAtom*&gt;(versions);</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;        <span class="comment">// Return an invalid vector - no replacements need to be made</span></div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;AstAtom*&gt;();</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;    }</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a018886d19f141b1cb565199a517c598f"><div class="ttname"><a href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f">souffle::clone</a></div><div class="ttdeci">std::unique_ptr&lt; A &gt; clone(const A *node)</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00465">Util.h:465</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="namespacesouffle_html_aeddc699418d426e1ffcb965e37ccb3a2"><div class="ttname"><a href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">souffle::getInlinedArgument</a></div><div class="ttdeci">NullableVector&lt; AstArgument * &gt; getInlinedArgument(AstProgram &amp;program, const AstArgument *arg)</div><div class="ttdoc">Returns a vector of arguments that should replace the given argument after one step of inlining...</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00529">InlineRelationsTransformer.cpp:529</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_aab858032a95af802114b255fac6f45f2"><div class="ttname"><a href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a></div><div class="ttdeci">var j</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8ae2dc0fd43bd8abb26027c3f2f448d1_cgraph.png" border="0" usemap="#namespacesouffle_a8ae2dc0fd43bd8abb26027c3f2f448d1_cgraph" alt=""/></div>
<map name="namespacesouffle_a8ae2dc0fd43bd8abb26027c3f2f448d1_cgraph" id="namespacesouffle_a8ae2dc0fd43bd8abb26027c3f2f448d1_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="1574,99,1683,126"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="1513,853,1744,879"/>
<area shape="rect" id="node5" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2" title="Returns a vector of arguments that should replace the given argument after one step of inlining..." alt="" coords="228,394,431,421"/>
<area shape="rect" id="node19" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="1798,549,1998,575"/>
<area shape="rect" id="node25" href="classsouffle_1_1_nullable_vector.html#ab04c65c2ed18c2756c463c50de1912e8" title="souffle::NullableVector\l::isValid" alt="" coords="1296,336,1465,377"/>
<area shape="rect" id="node26" href="classsouffle_1_1_nullable_vector.html#ad94b793fbfe9e5d0175becd240539fbc" title="souffle::NullableVector\l::getVector" alt="" coords="1296,476,1465,517"/>
<area shape="rect" id="node36" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="992,890,1248,917"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1825,943,1971,970"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a42c2f399b871f8fe7f0ba652812e2db5" title="souffle::combineAggregators" alt="" coords="479,226,688,253"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1" title="Tries to perform a single step of inlining on the given literal. " alt="" coords="493,558,673,585"/>
<area shape="rect" id="node37" href="classsouffle_1_1_ast_aggregator.html#a427d81a0d8eb9c03d0ab86ef3ef78d5d" title="souffle::AstAggregator\l::setBody" alt="" coords="500,277,667,319"/>
<area shape="rect" id="node38" href="classsouffle_1_1_ast_node.html#a0b664297f0971c6ce32ff2e0e4f2603f" title="Set source location for the AstNode. " alt="" coords="484,343,683,370"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a1193e67992e4f0591e4011faccb4abe2" title="Checks whether a functor operation can have a given argument count. " alt="" coords="749,252,931,293"/>
<area shape="rect" id="node8" href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961" title="Renames all variables in a given argument uniquely. " alt="" coords="748,201,932,227"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_node.html#ad7c4f8ce0322749e72ed60f543c6fd93" title="Apply the mapper to all child nodes. " alt="" coords="1033,201,1207,227"/>
<area shape="rect" id="node11" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="1046,789,1194,815"/>
<area shape="rect" id="node14" href="classsouffle_1_1_ast_relation.html#a698481c4da3f71880cb2cf8c622a9cdc" title="check for a relation qualifier " alt="" coords="766,723,914,764"/>
<area shape="rect" id="node15" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="1047,839,1193,866"/>
<area shape="rect" id="node17" href="namespacesouffle.html#a7dfca9e9addfda4f3e1ee38cbef0d7c0" title="Inlines the given atom based on a given clause. " alt="" coords="1025,671,1215,698"/>
<area shape="rect" id="node28" href="namespacesouffle.html#a2e5ef82376f71d4d7ebfcfa64437d540" title="Forms the bodies that will replace the negation of a given inlined atom. " alt="" coords="736,671,944,698"/>
<area shape="rect" id="node12" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1329,890,1433,917"/>
<area shape="rect" id="node13" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="1553,969,1704,1011"/>
<area shape="rect" id="node16" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="1553,1035,1704,1076"/>
<area shape="rect" id="node18" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Create a clone (i.e. " alt="" coords="1311,541,1450,583"/>
<area shape="rect" id="node20" href="classsouffle_1_1_ast_clause.html#ab7a5b630d02cd69873aab066c2bd9c46" title="Apply the mapper to all child nodes. " alt="" coords="1311,672,1450,713"/>
<area shape="rect" id="node21" href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="1306,789,1455,815"/>
<area shape="rect" id="node24" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="1311,607,1450,648"/>
<area shape="rect" id="node27" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="1559,904,1698,945"/>
<area shape="rect" id="node22" href="namespacesouffle.html#a659ae2c89cfab47908f27a660f82c147" title="Reduces a vector of substitutions. " alt="" coords="1531,797,1727,823"/>
<area shape="rect" id="node23" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828" title="A generic factory for constraints of the form. " alt="" coords="1849,797,1947,823"/>
<area shape="rect" id="node29" href="namespacesouffle.html#a0e3e2145b6ac09dba3c7ba2e5535935f" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="1003,730,1237,757"/>
<area shape="rect" id="node30" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d" title="Returns the negated version of a given literal. " alt="" coords="1301,738,1461,765"/>
<area shape="rect" id="node31" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Create a clone (i.e. " alt="" coords="1542,614,1715,641"/>
<area shape="rect" id="node33" href="classsouffle_1_1_ast_constraint.html#a4bc070302396ff2bee073f62c00b5e21" title="Create a clone (i.e. " alt="" coords="1547,731,1710,772"/>
<area shape="rect" id="node34" href="namespacesouffle.html#a4a2b4fc7558b8bce98ff88f8e10b516e" title="Negate an ast constraint. " alt="" coords="1535,679,1722,706"/>
<area shape="rect" id="node32" href="classsouffle_1_1_ast_atom.html#acef18129b13ce45477044717ded051d2" title="souffle::AstAtom::AstAtom" alt="" coords="1801,614,1995,641"/>
<area shape="rect" id="node35" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="1792,679,2004,706"/>
</map>
</div>

</div>
</div>
<a id="ac4639aeb42a36253468c45df580e18bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4639aeb42a36253468c45df580e18bf">&#9670;&nbsp;</a></span>getInlinedClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a>*&gt; souffle::getInlinedClause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of clauses that should replace the given clause after one step of inlining. </p>
<p>If no inlining can occur, the list will only contain a clone of the original clause. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00915">915</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_clause_8h_source.html#l00151">souffle::AstClause::addToBody()</a>, <a class="el" href="_ast_clause_8h_source.html#l00190">souffle::AstClause::clone()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00179">cloneHead()</a>, <a class="el" href="_ast_clause_8h_source.html#l00171">souffle::AstClause::getBodyLiterals()</a>, <a class="el" href="_ast_clause_8h_source.html#l00166">souffle::AstClause::getHead()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00731">getInlinedAtom()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00787">getInlinedLiteral()</a>, <a class="el" href="_ast_node_8h_source.html#l00045">souffle::AstNode::getSrcLoc()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00057">souffle::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="json11_8h_source.html#l00651">i</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00053">souffle::NullableVector&lt; T &gt;::isValid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l01006">souffle::InlineRelationsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;                                                                                     {</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;    std::vector&lt;AstClause*&gt; versions;</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;    <span class="comment">// Try to inline things contained in the arguments of the head first.</span></div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;    <span class="comment">// E.g. `a(x, max y : { b(y) }) :- c(x).`, where b should be inlined.</span></div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;    AstAtom* head = clause.getHead();</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;    NullableVector&lt;AstAtom*&gt; headVersions = <a class="code" href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1">getInlinedAtom</a>(program, *head);</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;    <span class="keywordflow">if</span> (headVersions.isValid()) {</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;        <span class="comment">// The head atom can be inlined!</span></div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;        changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;        <span class="comment">// Produce the new clauses with the replacement head atoms</span></div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;        <span class="keywordflow">for</span> (AstAtom* newHead : headVersions.getVector()) {</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;            <span class="keyword">auto</span>* newClause = <span class="keyword">new</span> AstClause();</div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;            newClause-&gt;setSrcLoc(clause.getSrcLoc());</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;</div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;            newClause-&gt;setHead(std::unique_ptr&lt;AstAtom&gt;(newHead));</div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;            <span class="comment">// The body will remain unchanged</span></div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;            <span class="keywordflow">for</span> (AstLiteral* lit : clause.getBodyLiterals()) {</div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;                newClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(lit-&gt;clone()));</div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;            }</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;            versions.push_back(newClause);</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;        }</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;    }</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;</div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;    <span class="comment">// Only perform one stage of inlining at a time.</span></div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;    <span class="comment">// If the head atoms did not need inlining, try inlining atoms nested in the body.</span></div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;    <span class="keywordflow">if</span> (!changed) {</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;        std::vector&lt;AstLiteral*&gt; bodyLiterals = clause.getBodyLiterals();</div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; bodyLiterals.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;            AstLiteral* currLit = bodyLiterals[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;            <span class="comment">// Three possible cases when trying to inline a literal:</span></div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;            <span class="comment">//  1) The literal itself may be directly inlined. In this case, the atom can be replaced</span></div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;            <span class="comment">//    with multiple different bodies, as the inlined atom may have several rules.</span></div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;            <span class="comment">//  2) Otherwise, the literal itself may not need to be inlined, but a subnode (e.g. an argument)</span></div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;            <span class="comment">//    may need to be inlined. In this case, an altered literal must replace the original.</span></div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;            <span class="comment">//    Again, several possible versions may exist, as the inlined relation may have several rules.</span></div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;            <span class="comment">//  3) The literal does not depend on any inlined relations, and so does not need to be changed.</span></div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;            NullableVector&lt;std::vector&lt;AstLiteral*&gt;&gt; litVersions = <a class="code" href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1">getInlinedLiteral</a>(program, currLit);</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;            <span class="keywordflow">if</span> (litVersions.isValid()) {</div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;                <span class="comment">// Case 1 and 2: Inlining has occurred!</span></div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;                changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;</div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;                <span class="comment">// The literal may be replaced with several different bodies.</span></div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;                <span class="comment">// Create a new clause for each possible version.</span></div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;                std::vector&lt;std::vector&lt;AstLiteral*&gt;&gt; bodyVersions = litVersions.getVector();</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;                <span class="comment">// Create the base clause with the current literal removed</span></div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;                <span class="keyword">auto</span> baseClause = std::unique_ptr&lt;AstClause&gt;(<a class="code" href="namespacesouffle.html#a6aa6d61f4a71ddbb2458d23ce24dbced">cloneHead</a>(&amp;clause));</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;                <span class="keywordflow">for</span> (AstLiteral* oldLit : bodyLiterals) {</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;                    <span class="keywordflow">if</span> (currLit != oldLit) {</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;                        baseClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(oldLit-&gt;clone()));</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;                    }</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;                }</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;                <span class="keywordflow">for</span> (std::vector&lt;AstLiteral*&gt; body : bodyVersions) {</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;                    AstClause* replacementClause = baseClause-&gt;clone();</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;                    <span class="comment">// Add in the current set of literals replacing the inlined literal</span></div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;                    <span class="comment">// In Case 2, each body contains exactly one literal</span></div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;                    <span class="keywordflow">for</span> (AstLiteral* newLit : body) {</div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;                        replacementClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(newLit));</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;                    }</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;                    versions.push_back(replacementClause);</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;                }</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;            }</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;            <span class="comment">// Only replace at most one literal per iteration</span></div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;            <span class="keywordflow">if</span> (changed) {</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;            }</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;        }</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;    }</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;    <span class="keywordflow">if</span> (!changed) {</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;        <span class="comment">// Case 3: No inlining changes, so a clone of the original should be returned</span></div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;        std::vector&lt;AstClause*&gt; ret;</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;        ret.push_back(clause.clone());</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;        <span class="keywordflow">return</span> ret;</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;        <span class="comment">// Inlining changes, so return the replacement clauses.</span></div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;        <span class="keywordflow">return</span> versions;</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;    }</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8ae2dc0fd43bd8abb26027c3f2f448d1"><div class="ttname"><a href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1">souffle::getInlinedAtom</a></div><div class="ttdeci">NullableVector&lt; AstAtom * &gt; getInlinedAtom(AstProgram &amp;program, AstAtom &amp;atom)</div><div class="ttdoc">Returns a vector of atoms that should replace the given atom after one step of inlining. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00731">InlineRelationsTransformer.cpp:731</a></div></div>
<div class="ttc" id="namespacesouffle_html_a6aa6d61f4a71ddbb2458d23ce24dbced"><div class="ttname"><a href="namespacesouffle.html#a6aa6d61f4a71ddbb2458d23ce24dbced">souffle::cloneHead</a></div><div class="ttdeci">AstClause * cloneHead(const AstClause *clause)</div><div class="ttdoc">Returns a clause which contains head of the given clause. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00179">AstUtils.cpp:179</a></div></div>
<div class="ttc" id="namespacesouffle_html_a25b07f1c5efea50145140a31f755e0d1"><div class="ttname"><a href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1">souffle::getInlinedLiteral</a></div><div class="ttdeci">NullableVector&lt; std::vector&lt; AstLiteral * &gt; &gt; getInlinedLiteral(AstProgram &amp;, AstLiteral *)</div><div class="ttdoc">Tries to perform a single step of inlining on the given literal. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00787">InlineRelationsTransformer.cpp:787</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ac4639aeb42a36253468c45df580e18bf_cgraph.png" border="0" usemap="#namespacesouffle_ac4639aeb42a36253468c45df580e18bf_cgraph" alt=""/></div>
<map name="namespacesouffle_ac4639aeb42a36253468c45df580e18bf_cgraph" id="namespacesouffle_ac4639aeb42a36253468c45df580e18bf_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_clause.html#ac5e3416082d23734d1277daa5c9dee81" title="Add a Literal to the body of the clause. " alt="" coords="254,5,393,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Create a clone (i.e. " alt="" coords="1542,423,1681,464"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="2029,337,2229,363"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a6aa6d61f4a71ddbb2458d23ce24dbced" title="Returns a clause which contains head of the given clause. " alt="" coords="1540,169,1683,195"/>
<area shape="rect" id="node11" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="1790,305,1929,347"/>
<area shape="rect" id="node12" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="1542,1416,1681,1457"/>
<area shape="rect" id="node14" href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1" title="Returns a vector of atoms that should replace the given atom after one step of inlining. " alt="" coords="236,767,411,794"/>
<area shape="rect" id="node21" href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1" title="Tries to perform a single step of inlining on the given literal. " alt="" coords="724,945,904,971"/>
<area shape="rect" id="node33" href="classsouffle_1_1_nullable_vector.html#ab04c65c2ed18c2756c463c50de1912e8" title="souffle::NullableVector\l::isValid" alt="" coords="1527,571,1696,612"/>
<area shape="rect" id="node34" href="classsouffle_1_1_nullable_vector.html#ad94b793fbfe9e5d0175becd240539fbc" title="souffle::NullableVector\l::getVector" alt="" coords="1527,1076,1696,1117"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="1805,371,1914,398"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Create a clone (i.e. " alt="" coords="1773,717,1946,743"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_execution_plan.html#ac657ffa016ae777656585a56fc9a899c" title="Create a clone (i.e. " alt="" coords="1766,240,1953,281"/>
<area shape="rect" id="node10" href="classsouffle_1_1_ast_clause.html#aa943423c45971e70c837da5b88c8fc04" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="1788,123,1931,164"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_atom.html#acef18129b13ce45477044717ded051d2" title="souffle::AstAtom::AstAtom" alt="" coords="2031,717,2226,743"/>
<area shape="rect" id="node13" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="2055,1178,2202,1205"/>
<area shape="rect" id="node15" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="1744,1203,1975,1230"/>
<area shape="rect" id="node16" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2" title="Returns a vector of arguments that should replace the given argument after one step of inlining..." alt="" coords="459,709,661,735"/>
<area shape="rect" id="node41" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="1223,1206,1479,1233"/>
<area shape="rect" id="node17" href="namespacesouffle.html#a42c2f399b871f8fe7f0ba652812e2db5" title="souffle::combineAggregators" alt="" coords="709,650,919,677"/>
<area shape="rect" id="node42" href="classsouffle_1_1_ast_aggregator.html#a427d81a0d8eb9c03d0ab86ef3ef78d5d" title="souffle::AstAggregator\l::setBody" alt="" coords="731,701,897,743"/>
<area shape="rect" id="node43" href="classsouffle_1_1_ast_node.html#a0b664297f0971c6ce32ff2e0e4f2603f" title="Set source location for the AstNode. " alt="" coords="715,599,913,626"/>
<area shape="rect" id="node18" href="namespacesouffle.html#a1193e67992e4f0591e4011faccb4abe2" title="Checks whether a functor operation can have a given argument count. " alt="" coords="979,651,1162,692"/>
<area shape="rect" id="node19" href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961" title="Renames all variables in a given argument uniquely. " alt="" coords="979,599,1163,626"/>
<area shape="rect" id="node20" href="classsouffle_1_1_ast_node.html#ad7c4f8ce0322749e72ed60f543c6fd93" title="Apply the mapper to all child nodes. " alt="" coords="1264,599,1437,626"/>
<area shape="rect" id="node22" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="1277,818,1425,845"/>
<area shape="rect" id="node25" href="classsouffle_1_1_ast_relation.html#a698481c4da3f71880cb2cf8c622a9cdc" title="check for a relation qualifier " alt="" coords="997,1096,1145,1137"/>
<area shape="rect" id="node26" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="1277,1153,1424,1179"/>
<area shape="rect" id="node28" href="namespacesouffle.html#a7dfca9e9addfda4f3e1ee38cbef0d7c0" title="Inlines the given atom based on a given clause. " alt="" coords="1255,919,1446,946"/>
<area shape="rect" id="node35" href="namespacesouffle.html#a2e5ef82376f71d4d7ebfcfa64437d540" title="Forms the bodies that will replace the negation of a given inlined atom. " alt="" coords="967,970,1175,997"/>
<area shape="rect" id="node23" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1559,767,1663,794"/>
<area shape="rect" id="node24" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="1784,1073,1935,1115"/>
<area shape="rect" id="node27" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="1536,1145,1687,1187"/>
<area shape="rect" id="node29" href="classsouffle_1_1_ast_clause.html#ab7a5b630d02cd69873aab066c2bd9c46" title="Apply the mapper to all child nodes. " alt="" coords="1542,920,1681,961"/>
<area shape="rect" id="node30" href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="1537,998,1686,1025"/>
<area shape="rect" id="node31" href="namespacesouffle.html#a659ae2c89cfab47908f27a660f82c147" title="Reduces a vector of substitutions. " alt="" coords="1761,998,1957,1025"/>
<area shape="rect" id="node32" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828" title="A generic factory for constraints of the form. " alt="" coords="2080,998,2177,1025"/>
<area shape="rect" id="node36" href="namespacesouffle.html#a0e3e2145b6ac09dba3c7ba2e5535935f" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="1234,869,1467,895"/>
<area shape="rect" id="node37" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d" title="Returns the negated version of a given literal. " alt="" coords="1531,818,1691,845"/>
<area shape="rect" id="node38" href="classsouffle_1_1_ast_constraint.html#a4bc070302396ff2bee073f62c00b5e21" title="Create a clone (i.e. " alt="" coords="1778,844,1941,885"/>
<area shape="rect" id="node39" href="namespacesouffle.html#a4a2b4fc7558b8bce98ff88f8e10b516e" title="Negate an ast constraint. " alt="" coords="1766,793,1953,819"/>
<area shape="rect" id="node40" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="2023,793,2235,819"/>
</map>
</div>

</div>
</div>
<a id="a25b07f1c5efea50145140a31f755e0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b07f1c5efea50145140a31f755e0d1">&#9670;&nbsp;</a></span>getInlinedLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt; std::vector&lt; <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> * &gt; &gt; souffle::getInlinedLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *&#160;</td>
          <td class="paramname"><em>lit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to perform a single step of inlining on the given literal. </p>
<p>Returns a pair of nullable vectors (v, w) such that:</p><ul>
<li>v is valid if and only if the literal can be directly inlined, whereby it contains the bodies that replace it</li>
<li>if v is not valid, then w is valid if and only if the literal cannot be inlined directly, but contains a subargument that can be. In this case, it will contain the versions that will replace it.</li>
<li>If both are invalid, then no more inlining can occur on this literal and we are done. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00787">787</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00422">formNegatedLiterals()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00042">getClauses()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00529">getInlinedArgument()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00731">getInlinedAtom()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00056">getRelation()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00057">souffle::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="_ast_relation_8h_source.html#l00103">souffle::AstRelation::hasQualifier()</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">INLINE</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00281">inlineBodyLiterals()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00053">souffle::NullableVector&lt; T &gt;::isValid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00529">getInlinedArgument()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00915">getInlinedClause()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00057">souffle::NullableVector&lt; T &gt;::getVector()</a>.</p>
<div class="fragment"><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;                                                                                               {</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;    <span class="keywordtype">bool</span> inlined = <span class="keyword">false</span>;</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;    std::vector&lt;std::vector&lt;AstLiteral*&gt;&gt; addedBodyLiterals;</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;    std::vector&lt;AstLiteral*&gt; versions;</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span>* atom = dynamic_cast&lt;AstAtom*&gt;(lit)) {</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;        <span class="comment">// Check if this atom is meant to be inlined</span></div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;        AstRelation* rel = <a class="code" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">getRelation</a>(program, atom-&gt;getQualifiedName());</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;        <span class="keywordflow">if</span> (rel-&gt;hasQualifier(RelationQualifier::INLINE)) {</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;            <span class="comment">// We found an atom in the clause that needs to be inlined!</span></div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;            <span class="comment">// The clause needs to be replaced</span></div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;            inlined = <span class="keyword">true</span>;</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;            <span class="comment">// N new clauses should be formed, where N is the number of clauses</span></div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;            <span class="comment">// associated with the inlined relation</span></div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;            <span class="keywordflow">for</span> (AstClause* inClause : <a class="code" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">getClauses</a>(program, *rel)) {</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;                <span class="comment">// Form the replacement clause</span></div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;                std::pair&lt;NullableVector&lt;AstLiteral*&gt;, std::vector&lt;AstBinaryConstraint*&gt;&gt; inlineResult =</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;                        <a class="code" href="namespacesouffle.html#a7dfca9e9addfda4f3e1ee38cbef0d7c0">inlineBodyLiterals</a>(atom, inClause);</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;                NullableVector&lt;AstLiteral*&gt; replacementBodyLiterals = inlineResult.first;</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;                std::vector&lt;AstBinaryConstraint*&gt; currConstraints = inlineResult.second;</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;                <span class="keywordflow">if</span> (!replacementBodyLiterals.isValid()) {</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;                    <span class="comment">// Failed to unify the atoms! We can skip this one...</span></div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;                }</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;                <span class="comment">// Unification successful - the returned vector of literals represents one possible body</span></div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;                <span class="comment">// replacement We can add in the unification constraints as part of these literals.</span></div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;                std::vector&lt;AstLiteral*&gt; bodyResult = replacementBodyLiterals.getVector();</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;                <span class="keywordflow">for</span> (AstBinaryConstraint* cons : currConstraints) {</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;                    bodyResult.push_back(cons);</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;                }</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;                addedBodyLiterals.push_back(bodyResult);</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;            }</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;            <span class="comment">// Not meant to be inlined, but a subargument may be</span></div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;            NullableVector&lt;AstAtom*&gt; atomVersions = <a class="code" href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1">getInlinedAtom</a>(program, *atom);</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;            <span class="keywordflow">if</span> (atomVersions.isValid()) {</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;                <span class="comment">// Subnode needs to be inlined, so we have a vector of replacement atoms</span></div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;                changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;                <span class="keywordflow">for</span> (AstAtom* newAtom : atomVersions.getVector()) {</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;                    versions.push_back(newAtom);</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;                }</div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;            }</div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;        }</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span> neg = dynamic_cast&lt;AstNegation*&gt;(lit)) {</div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;        <span class="comment">// For negations, check the corresponding atom</span></div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;        AstAtom* atom = neg-&gt;getAtom();</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;        NullableVector&lt;std::vector&lt;AstLiteral*&gt;&gt; atomVersions = <a class="code" href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1">getInlinedLiteral</a>(program, atom);</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;</div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;        <span class="keywordflow">if</span> (atomVersions.isValid()) {</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;            <span class="comment">// The atom can be inlined</span></div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;            inlined = <span class="keyword">true</span>;</div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;            <span class="keywordflow">if</span> (atomVersions.getVector().empty()) {</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;                <span class="comment">// No clauses associated with the atom, so just becomes a true literal</span></div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;                addedBodyLiterals.push_back({<span class="keyword">new</span> AstBooleanConstraint(<span class="keyword">true</span>)});</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;                <span class="comment">// Suppose an atom a(x) is inlined and has the following rules:</span></div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;                <span class="comment">//  - a(x) :- a11(x), a12(x).</span></div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;                <span class="comment">//  - a(x) :- a21(x), a22(x).</span></div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;                <span class="comment">// Then, a(x) &lt;- (a11(x) ^ a12(x)) v (a21(x) ^ a22(x))</span></div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;                <span class="comment">//  =&gt; !a(x) &lt;- (!a11(x) v !a12(x)) ^ (!a21(x) v !a22(x))</span></div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;                <span class="comment">//  =&gt; !a(x) &lt;- (!a11(x) ^ !a21(x)) v (!a11(x) ^ !a22(x)) v ...</span></div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;                <span class="comment">// Essentially, produce every combination (m_1 ^ m_2 ^ ...) where m_i is a</span></div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;                <span class="comment">// negated literal in the ith rule of a.</span></div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;                addedBodyLiterals = <a class="code" href="namespacesouffle.html#a2e5ef82376f71d4d7ebfcfa64437d540">formNegatedLiterals</a>(program, atom);</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;            }</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;        }</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;        <span class="keywordflow">if</span> (atomVersions.isValid()) {</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; curVec : atomVersions.getVector()) {</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span>* cur : curVec) {</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;                    <span class="keyword">delete</span> cur;</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;                }</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;            }</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;        }</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span>* constraint = dynamic_cast&lt;AstBinaryConstraint*&gt;(lit)) {</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;        NullableVector&lt;AstArgument*&gt; lhsVersions = <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, constraint-&gt;getLHS());</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;        <span class="keywordflow">if</span> (lhsVersions.isValid()) {</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;            changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;            <span class="keywordflow">for</span> (AstArgument* newLhs : lhsVersions.getVector()) {</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;                AstLiteral* newLit = <span class="keyword">new</span> AstBinaryConstraint(constraint-&gt;getOperator(),</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;                        std::unique_ptr&lt;AstArgument&gt;(newLhs),</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;                        std::unique_ptr&lt;AstArgument&gt;(constraint-&gt;getRHS()-&gt;clone()));</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;                versions.push_back(newLit);</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;            }</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;            NullableVector&lt;AstArgument*&gt; rhsVersions = <a class="code" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">getInlinedArgument</a>(program, constraint-&gt;getRHS());</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;            <span class="keywordflow">if</span> (rhsVersions.isValid()) {</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;                changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;                <span class="keywordflow">for</span> (AstArgument* newRhs : rhsVersions.getVector()) {</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;                    AstLiteral* newLit = <span class="keyword">new</span> AstBinaryConstraint(constraint-&gt;getOperator(),</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;                            std::unique_ptr&lt;AstArgument&gt;(constraint-&gt;getLHS()-&gt;clone()),</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;                            std::unique_ptr&lt;AstArgument&gt;(newRhs));</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;                    versions.push_back(newLit);</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;                }</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;            }</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;        }</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;    }</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;    <span class="keywordflow">if</span> (changed) {</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;        <span class="comment">// Not inlined directly but found replacement literals</span></div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;        <span class="comment">// Rewrite these as single-literal bodies</span></div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;        <span class="keywordflow">for</span> (AstLiteral* version : versions) {</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;            std::vector&lt;AstLiteral*&gt; newBody;</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;            newBody.push_back(version);</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;            addedBodyLiterals.push_back(newBody);</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;        }</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;        inlined = <span class="keyword">true</span>;</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;    }</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;    <span class="keywordflow">if</span> (inlined) {</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;std::vector&lt;AstLiteral*&gt;&gt;(addedBodyLiterals);</div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;std::vector&lt;AstLiteral*&gt;&gt;();</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;    }</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a7dfca9e9addfda4f3e1ee38cbef0d7c0"><div class="ttname"><a href="namespacesouffle.html#a7dfca9e9addfda4f3e1ee38cbef0d7c0">souffle::inlineBodyLiterals</a></div><div class="ttdeci">std::pair&lt; NullableVector&lt; AstLiteral * &gt;, std::vector&lt; AstBinaryConstraint * &gt; &gt; inlineBodyLiterals(AstAtom *atom, AstClause *atomInlineClause)</div><div class="ttdoc">Inlines the given atom based on a given clause. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00281">InlineRelationsTransformer.cpp:281</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2e5ef82376f71d4d7ebfcfa64437d540"><div class="ttname"><a href="namespacesouffle.html#a2e5ef82376f71d4d7ebfcfa64437d540">souffle::formNegatedLiterals</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; AstLiteral * &gt; &gt; formNegatedLiterals(AstProgram &amp;program, AstAtom *atom)</div><div class="ttdoc">Forms the bodies that will replace the negation of a given inlined atom. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00422">InlineRelationsTransformer.cpp:422</a></div></div>
<div class="ttc" id="namespacesouffle_html_ada252aa15afbf7d703a11b000dfd4048"><div class="ttname"><a href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">souffle::getRelation</a></div><div class="ttdeci">AstRelation * getRelation(const AstProgram &amp;program, const AstQualifiedName &amp;name)</div><div class="ttdoc">Returns the relation with the given name in the program. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00056">AstUtils.cpp:56</a></div></div>
<div class="ttc" id="namespacesouffle_html_aeddc699418d426e1ffcb965e37ccb3a2"><div class="ttname"><a href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2">souffle::getInlinedArgument</a></div><div class="ttdeci">NullableVector&lt; AstArgument * &gt; getInlinedArgument(AstProgram &amp;program, const AstArgument *arg)</div><div class="ttdoc">Returns a vector of arguments that should replace the given argument after one step of inlining...</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00529">InlineRelationsTransformer.cpp:529</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8ae2dc0fd43bd8abb26027c3f2f448d1"><div class="ttname"><a href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1">souffle::getInlinedAtom</a></div><div class="ttdeci">NullableVector&lt; AstAtom * &gt; getInlinedAtom(AstProgram &amp;program, AstAtom &amp;atom)</div><div class="ttdoc">Returns a vector of atoms that should replace the given atom after one step of inlining. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00731">InlineRelationsTransformer.cpp:731</a></div></div>
<div class="ttc" id="namespacesouffle_html_a25b07f1c5efea50145140a31f755e0d1"><div class="ttname"><a href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1">souffle::getInlinedLiteral</a></div><div class="ttdeci">NullableVector&lt; std::vector&lt; AstLiteral * &gt; &gt; getInlinedLiteral(AstProgram &amp;, AstLiteral *)</div><div class="ttdoc">Tries to perform a single step of inlining on the given literal. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00787">InlineRelationsTransformer.cpp:787</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4d9e53888640a9abfd7ea7c43715152a"><div class="ttname"><a href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">souffle::getClauses</a></div><div class="ttdeci">std::vector&lt; AstClause * &gt; getClauses(const AstProgram &amp;program, const AstQualifiedName &amp;relationName)</div><div class="ttdoc">Returns a vector of clauses in the program describing the relation with the given name...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00042">AstUtils.cpp:42</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a25b07f1c5efea50145140a31f755e0d1_cgraph.png" border="0" usemap="#namespacesouffle_a25b07f1c5efea50145140a31f755e0d1_cgraph" alt=""/></div>
<map name="namespacesouffle_a25b07f1c5efea50145140a31f755e0d1_cgraph" id="namespacesouffle_a25b07f1c5efea50145140a31f755e0d1_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a2e5ef82376f71d4d7ebfcfa64437d540" title="Forms the bodies that will replace the negation of a given inlined atom. " alt="" coords="233,339,441,366"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="544,45,691,71"/>
<area shape="rect" id="node15" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="543,95,691,122"/>
<area shape="rect" id="node18" href="classsouffle_1_1_nullable_vector.html#ad94b793fbfe9e5d0175becd240539fbc" title="souffle::NullableVector\l::getVector" alt="" coords="813,548,983,589"/>
<area shape="rect" id="node19" href="namespacesouffle.html#a7dfca9e9addfda4f3e1ee38cbef0d7c0" title="Inlines the given atom based on a given clause. " alt="" coords="522,250,713,277"/>
<area shape="rect" id="node28" href="classsouffle_1_1_nullable_vector.html#ab04c65c2ed18c2756c463c50de1912e8" title="souffle::NullableVector\l::isValid" alt="" coords="813,613,983,655"/>
<area shape="rect" id="node30" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2" title="Returns a vector of arguments that should replace the given argument after one step of inlining..." alt="" coords="516,831,719,858"/>
<area shape="rect" id="node37" href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1" title="Returns a vector of atoms that should replace the given atom after one step of inlining. " alt="" coords="250,603,425,630"/>
<area shape="rect" id="node38" href="classsouffle_1_1_ast_relation.html#a698481c4da3f71880cb2cf8c622a9cdc" title="check for a relation qualifier " alt="" coords="263,895,411,936"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a0e3e2145b6ac09dba3c7ba2e5535935f" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="501,301,734,327"/>
<area shape="rect" id="node14" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="489,527,745,554"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d" title="Returns the negated version of a given literal. " alt="" coords="818,431,978,458"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Create a clone (i.e. " alt="" coords="1079,519,1253,546"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_constraint.html#a4bc070302396ff2bee073f62c00b5e21" title="Create a clone (i.e. " alt="" coords="1085,453,1247,495"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a4a2b4fc7558b8bce98ff88f8e10b516e" title="Negate an ast constraint. " alt="" coords="1073,402,1259,429"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_atom.html#acef18129b13ce45477044717ded051d2" title="souffle::AstAtom::AstAtom" alt="" coords="1338,519,1533,546"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="1335,570,1535,597"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="1329,402,1541,429"/>
<area shape="rect" id="node12" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="1091,5,1241,47"/>
<area shape="rect" id="node13" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1362,129,1509,155"/>
<area shape="rect" id="node16" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="846,45,950,71"/>
<area shape="rect" id="node17" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="1091,88,1241,129"/>
<area shape="rect" id="node20" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Create a clone (i.e. " alt="" coords="829,483,967,524"/>
<area shape="rect" id="node22" href="classsouffle_1_1_ast_clause.html#ab7a5b630d02cd69873aab066c2bd9c46" title="Apply the mapper to all child nodes. " alt="" coords="829,197,967,239"/>
<area shape="rect" id="node23" href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="823,381,973,407"/>
<area shape="rect" id="node27" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="829,315,967,356"/>
<area shape="rect" id="node29" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="1097,153,1235,195"/>
<area shape="rect" id="node21" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="1111,730,1221,757"/>
<area shape="rect" id="node24" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="1051,219,1281,246"/>
<area shape="rect" id="node25" href="namespacesouffle.html#a659ae2c89cfab47908f27a660f82c147" title="Reduces a vector of substitutions. " alt="" coords="1068,351,1264,378"/>
<area shape="rect" id="node26" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828" title="A generic factory for constraints of the form. " alt="" coords="1387,351,1484,378"/>
<area shape="rect" id="node31" href="namespacesouffle.html#a42c2f399b871f8fe7f0ba652812e2db5" title="souffle::combineAggregators" alt="" coords="793,831,1003,858"/>
<area shape="rect" id="node35" href="classsouffle_1_1_ast_aggregator.html#a427d81a0d8eb9c03d0ab86ef3ef78d5d" title="souffle::AstAggregator\l::setBody" alt="" coords="815,883,981,924"/>
<area shape="rect" id="node36" href="classsouffle_1_1_ast_node.html#a0b664297f0971c6ce32ff2e0e4f2603f" title="Set source location for the AstNode. " alt="" coords="799,949,997,975"/>
<area shape="rect" id="node32" href="namespacesouffle.html#a1193e67992e4f0591e4011faccb4abe2" title="Checks whether a functor operation can have a given argument count. " alt="" coords="1075,857,1257,899"/>
<area shape="rect" id="node33" href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961" title="Renames all variables in a given argument uniquely. " alt="" coords="1074,806,1258,833"/>
<area shape="rect" id="node34" href="classsouffle_1_1_ast_node.html#ad7c4f8ce0322749e72ed60f543c6fd93" title="Apply the mapper to all child nodes. " alt="" coords="1349,806,1522,833"/>
</map>
</div>

</div>
</div>
<a id="a7814a3034094392e5744454c68463cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7814a3034094392e5744454c68463cc5">&#9670;&nbsp;</a></span>getInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_souffle_program.html">souffle::SouffleProgram</a>* souffle::getInstance </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_compiled_souffle_8h_source.html#l00060">60</a> of file <a class="el" href="_compiled_souffle_8h_source.html">CompiledSouffle.h</a>.</p>

<p class="reference">References <a class="el" href="classsouffle_1_1_program_factory.html#aeeb8c8fa86018f5f19cf6d419acdec54">souffle::ProgramFactory::newInstance()</a>.</p>
<div class="fragment"><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                                                         {</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1_program_factory.html#aeeb8c8fa86018f5f19cf6d419acdec54">souffle::ProgramFactory::newInstance</a>(<a class="code" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>);</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;}</div><div class="ttc" id="classsouffle_1_1_program_factory_html_aeeb8c8fa86018f5f19cf6d419acdec54"><div class="ttname"><a href="classsouffle_1_1_program_factory.html#aeeb8c8fa86018f5f19cf6d419acdec54">souffle::ProgramFactory::newInstance</a></div><div class="ttdeci">virtual SouffleProgram * newInstance()=0</div><div class="ttdoc">Create new instance (abstract). </div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_a0e2839cf85d4f50ed7cdcc6c1b3adf83"><div class="ttname"><a href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a></div><div class="ttdeci">a horizontalBars(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})):a.axisX.type.call(c, c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})), l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y, b.normalized.series, o,{ticks:k}):a.axisY.type.call(c, c.Axis.units.y, b.normalized.series, o, a.axisY)) var p</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a7814a3034094392e5744454c68463cc5_cgraph.png" border="0" usemap="#namespacesouffle_a7814a3034094392e5744454c68463cc5_cgraph" alt=""/></div>
<map name="namespacesouffle_a7814a3034094392e5744454c68463cc5_cgraph" id="namespacesouffle_a7814a3034094392e5744454c68463cc5_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_program_factory.html#aeeb8c8fa86018f5f19cf6d419acdec54" title="Create new instance (abstract). " alt="" coords="204,5,380,47"/>
</map>
</div>

</div>
</div>
<a id="a8aecaefb22443dc01bb4c208cb6aabdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aecaefb22443dc01bb4c208cb6aabdf">&#9670;&nbsp;</a></span>getLeastCommonSupertypes() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> souffle::getLeastCommonSupertypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the least common super types of the two given types. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00446">446</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l01010">any_of()</a>, <a class="el" href="_type_system_8cpp_source.html#l00100">souffle::TypeEnvironment::getAllTypes()</a>, <a class="el" href="_type_system_8h_source.html#l00051">souffle::Type::getTypeEnvironment()</a>, <a class="el" href="_type_system_8h_source.html#l00229">souffle::TypeSet::insert()</a>, <a class="el" href="_type_system_8cpp_source.html#l00401">isSubtypeOf()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00081">souffle::TypeEnvironment::isType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_type_system_8cpp_source.html#l00484">getLeastCommonSupertypes()</a>, and <a class="el" href="_type_system_8h_source.html#l00513">isOrderableType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;                                                               {</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    <span class="comment">// make sure they are in the same type environment</span></div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    assert(a.getTypeEnvironment().isType(a) &amp;&amp; a.getTypeEnvironment().isType(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>));</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    <span class="comment">// if they are equal it is easy</span></div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    <span class="keywordflow">if</span> (a == <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>) {</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;        <span class="keywordflow">return</span> TypeSet(a);</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    }</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    <span class="comment">// equally simple - check whether one is a sub-type of the other</span></div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(a, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)) {</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;        <span class="keywordflow">return</span> TypeSet(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>);</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    }</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, a)) {</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;        <span class="keywordflow">return</span> TypeSet(a);</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    }</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    <span class="comment">// harder: no obvious relation =&gt; hard way</span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    TypeSet superTypes;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    TypeSet all = a.getTypeEnvironment().getAllTypes();</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; cur : all) {</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(a, cur) &amp;&amp; <a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, cur)) {</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;            superTypes.insert(cur);</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        }</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    }</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    <span class="comment">// filter out non-least super types</span></div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    TypeSet res;</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; cur : superTypes) {</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;        <span class="keywordtype">bool</span> least = !<a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(superTypes, [&amp;](<span class="keyword">const</span> Type&amp; t) { <span class="keywordflow">return</span> t != cur &amp;&amp; <a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(t, cur); });</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;        <span class="keywordflow">if</span> (least) {</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;            res.insert(cur);</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;        }</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    }</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    <span class="keywordflow">return</span> res;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a34f8eecb81c090fca9e58d3357b63ed9"><div class="ttname"><a href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">souffle::any_of</a></div><div class="ttdeci">bool any_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether any elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01010">Util.h:1010</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8cc19c66d9d13ce64e65f14dcabb43b3"><div class="ttname"><a href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">souffle::isSubtypeOf</a></div><div class="ttdeci">bool isSubtypeOf(const Type &amp;a, const Type &amp;b)</div><div class="ttdoc">Determines whether type a is a subtype of type b. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00401">TypeSystem.cpp:401</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8aecaefb22443dc01bb4c208cb6aabdf_cgraph.png" border="0" usemap="#namespacesouffle_a8aecaefb22443dc01bb4c208cb6aabdf_cgraph" alt=""/></div>
<map name="namespacesouffle_a8aecaefb22443dc01bb4c208cb6aabdf_cgraph" id="namespacesouffle_a8aecaefb22443dc01bb4c208cb6aabdf_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="350,56,469,83"/>
<area shape="rect" id="node3" href="classsouffle_1_1_type_environment.html#af9544bc93704955f168a0803f583ae19" title="souffle::TypeEnvironment\l::getAllTypes" alt="" coords="316,158,503,199"/>
<area shape="rect" id="node4" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="559,5,729,32"/>
<area shape="rect" id="node5" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="785,300,1032,327"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="333,224,486,251"/>
<area shape="rect" id="node7" href="classsouffle_1_1_type_environment.html#a5ead83575e9abfebb3a0b180a33a7d96" title="souffle::TypeEnvironment\l::isType" alt="" coords="551,377,737,418"/>
<area shape="rect" id="node8" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="815,207,1002,249"/>
<area shape="rect" id="node13" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="561,275,727,301"/>
<area shape="rect" id="node14" href="classsouffle_1_1_type_environment.html#a72fa419d33bf813f22efabec629a4627" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="815,142,1002,183"/>
<area shape="rect" id="node15" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="562,224,726,251"/>
<area shape="rect" id="node16" href="classsouffle_1_1_subset_type.html#ac5c52e503cbce42370d6ada3f050773d" title="souffle::SubsetType\l::getBaseType" alt="" coords="570,57,718,98"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="1080,183,1205,209"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1277,153,1381,180"/>
<area shape="rect" id="node11" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="1253,205,1404,246"/>
<area shape="rect" id="node12" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1452,212,1599,239"/>
</map>
</div>

</div>
</div>
<a id="a3e40a76eef0a150ef9c20743b95f589e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e40a76eef0a150ef9c20743b95f589e">&#9670;&nbsp;</a></span>getLeastCommonSupertypes() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> souffle::getLeastCommonSupertypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the least common super types of all the types in the given set. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00484">484</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_type_system_8h_source.html#l00274">souffle::TypeSet::begin()</a>, <a class="el" href="_type_system_8cpp_source.html#l00446">getLeastCommonSupertypes()</a>, and <a class="el" href="_type_system_8h_source.html#l00229">souffle::TypeSet::insert()</a>.</p>
<div class="fragment"><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;                                                     {</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    <span class="comment">// handle the empty set</span></div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">set</span>.empty()) {</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">set</span>;</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    }</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    <span class="comment">// handle the all set =&gt; empty set (since no common super-type)</span></div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">set</span>.isAll()) {</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        <span class="keywordflow">return</span> TypeSet();</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    }</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;    TypeSet res;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    <span class="keyword">auto</span> it = <span class="keyword">set</span>.begin();</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;    res.insert(*it);</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    ++it;</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    <span class="comment">// refine sub-set step by step</span></div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    <span class="keywordflow">for</span> (; it != <span class="keyword">set</span>.end(); ++it) {</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;        TypeSet tmp;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; cur : res) {</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;            tmp.insert(<a class="code" href="namespacesouffle.html#a8e5fe6f4fe0781dfc619f8640a1631d3">getLeastCommonSupertypes</a>(cur, *it));</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        }</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        res = tmp;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;    }</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    <span class="comment">// done</span></div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    <span class="keywordflow">return</span> res;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a8e5fe6f4fe0781dfc619f8640a1631d3"><div class="ttname"><a href="namespacesouffle.html#a8e5fe6f4fe0781dfc619f8640a1631d3">souffle::getLeastCommonSupertypes</a></div><div class="ttdeci">TypeSet getLeastCommonSupertypes(const TypeSet &amp;a, const TypeSet &amp;b)</div><div class="ttdoc">The set of pair-wise least common super types of the types in the two given sets. ...</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00514">TypeSystem.cpp:514</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a3e40a76eef0a150ef9c20743b95f589e_cgraph.png" border="0" usemap="#namespacesouffle_a3e40a76eef0a150ef9c20743b95f589e_cgraph" alt=""/></div>
<map name="namespacesouffle_a3e40a76eef0a150ef9c20743b95f589e_cgraph" id="namespacesouffle_a3e40a76eef0a150ef9c20743b95f589e_cgraph">
<area shape="rect" id="node2" href="structsouffle_1_1_type_set.html#a6a55651b4f3aafc2dd60280ed38e1918" title="Allows to iterate over the types contained in this set (only if not universal) " alt="" coords="363,5,532,32"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a8aecaefb22443dc01bb4c208cb6aabdf" title="Computes the least common super types of the two given types. " alt="" coords="316,216,579,243"/>
<area shape="rect" id="node7" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="869,107,1040,133"/>
<area shape="rect" id="node3" href="namespacesouffle.html#aeb411c7585f438a75ef3de5b6ae2abc5" title="A factory function enabling the construction of a dereferencing iterator utilizing the automated dedu..." alt="" coords="655,5,785,32"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="661,157,779,184"/>
<area shape="rect" id="node6" href="classsouffle_1_1_type_environment.html#af9544bc93704955f168a0803f583ae19" title="souffle::TypeEnvironment\l::getAllTypes" alt="" coords="627,209,813,250"/>
<area shape="rect" id="node8" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="1096,329,1343,356"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="643,325,797,352"/>
<area shape="rect" id="node10" href="classsouffle_1_1_type_environment.html#a5ead83575e9abfebb3a0b180a33a7d96" title="souffle::TypeEnvironment\l::isType" alt="" coords="861,158,1048,199"/>
<area shape="rect" id="node11" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="1126,381,1313,422"/>
<area shape="rect" id="node16" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="871,376,1038,403"/>
<area shape="rect" id="node17" href="classsouffle_1_1_type_environment.html#a72fa419d33bf813f22efabec629a4627" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="1126,263,1313,305"/>
<area shape="rect" id="node18" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="873,275,1037,301"/>
<area shape="rect" id="node19" href="classsouffle_1_1_subset_type.html#ac5c52e503cbce42370d6ada3f050773d" title="souffle::SubsetType\l::getBaseType" alt="" coords="881,478,1029,519"/>
<area shape="rect" id="node12" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="1391,329,1516,356"/>
<area shape="rect" id="node13" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1587,300,1691,327"/>
<area shape="rect" id="node14" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="1564,351,1715,393"/>
<area shape="rect" id="node15" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1763,359,1909,385"/>
</map>
</div>

</div>
</div>
<a id="a8e5fe6f4fe0781dfc619f8640a1631d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5fe6f4fe0781dfc619f8640a1631d3">&#9670;&nbsp;</a></span>getLeastCommonSupertypes() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> souffle::getLeastCommonSupertypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The set of pair-wise least common super types of the types in the two given sets. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00514">514</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="html_js_chartist_min_8h_source.html#l00015">b</a>, <a class="el" href="_type_system_8h_source.html#l00208">souffle::TypeSet::empty()</a>, <a class="el" href="_type_system_8cpp_source.html#l00446">getLeastCommonSupertypes()</a>, <a class="el" href="_type_system_8h_source.html#l00229">souffle::TypeSet::insert()</a>, and <a class="el" href="_type_system_8h_source.html#l00213">souffle::TypeSet::isAll()</a>.</p>
<div class="fragment"><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;                                                                     {</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    <span class="comment">// special cases</span></div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;    <span class="keywordflow">if</span> (a.empty()) {</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;        <span class="keywordflow">return</span> a;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;    }</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>.empty()) {</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    }</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    <span class="keywordflow">if</span> (a.isAll()) {</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>;</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    }</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>.isAll()) {</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;        <span class="keywordflow">return</span> a;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    }</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    <span class="comment">// compute pairwise least common super types</span></div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;    TypeSet res;</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; x : a) {</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> Type&amp; y : <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>) {</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;            res.insert(<a class="code" href="namespacesouffle.html#a8e5fe6f4fe0781dfc619f8640a1631d3">getLeastCommonSupertypes</a>(x, y));</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;        }</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;    }</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;    <span class="keywordflow">return</span> res;</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8e5fe6f4fe0781dfc619f8640a1631d3"><div class="ttname"><a href="namespacesouffle.html#a8e5fe6f4fe0781dfc619f8640a1631d3">souffle::getLeastCommonSupertypes</a></div><div class="ttdeci">TypeSet getLeastCommonSupertypes(const TypeSet &amp;a, const TypeSet &amp;b)</div><div class="ttdoc">The set of pair-wise least common super types of the types in the two given sets. ...</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00514">TypeSystem.cpp:514</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8e5fe6f4fe0781dfc619f8640a1631d3_cgraph.png" border="0" usemap="#namespacesouffle_a8e5fe6f4fe0781dfc619f8640a1631d3_cgraph" alt=""/></div>
<map name="namespacesouffle_a8e5fe6f4fe0781dfc619f8640a1631d3_cgraph" id="namespacesouffle_a8e5fe6f4fe0781dfc619f8640a1631d3_cgraph">
<area shape="rect" id="node2" href="structsouffle_1_1_type_set.html#a2110dea550ae2c1eaf6ef65e2854f925" title="Emptiness check. " alt="" coords="360,5,535,32"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a8aecaefb22443dc01bb4c208cb6aabdf" title="Computes the least common super types of the two given types. " alt="" coords="316,199,579,225"/>
<area shape="rect" id="node6" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="869,112,1040,139"/>
<area shape="rect" id="node19" href="structsouffle_1_1_type_set.html#ae26622401685d8ac9080b2f5a83d7eaa" title="Universality check. " alt="" coords="367,249,528,276"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="661,275,779,301"/>
<area shape="rect" id="node5" href="classsouffle_1_1_type_environment.html#af9544bc93704955f168a0803f583ae19" title="souffle::TypeEnvironment\l::getAllTypes" alt="" coords="627,107,813,149"/>
<area shape="rect" id="node7" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="1096,335,1343,361"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="643,329,797,356"/>
<area shape="rect" id="node9" href="classsouffle_1_1_type_environment.html#a5ead83575e9abfebb3a0b180a33a7d96" title="souffle::TypeEnvironment\l::isType" alt="" coords="861,163,1048,205"/>
<area shape="rect" id="node10" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="1126,269,1313,310"/>
<area shape="rect" id="node15" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="871,280,1038,307"/>
<area shape="rect" id="node16" href="classsouffle_1_1_type_environment.html#a72fa419d33bf813f22efabec629a4627" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="1126,386,1313,427"/>
<area shape="rect" id="node17" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="873,381,1037,408"/>
<area shape="rect" id="node18" href="classsouffle_1_1_subset_type.html#ac5c52e503cbce42370d6ada3f050773d" title="souffle::SubsetType\l::getBaseType" alt="" coords="881,483,1029,525"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="1391,335,1516,361"/>
<area shape="rect" id="node12" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1587,305,1691,332"/>
<area shape="rect" id="node13" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="1564,357,1715,398"/>
<area shape="rect" id="node14" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1763,364,1909,391"/>
</map>
</div>

</div>
</div>
<a id="a172efe6c434b6ded80903a16f2535cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172efe6c434b6ded80903a16f2535cae">&#9670;&nbsp;</a></span>getLeastCommonSupertypes() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> souffle::getLeastCommonSupertypes </td>
          <td>(</td>
          <td class="paramtype">const Types &amp;...&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the least common super types of the given types. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8h_source.html#l00618">618</a> of file <a class="el" href="_type_system_8h_source.html">TypeSystem.h</a>.</p>

<p class="reference">References <a class="el" href="_type_system_8cpp_source.html#l00540">getGreatestCommonSubtypes()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00446">getLeastCommonSupertypes()</a>.</p>
<div class="fragment"><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;                                                        {</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a172efe6c434b6ded80903a16f2535cae">getLeastCommonSupertypes</a>(TypeSet(<a class="code" href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>...));</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;}</div><div class="ttc" id="_component_instantiation_transformer_8cpp_html_a769811c621f0af455fbefd863c0f1a0c"><div class="ttname"><a href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a></div><div class="ttdeci">std::vector&lt; std::unique_ptr&lt; AstType &gt; &gt; types</div><div class="ttdef"><b>Definition:</b> <a href="_component_instantiation_transformer_8cpp_source.html#l00046">ComponentInstantiationTransformer.cpp:46</a></div></div>
<div class="ttc" id="namespacesouffle_html_a172efe6c434b6ded80903a16f2535cae"><div class="ttname"><a href="namespacesouffle.html#a172efe6c434b6ded80903a16f2535cae">souffle::getLeastCommonSupertypes</a></div><div class="ttdeci">TypeSet getLeastCommonSupertypes(const Types &amp;... types)</div><div class="ttdoc">Computes the least common super types of the given types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8h_source.html#l00618">TypeSystem.h:618</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a172efe6c434b6ded80903a16f2535cae_cgraph.png" border="0" usemap="#namespacesouffle_a172efe6c434b6ded80903a16f2535cae_cgraph" alt=""/></div>
<map name="namespacesouffle_a172efe6c434b6ded80903a16f2535cae_cgraph" id="namespacesouffle_a172efe6c434b6ded80903a16f2535cae_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#abb20659f25b4513908b813cfdbf43e23" title="Computes the greatest common sub types of the two given types. " alt="" coords="342,329,553,371"/>
<area shape="rect" id="node18" href="namespacesouffle.html#a8aecaefb22443dc01bb4c208cb6aabdf" title="Computes the least common super types of the two given types. " alt="" coords="316,417,579,443"/>
<area shape="rect" id="node3" href="classsouffle_1_1_union_type.html#a0175bce933a70c1d3691114860ac17fc" title="souffle::UnionType\l::getElementTypes" alt="" coords="649,5,791,47"/>
<area shape="rect" id="node5" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="1096,173,1343,199"/>
<area shape="rect" id="node6" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="869,577,1040,603"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="643,315,797,342"/>
<area shape="rect" id="node8" href="classsouffle_1_1_type_environment.html#a5ead83575e9abfebb3a0b180a33a7d96" title="souffle::TypeEnvironment\l::isType" alt="" coords="861,493,1048,535"/>
<area shape="rect" id="node4" href="classsouffle_1_1_type.html#a00437c665d598367ff16229c823c728f" title="souffle::Type::print" alt="" coords="883,13,1026,39"/>
<area shape="rect" id="node9" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="1126,384,1313,425"/>
<area shape="rect" id="node14" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="871,391,1038,418"/>
<area shape="rect" id="node15" href="classsouffle_1_1_type_environment.html#a72fa419d33bf813f22efabec629a4627" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="1126,267,1313,308"/>
<area shape="rect" id="node16" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="873,223,1037,250"/>
<area shape="rect" id="node17" href="classsouffle_1_1_subset_type.html#ac5c52e503cbce42370d6ada3f050773d" title="souffle::SubsetType\l::getBaseType" alt="" coords="881,325,1029,367"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="1391,333,1516,359"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1587,303,1691,330"/>
<area shape="rect" id="node12" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="1564,355,1715,396"/>
<area shape="rect" id="node13" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1763,362,1909,389"/>
<area shape="rect" id="node19" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="661,518,779,545"/>
<area shape="rect" id="node20" href="classsouffle_1_1_type_environment.html#af9544bc93704955f168a0803f583ae19" title="souffle::TypeEnvironment\l::getAllTypes" alt="" coords="627,569,813,611"/>
</map>
</div>

</div>
</div>
<a id="a4221a3f8bea9103ac8244e7709fbf1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4221a3f8bea9103ac8244e7709fbf1bc">&#9670;&nbsp;</a></span>getNextAtomMaxBoundSIPS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int souffle::getNextAtomMaxBoundSIPS </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>atoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;&#160;</td>
          <td class="paramname"><em>compositeBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00511">511</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_magic_set_8cpp_source.html#l00046">contains()</a>, <a class="el" href="_ast_literal_8h_source.html#l00078">souffle::AstAtom::getArguments()</a>, <a class="el" href="_ast_literal_8h_source.html#l00058">souffle::AstAtom::getQualifiedName()</a>, <a class="el" href="json11_8h_source.html#l00651">i</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00115">isBoundArgument()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00587">getNextAtomSIPS()</a>.</p>
<div class="fragment"><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;                                                                              {</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;    <span class="keywordtype">int</span> maxBound = -1;</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    <span class="keywordtype">int</span> maxIndex = 0;</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    <span class="keywordtype">bool</span> maxIsEDB = <span class="keyword">false</span>;  <span class="comment">// checks if current max index is an EDB predicate</span></div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; atoms.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;        AstAtom* currAtom = atoms[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;        <span class="keywordflow">if</span> (currAtom == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;            <span class="comment">// already done - move on</span></div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;        }</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;        <span class="keywordtype">int</span> numBound = 0;</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;        <span class="keywordflow">for</span> (AstArgument* arg : currAtom-&gt;getArguments()) {</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a5048549cddd623327a828a4cc90fe746">isBoundArgument</a>(arg, boundArgs, compositeBindings)) {</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;                numBound++;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;            }</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;        }</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;        <span class="keywordflow">if</span> (numBound &gt; maxBound) {</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;            maxBound = numBound;</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;            maxIndex = <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;            maxIsEDB = <a class="code" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">contains</a>(edb, currAtom-&gt;getQualifiedName());</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!maxIsEDB &amp;&amp; numBound == maxBound &amp;&amp; <a class="code" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">contains</a>(edb, currAtom-&gt;getQualifiedName())) {</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;            <span class="comment">// prioritise EDB predicates</span></div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;            maxIsEDB = <span class="keyword">true</span>;</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;            maxIndex = <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;        }</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    }</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;    <span class="keywordflow">return</span> maxIndex;</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a8a825f62e860ca448e7e16ab1a3a4333"><div class="ttname"><a href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">souffle::contains</a></div><div class="ttdeci">bool contains(std::set&lt; AdornedPredicate &gt; adornedPredicates, const AstQualifiedName &amp;atomName, const std::string &amp;atomAdornment)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00046">MagicSet.cpp:46</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="namespacesouffle_html_a5048549cddd623327a828a4cc90fe746"><div class="ttname"><a href="namespacesouffle.html#a5048549cddd623327a828a4cc90fe746">souffle::isBoundArgument</a></div><div class="ttdeci">bool isBoundArgument(AstArgument *arg, const std::set&lt; std::string &gt; &amp;boundArgs, BindingStore &amp;compositeBindings)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00115">MagicSet.cpp:115</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a4221a3f8bea9103ac8244e7709fbf1bc_cgraph.png" border="0" usemap="#namespacesouffle_a4221a3f8bea9103ac8244e7709fbf1bc_cgraph" alt=""/></div>
<map name="namespacesouffle_a4221a3f8bea9103ac8244e7709fbf1bc_cgraph" id="namespacesouffle_a4221a3f8bea9103ac8244e7709fbf1bc_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333" title="souffle::contains" alt="" coords="903,84,1033,111"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="323,46,554,72"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="311,96,567,123"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a5048549cddd623327a828a4cc90fe746" title="souffle::isBoundArgument" alt="" coords="343,147,534,174"/>
<area shape="rect" id="node3" href="namespacesouffle.html#aae135d2382a133fa5b036296fbd7f60a" title="souffle::isEqualAdornment" alt="" coords="1125,84,1319,111"/>
<area shape="rect" id="node5" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="639,46,786,72"/>
<area shape="rect" id="node8" href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198" title="souffle::hasPrefix" alt="" coords="645,147,780,174"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a4d2a34e7c27740b381cf558eeebb28e4" title="souffle::isBoundComposite" alt="" coords="615,198,811,224"/>
<area shape="rect" id="node10" href="classsouffle_1_1_ast_variable.html#a2b73a95c7b59624d956dee0ed4e13884" title="souffle::AstVariable\l::getName" alt="" coords="894,136,1042,177"/>
<area shape="rect" id="node11" href="classsouffle_1_1_binding_store.html#a9ce08dc8e33c130b291f57e9d72d0c78" title="souffle::BindingStore\l::getVariableDependencies" alt="" coords="870,201,1066,242"/>
<area shape="rect" id="node12" href="classsouffle_1_1_binding_store.html#a0da8360ecba6d9b26e9d075a0b285740" title="souffle::BindingStore\l::addVariableBoundComposite" alt="" coords="859,266,1077,308"/>
</map>
</div>

</div>
</div>
<a id="a3aa310599bd78295747a8d56b3dd6cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa310599bd78295747a8d56b3dd6cd1">&#9670;&nbsp;</a></span>getNextAtomMaxRatioSIPS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int souffle::getNextAtomMaxRatioSIPS </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>atoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;&#160;</td>
          <td class="paramname"><em>compositeBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00546">546</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_literal_8h_source.html#l00078">souffle::AstAtom::getArguments()</a>, <a class="el" href="_ast_literal_8h_source.html#l00063">souffle::AstAtom::getArity()</a>, <a class="el" href="json11_8h_source.html#l00651">i</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00115">isBoundArgument()</a>.</p>
<div class="fragment"><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;                                                                            {</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;    <span class="keywordtype">double</span> maxRatio = -1;</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;    <span class="keywordtype">int</span> maxIndex = 0;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; atoms.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;        AstAtom* currAtom = atoms[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;        <span class="keywordflow">if</span> (currAtom == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;            <span class="comment">// already done - move on</span></div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;        }</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;        <span class="keywordtype">int</span> numArguments = currAtom-&gt;getArity();</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;        <span class="keywordflow">if</span> (numArguments == 0) {</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;  <span class="comment">// no arguments!</span></div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;        }</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;        <span class="keywordtype">int</span> numBound = 0;</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;        <span class="keywordflow">for</span> (AstArgument* arg : currAtom-&gt;getArguments()) {</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a5048549cddd623327a828a4cc90fe746">isBoundArgument</a>(arg, boundArgs, compositeBindings)) {</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;                numBound++;</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;            }</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;        }</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;        <span class="keywordtype">double</span> currRatio = numBound * 1.0 / numArguments;</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;        <span class="keywordflow">if</span> (currRatio == 1) {</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;  <span class="comment">// all bound, not going to get better than this</span></div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;        }</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;        <span class="keywordflow">if</span> (currRatio &gt; maxRatio) {</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;            maxRatio = currRatio;</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;            maxIndex = <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;        }</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;    }</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;    <span class="keywordflow">return</span> maxIndex;</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="namespacesouffle_html_a5048549cddd623327a828a4cc90fe746"><div class="ttname"><a href="namespacesouffle.html#a5048549cddd623327a828a4cc90fe746">souffle::isBoundArgument</a></div><div class="ttdeci">bool isBoundArgument(AstArgument *arg, const std::set&lt; std::string &gt; &amp;boundArgs, BindingStore &amp;compositeBindings)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00115">MagicSet.cpp:115</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a3aa310599bd78295747a8d56b3dd6cd1_cgraph.png" border="0" usemap="#namespacesouffle_a3aa310599bd78295747a8d56b3dd6cd1_cgraph" alt=""/></div>
<map name="namespacesouffle_a3aa310599bd78295747a8d56b3dd6cd1_cgraph" id="namespacesouffle_a3aa310599bd78295747a8d56b3dd6cd1_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="304,5,535,32"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_atom.html#a6728012e15c7e2be0b626c477c5018fd" title="get arity of the atom " alt="" coords="324,56,515,83"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a5048549cddd623327a828a4cc90fe746" title="souffle::isBoundArgument" alt="" coords="324,107,515,133"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="607,5,754,32"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198" title="souffle::hasPrefix" alt="" coords="613,56,748,83"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a4d2a34e7c27740b381cf558eeebb28e4" title="souffle::isBoundComposite" alt="" coords="583,161,779,188"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333" title="souffle::contains" alt="" coords="871,103,1001,129"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_variable.html#a2b73a95c7b59624d956dee0ed4e13884" title="souffle::AstVariable\l::getName" alt="" coords="862,154,1010,195"/>
<area shape="rect" id="node11" href="classsouffle_1_1_binding_store.html#a9ce08dc8e33c130b291f57e9d72d0c78" title="souffle::BindingStore\l::getVariableDependencies" alt="" coords="838,219,1034,261"/>
<area shape="rect" id="node12" href="classsouffle_1_1_binding_store.html#a0da8360ecba6d9b26e9d075a0b285740" title="souffle::BindingStore\l::addVariableBoundComposite" alt="" coords="827,285,1045,326"/>
<area shape="rect" id="node10" href="namespacesouffle.html#aae135d2382a133fa5b036296fbd7f60a" title="souffle::isEqualAdornment" alt="" coords="1093,103,1287,129"/>
</map>
</div>

</div>
</div>
<a id="a96942dfde31987eafed7489366283f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96942dfde31987eafed7489366283f66">&#9670;&nbsp;</a></span>getNextAtomNaiveSIPS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int souffle::getNextAtomNaiveSIPS </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&gt;&#160;</td>
          <td class="paramname"><em>atoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;&#160;</td>
          <td class="paramname"><em>compositeBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00470">470</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_magic_set_8cpp_source.html#l00046">contains()</a>, <a class="el" href="_ast_literal_8h_source.html#l00058">souffle::AstAtom::getQualifiedName()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00136">hasBoundArgument()</a>, and <a class="el" href="json11_8h_source.html#l00651">i</a>.</p>
<div class="fragment"><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;                                                                              {</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    <span class="comment">// find the first available atom with at least one bound argument</span></div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    <span class="keywordtype">int</span> firstedb = -1;</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    <span class="keywordtype">int</span> firstidb = -1;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; atoms.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;        AstAtom* currAtom = atoms[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;        <span class="keywordflow">if</span> (currAtom == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;            <span class="comment">// already done - move on</span></div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        }</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        AstQualifiedName atomName = currAtom-&gt;getQualifiedName();</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;        <span class="comment">// check if this is the first edb or idb atom met</span></div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">contains</a>(edb, atomName)) {</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;            <span class="keywordflow">if</span> (firstedb &lt; 0) {</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;                firstedb = <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;            }</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (firstidb &lt; 0) {</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;            firstidb = <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;        }</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;        <span class="comment">// if it has at least one bound argument, then adorn this atom next</span></div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a2c1c5f7d59161b1c204ead73986cc0cf">hasBoundArgument</a>(currAtom, boundArgs, compositeBindings)) {</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        }</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;    }</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    <span class="comment">// all unadorned body atoms only have free arguments</span></div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    <span class="comment">// choose the first edb remaining if available</span></div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    <span class="keywordflow">if</span> (firstedb &gt;= 0) {</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;        <span class="keywordflow">return</span> firstedb;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        <span class="keywordflow">return</span> firstidb;</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    }</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a8a825f62e860ca448e7e16ab1a3a4333"><div class="ttname"><a href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">souffle::contains</a></div><div class="ttdeci">bool contains(std::set&lt; AdornedPredicate &gt; adornedPredicates, const AstQualifiedName &amp;atomName, const std::string &amp;atomAdornment)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00046">MagicSet.cpp:46</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2c1c5f7d59161b1c204ead73986cc0cf"><div class="ttname"><a href="namespacesouffle.html#a2c1c5f7d59161b1c204ead73986cc0cf">souffle::hasBoundArgument</a></div><div class="ttdeci">bool hasBoundArgument(AstAtom *atom, const std::set&lt; std::string &gt; &amp;boundArgs, BindingStore &amp;compositeBindings)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00136">MagicSet.cpp:136</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a96942dfde31987eafed7489366283f66_cgraph.png" border="0" usemap="#namespacesouffle_a96942dfde31987eafed7489366283f66_cgraph" alt=""/></div>
<map name="namespacesouffle_a96942dfde31987eafed7489366283f66_cgraph" id="namespacesouffle_a96942dfde31987eafed7489366283f66_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333" title="souffle::contains" alt="" coords="1151,86,1281,113"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="280,48,536,74"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a2c1c5f7d59161b1c204ead73986cc0cf" title="souffle::hasBoundArgument" alt="" coords="307,98,509,125"/>
<area shape="rect" id="node3" href="namespacesouffle.html#aae135d2382a133fa5b036296fbd7f60a" title="souffle::isEqualAdornment" alt="" coords="1373,86,1567,113"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="584,60,815,86"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a5048549cddd623327a828a4cc90fe746" title="souffle::isBoundArgument" alt="" coords="604,124,795,150"/>
<area shape="rect" id="node7" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="887,48,1034,74"/>
<area shape="rect" id="node9" href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198" title="souffle::hasPrefix" alt="" coords="893,149,1028,176"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a4d2a34e7c27740b381cf558eeebb28e4" title="souffle::isBoundComposite" alt="" coords="863,200,1059,226"/>
<area shape="rect" id="node11" href="classsouffle_1_1_ast_variable.html#a2b73a95c7b59624d956dee0ed4e13884" title="souffle::AstVariable\l::getName" alt="" coords="1142,138,1290,179"/>
<area shape="rect" id="node12" href="classsouffle_1_1_binding_store.html#a9ce08dc8e33c130b291f57e9d72d0c78" title="souffle::BindingStore\l::getVariableDependencies" alt="" coords="1118,203,1314,244"/>
<area shape="rect" id="node13" href="classsouffle_1_1_binding_store.html#a0da8360ecba6d9b26e9d075a0b285740" title="souffle::BindingStore\l::addVariableBoundComposite" alt="" coords="1107,268,1325,310"/>
</map>
</div>

</div>
</div>
<a id="ae1d63e6f1d133be7f1d35c3f2a331c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d63e6f1d133be7f1d35c3f2a331c0e">&#9670;&nbsp;</a></span>getNextAtomSIPS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int souffle::getNextAtomSIPS </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>atoms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>boundArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &gt;&#160;</td>
          <td class="paramname"><em>edb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;&#160;</td>
          <td class="paramname"><em>compositeBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00587">587</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_magic_set_8cpp_source.html#l00511">getNextAtomMaxBoundSIPS()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00695">souffle::Adornment::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;                                                                       {</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a4221a3f8bea9103ac8244e7709fbf1bc">getNextAtomMaxBoundSIPS</a>(atoms, boundArgs, edb, compositeBindings);</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a4221a3f8bea9103ac8244e7709fbf1bc"><div class="ttname"><a href="namespacesouffle.html#a4221a3f8bea9103ac8244e7709fbf1bc">souffle::getNextAtomMaxBoundSIPS</a></div><div class="ttdeci">int getNextAtomMaxBoundSIPS(std::vector&lt; AstAtom *&gt; &amp;atoms, const std::set&lt; std::string &gt; &amp;boundArgs, const std::set&lt; AstQualifiedName &gt; &amp;edb, BindingStore &amp;compositeBindings)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00511">MagicSet.cpp:511</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ae1d63e6f1d133be7f1d35c3f2a331c0e_cgraph.png" border="0" usemap="#namespacesouffle_ae1d63e6f1d133be7f1d35c3f2a331c0e_cgraph" alt=""/></div>
<map name="namespacesouffle_ae1d63e6f1d133be7f1d35c3f2a331c0e_cgraph" id="namespacesouffle_ae1d63e6f1d133be7f1d35c3f2a331c0e_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a4221a3f8bea9103ac8244e7709fbf1bc" title="souffle::getNextAtomMaxBoundSIPS" alt="" coords="243,71,500,98"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333" title="souffle::contains" alt="" coords="1141,84,1270,111"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="561,46,791,72"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="548,96,804,123"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a5048549cddd623327a828a4cc90fe746" title="souffle::isBoundArgument" alt="" coords="581,147,771,174"/>
<area shape="rect" id="node4" href="namespacesouffle.html#aae135d2382a133fa5b036296fbd7f60a" title="souffle::isEqualAdornment" alt="" coords="1363,84,1556,111"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="877,46,1023,72"/>
<area shape="rect" id="node9" href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198" title="souffle::hasPrefix" alt="" coords="883,147,1017,174"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a4d2a34e7c27740b381cf558eeebb28e4" title="souffle::isBoundComposite" alt="" coords="852,198,1048,224"/>
<area shape="rect" id="node11" href="classsouffle_1_1_ast_variable.html#a2b73a95c7b59624d956dee0ed4e13884" title="souffle::AstVariable\l::getName" alt="" coords="1131,136,1279,177"/>
<area shape="rect" id="node12" href="classsouffle_1_1_binding_store.html#a9ce08dc8e33c130b291f57e9d72d0c78" title="souffle::BindingStore\l::getVariableDependencies" alt="" coords="1107,201,1303,242"/>
<area shape="rect" id="node13" href="classsouffle_1_1_binding_store.html#a0da8360ecba6d9b26e9d075a0b285740" title="souffle::BindingStore\l::addVariableBoundComposite" alt="" coords="1096,266,1315,308"/>
</map>
</div>

</div>
</div>
<a id="aeb526d569fc848583a59613102f660d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb526d569fc848583a59613102f660d3">&#9670;&nbsp;</a></span>getNextEdbName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::getNextEdbName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00196">196</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_utils_8cpp_source.html#l00056">getRelation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00899">separateDBs()</a>.</p>
<div class="fragment"><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                                              {</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">int</span> edbNum = 0;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    std::stringstream newEdbName;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="comment">// find the next unused relation name of the form &quot;newedbX&quot;, X an integer</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    <span class="keywordflow">do</span> {</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        newEdbName.str(<span class="stringliteral">&quot;&quot;</span>);  <span class="comment">// check</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        edbNum++;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        newEdbName &lt;&lt; <span class="stringliteral">&quot;newedb&quot;</span> &lt;&lt; edbNum;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    } <span class="keywordflow">while</span> (<a class="code" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">getRelation</a>(*program, newEdbName.str()) != <span class="keyword">nullptr</span>);</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="keywordflow">return</span> newEdbName.str();</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_ada252aa15afbf7d703a11b000dfd4048"><div class="ttname"><a href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">souffle::getRelation</a></div><div class="ttdeci">AstRelation * getRelation(const AstProgram &amp;program, const AstQualifiedName &amp;name)</div><div class="ttdoc">Returns the relation with the given name in the program. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00056">AstUtils.cpp:56</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aeb526d569fc848583a59613102f660d3_cgraph.png" border="0" usemap="#namespacesouffle_aeb526d569fc848583a59613102f660d3_cgraph" alt=""/></div>
<map name="namespacesouffle_aeb526d569fc848583a59613102f660d3_cgraph" id="namespacesouffle_aeb526d569fc848583a59613102f660d3_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="243,35,391,61"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="462,5,566,32"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="439,57,589,98"/>
<area shape="rect" id="node5" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="637,64,784,91"/>
</map>
</div>

</div>
</div>
<a id="a48147c448827024d87c8fd8797470196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48147c448827024d87c8fd8797470196">&#9670;&nbsp;</a></span>getOr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">C::mapped_type const&amp; souffle::getOr </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename C::key_type&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename C::mapped_type &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get value for a given key; if not found, return default value. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00328">328</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_read_stream_c_s_v_8h_source.html#l00266">souffle::ReadFileCSV::getFileName()</a>, <a class="el" href="_read_stream_c_s_v_8h_source.html#l00199">souffle::ReadStreamCSV::getInputColumnMap()</a>, <a class="el" href="_read_stream_c_s_v_8h_source.html#l00231">souffle::ReadFileCSV::ReadFileCSV()</a>, <a class="el" href="_write_stream_c_s_v_8h_source.html#l00131">souffle::WriteCoutCSV::WriteCoutCSV()</a>, <a class="el" href="_write_stream_c_s_v_8h_source.html#l00079">souffle::WriteFileCSV::WriteFileCSV()</a>, and <a class="el" href="_write_stream_c_s_v_8h_source.html#l00097">souffle::WriteFileCSV::writeNextTuple()</a>.</p>
<div class="fragment"><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                                                                                               {</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    <span class="keyword">auto</span> it = container.find(key);</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="keywordflow">if</span> (it != container.end()) {</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        <span class="keywordflow">return</span> it-&gt;second;</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;        <span class="keywordflow">return</span> defaultValue;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    }</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a1f3d2bbfbcd58c76463920d43a29b3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3d2bbfbcd58c76463920d43a29b3d0">&#9670;&nbsp;</a></span>getOutputLock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1_lock.html">Lock</a>&amp; souffle::getOutputLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a reference to the lock synchronizing output operations. </p>

<p class="definition">Definition at line <a class="el" href="_parallel_utils_8h_source.html#l00568">568</a> of file <a class="el" href="_parallel_utils_8h_source.html">ParallelUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_write_stream_c_s_v_8h_source.html#l00157">souffle::WriteCoutPrintSize::WriteCoutPrintSize()</a>.</p>
<div class="fragment"><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;                             {</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;    <span class="keyword">static</span> Lock outputLock;</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;    <span class="keywordflow">return</span> outputLock;</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a9726f0afbc98fa9807f0ba3bff93ba56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9726f0afbc98fa9807f0ba3bff93ba56">&#9670;&nbsp;</a></span>getRecords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const <a class="el" href="classsouffle_1_1_ast_record_init.html">AstRecordInit</a> * &gt; souffle::getRecords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a list of all records referenced within the AST rooted by the given root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be searched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of all records referenced within </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00035">35</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>.</p>
<div class="fragment"><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;                                                                {</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <span class="comment">// simply collect the list of all records by visiting all records</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    std::vector&lt;const AstRecordInit*&gt; recs;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(root, [&amp;](<span class="keyword">const</span> AstRecordInit&amp; rec) { recs.push_back(&amp;rec); });</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <span class="keywordflow">return</span> recs;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a9726f0afbc98fa9807f0ba3bff93ba56_cgraph.png" border="0" usemap="#namespacesouffle_a9726f0afbc98fa9807f0ba3bff93ba56_cgraph" alt=""/></div>
<map name="namespacesouffle_a9726f0afbc98fa9807f0ba3bff93ba56_cgraph" id="namespacesouffle_a9726f0afbc98fa9807f0ba3bff93ba56_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="200,13,368,39"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="416,5,584,47"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="632,5,823,47"/>
</map>
</div>

</div>
</div>
<a id="ada252aa15afbf7d703a11b000dfd4048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada252aa15afbf7d703a11b000dfd4048">&#9670;&nbsp;</a></span>getRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> * souffle::getRelation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the relation with the given name in the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>the program </td></tr>
    <tr><td class="paramname">name</td><td>the name of the relation to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the relation if it exists; nullptr otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00056">56</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00318">getIf()</a>, and <a class="el" href="_ast_program_8h_source.html#l00057">souffle::AstProgram::getRelations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00337">addForwardDependencies()</a>, <a class="el" href="_parser_driver_8cpp_source.html#l00110">souffle::ParserDriver::addRelation()</a>, <a class="el" href="_ast_program_8h_source.html#l00082">souffle::AstProgram::addRelation()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00382">souffle::AstSemanticChecker::checkAtom()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00610">souffle::AstSemanticChecker::checkFact()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l01219">souffle::AstSemanticChecker::checkInlining()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00972">souffle::AstSemanticChecker::checkIO()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00176">containsInlinedAtom()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00422">formNegatedLiterals()</a>, <a class="el" href="_aux_arity_analysis_8h_source.html#l00045">souffle::AuxiliaryArity::getArity()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00075">getAtomRelation()</a>, <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00096">getClauseNum()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00086">souffle::AstTranslator::getEvaluationArity()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00787">getInlinedLiteral()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00196">getNextEdbName()</a>, <a class="el" href="_souffle_interface_8h_source.html#l00805">souffle::SouffleProgram::getRelationName()</a>, <a class="el" href="_souffle_interface_8h_source.html#l00795">souffle::SouffleProgram::getRelationSize()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00224">souffle::MaterializeAggregationQueriesTransformer::materializeAggregationQueries()</a>, <a class="el" href="_ram_statement_8h_source.html#l00119">souffle::RamIO::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00158">souffle::RamClear::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00227">souffle::RamScan::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00259">souffle::RamParallelScan::print()</a>, <a class="el" href="_ram_condition_8h_source.html#l00306">souffle::RamAbstractExistenceCheck::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00367">souffle::RamIndexScan::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00408">souffle::RamParallelIndexScan::print()</a>, <a class="el" href="_ram_condition_8h_source.html#l00420">souffle::RamEmptinessCheck::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00493">souffle::RamChoice::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00534">souffle::RamParallelChoice::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00597">souffle::RamIndexChoice::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00646">souffle::RamParallelIndexChoice::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00650">souffle::RamLogRelationTimer::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00757">souffle::RamLogSize::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00783">souffle::RamAggregate::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00839">souffle::RamIndexAggregate::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l01079">souffle::RamProject::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00309">souffle::RamIndexOperation::printIndex()</a>, <a class="el" href="_ram_operation_8h_source.html#l00562">souffle::RamIndexChoice::RamIndexChoice()</a>, <a class="el" href="_ram_operation_8h_source.html#l00273">souffle::RamIndexOperation::RamIndexOperation()</a>, <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00372">reduceSingletonRelations()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00079">souffle::RemoveRelationCopiesTransformer::removeRelationCopies()</a>, <a class="el" href="_ast_i_o_type_analysis_8cpp_source.html#l00025">souffle::IOType::run()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00695">souffle::Adornment::run()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00822">souffle::ReduceExistentialsTransformer::transform()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                                                                                  {</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa">getIf</a>(program.getRelations(), [&amp;](<span class="keyword">const</span> AstRelation* r) { <span class="keywordflow">return</span> r-&gt;getQualifiedName() == name; });</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a62f80c157a6a365d78a43592732a8efa"><div class="ttname"><a href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa">souffle::getIf</a></div><div class="ttdeci">C::value_type getIf(const C &amp;container, std::function&lt; bool(const typename C::value_type)&gt; pred)</div><div class="ttdoc">Returns the first element in a container that satisfies a given predicate, nullptr otherwise...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00318">Util.h:318</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ada252aa15afbf7d703a11b000dfd4048_cgraph.png" border="0" usemap="#namespacesouffle_ada252aa15afbf7d703a11b000dfd4048_cgraph" alt=""/></div>
<map name="namespacesouffle_ada252aa15afbf7d703a11b000dfd4048_cgraph" id="namespacesouffle_ada252aa15afbf7d703a11b000dfd4048_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="225,5,329,32"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="201,57,352,98"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="400,64,547,91"/>
</map>
</div>

</div>
</div>
<a id="acb3060fa0568d3ce72ce5ac14941af29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3060fa0568d3ce72ce5ac14941af29">&#9670;&nbsp;</a></span>getRelationQualifierFromTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#a4d1111156440d898474b3cd9cd43a276">RelationQualifier</a> souffle::getRelationQualifierFromTag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529f">RelationTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the corresponding RelationQualifier for a valid RelationTag. </p>

<p class="definition">Definition at line <a class="el" href="_relation_tag_8h_source.html#l00087">87</a> of file <a class="el" href="_relation_tag_8h_source.html">RelationTag.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">INLINE</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529faa84cc046d48610b05c21fd3670d0c829">INPUT</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa50a87f0d71f7221582dad4bf507a0f34">OUTPUT</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fac9572efed22489a0eb4ab9dcd8132d4b">OVERRIDABLE</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa412e14f57c2f0eeb02d2475ca63bf38c">PRINTSIZE</a>, and <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa749f7196d531a918508ddc75af68469d">SUPPRESSED</a>.</p>
<div class="fragment"><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                                                                             {</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keywordflow">switch</span> (tag) {</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        <span class="keywordflow">case</span> RelationTag::INPUT:</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            <span class="keywordflow">return</span> RelationQualifier::INPUT;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="keywordflow">case</span> RelationTag::OUTPUT:</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            <span class="keywordflow">return</span> RelationQualifier::OUTPUT;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        <span class="keywordflow">case</span> RelationTag::PRINTSIZE:</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;            <span class="keywordflow">return</span> RelationQualifier::PRINTSIZE;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        <span class="keywordflow">case</span> RelationTag::OVERRIDABLE:</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            <span class="keywordflow">return</span> RelationQualifier::OVERRIDABLE;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <span class="keywordflow">case</span> RelationTag::INLINE:</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            <span class="keywordflow">return</span> RelationQualifier::INLINE;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        <span class="keywordflow">case</span> RelationTag::SUPPRESSED:</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            <span class="keywordflow">return</span> RelationQualifier::SUPPRESSED;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;            assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;invalid relation tag&quot;</span>);</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    }</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a276d79bb2f106919b0baeb7fcf7d838c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a276d79bb2f106919b0baeb7fcf7d838c">&#9670;&nbsp;</a></span>getRelationRepresentationFromTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9e">RelationRepresentation</a> souffle::getRelationRepresentationFromTag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529f">RelationTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the corresponding RelationRepresentation for a valid RelationTag. </p>

<p class="definition">Definition at line <a class="el" href="_relation_tag_8h_source.html#l00109">109</a> of file <a class="el" href="_relation_tag_8h_source.html">RelationTag.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fade0f2c62e46b76fe07b1033a2af15a28">BRIE</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa26daa90bc6e4e7baf2b5781caef22940">BTREE</a>, and <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa06a35dca93aeafc1b0f548410517223a">EQREL</a>.</p>
<div class="fragment"><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                                                                                       {</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="keywordflow">switch</span> (tag) {</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        <span class="keywordflow">case</span> RelationTag::BRIE:</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;            <span class="keywordflow">return</span> RelationRepresentation::BRIE;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        <span class="keywordflow">case</span> RelationTag::BTREE:</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;            <span class="keywordflow">return</span> RelationRepresentation::BTREE;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="keywordflow">case</span> RelationTag::EQREL:</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;            <span class="keywordflow">return</span> RelationRepresentation::EQREL;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;            assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;invalid relation tag&quot;</span>);</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    }</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a34387241fab1e3ecc054fed02cee2d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34387241fab1e3ecc054fed02cee2d0d">&#9670;&nbsp;</a></span>getSipsFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#ad0dcec7b78fdde7450cb55df1fece164">sips_t</a> souffle::getSipsFunction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sipsChosen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a SIPS function based on the SIPS option provided. </p>
<p>The SIPS function will return the index of the appropriate atom in a clause given a goal.</p>
<p>E.g. the 'max-bound' SIPS function will return the atom in the clause with the maximum number of bound arguments. </p>

<p class="definition">Definition at line <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00079">79</a> of file <a class="el" href="_reorder_literals_transformer_8cpp_source.html">ReorderLiteralsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_literal_8h_source.html#l00063">souffle::AstAtom::getArity()</a>, <a class="el" href="_ast_argument_8h_source.html#l00052">souffle::AstVariable::getName()</a>, <a class="el" href="json11_8h_source.html#l00651">i</a>, <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00042">isProposition()</a>, <a class="el" href="_resolve_aliases_transformer_8cpp_source.html#l00160">lhs</a>, <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00049">numBoundArguments()</a>, <a class="el" href="_resolve_aliases_transformer_8cpp_source.html#l00161">rhs</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00355">souffle::ReorderLiteralsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                                                    {</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="comment">// --- Create the appropriate SIPS function ---</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="comment">// Each SIPS function has a priority metric (e.g. max-bound atoms).</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="comment">// Arguments:</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="comment">//      - a vector of atoms to choose from (nullpointers in the vector will be ignored)</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="comment">//      - the set of variables bound so far</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="comment">// Returns: the index of the atom maximising the priority metric</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <a class="code" href="namespacesouffle.html#ad0dcec7b78fdde7450cb55df1fece164">sips_t</a> getNextAtomSips;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="keywordflow">if</span> (sipsChosen == <span class="stringliteral">&quot;naive&quot;</span>) {</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <span class="comment">// Goal: choose the first atom with at least one bound argument, or with no arguments</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        getNextAtomSips = [&amp;](std::vector&lt;AstAtom*&gt; atoms, <span class="keyword">const</span> std::set&lt;std::string&gt;&amp; boundVariables) {</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; atoms.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;                <span class="keyword">const</span> AstAtom* currAtom = atoms[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                <span class="keywordflow">if</span> (currAtom == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                    <span class="comment">// already processed - move on</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                }</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a1c608d44d9d95373b73915fd555eeb60">isProposition</a>(currAtom)) {</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                    <span class="comment">// no arguments</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;                }</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a84b8ff6e096476fd6097c05b4eb12386">numBoundArguments</a>(currAtom, boundVariables) &gt;= 1) {</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;                    <span class="comment">// at least one bound argument</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;                }</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;            }</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;            <span class="comment">// none found; choose the first non-null</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; atoms.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                <span class="keywordflow">if</span> (atoms[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>] != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;                }</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;            }</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;            <span class="comment">// fall back to the first</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;            <span class="keywordflow">return</span> 0U;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        };</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sipsChosen == <span class="stringliteral">&quot;all-bound&quot;</span>) {</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        <span class="comment">// Goal: prioritise atoms with all arguments bound</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        getNextAtomSips = [&amp;](std::vector&lt;AstAtom*&gt; atoms, <span class="keyword">const</span> std::set&lt;std::string&gt;&amp; boundVariables) {</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; atoms.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;                <span class="keyword">const</span> AstAtom* currAtom = atoms[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;                <span class="keywordflow">if</span> (currAtom == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                    <span class="comment">// already processed - move on</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                }</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a1c608d44d9d95373b73915fd555eeb60">isProposition</a>(currAtom)) {</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                    <span class="comment">// no arguments, so all are trivially bound</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                }</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                <span class="keywordtype">int</span> arity = currAtom-&gt;getArity();</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                <span class="keywordtype">int</span> numBound = <a class="code" href="namespacesouffle.html#a84b8ff6e096476fd6097c05b4eb12386">numBoundArguments</a>(currAtom, boundVariables);</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                <span class="keywordflow">if</span> (numBound == arity) {</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;                    <span class="comment">// all arguments are bound!</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;                }</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;            }</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;            <span class="comment">// none found; choose the first non-null</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; atoms.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                <span class="keywordflow">if</span> (atoms[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>] != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;                }</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            }</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;            <span class="comment">// fall back to the first</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            <span class="keywordflow">return</span> 0U;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        };</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sipsChosen == <span class="stringliteral">&quot;max-bound&quot;</span>) {</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        <span class="comment">// Goal: choose the atom with the maximum number of bound variables</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="comment">//       - exception: propositions should be prioritised</span></div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        getNextAtomSips = [&amp;](std::vector&lt;AstAtom*&gt; atoms, <span class="keyword">const</span> std::set&lt;std::string&gt;&amp; boundVariables) {</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;            <span class="keywordtype">int</span> currMaxBound = -1;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> currMaxIdx = 0U;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; atoms.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                <span class="keyword">const</span> AstAtom* currAtom = atoms[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                <span class="keywordflow">if</span> (currAtom == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                    <span class="comment">// already processed - move on</span></div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                }</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a1c608d44d9d95373b73915fd555eeb60">isProposition</a>(currAtom)) {</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                    <span class="comment">// propositions should be prioritised</span></div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                }</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                <span class="keywordtype">int</span> numBound = <a class="code" href="namespacesouffle.html#a84b8ff6e096476fd6097c05b4eb12386">numBoundArguments</a>(currAtom, boundVariables);</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                <span class="keywordflow">if</span> (numBound &gt; currMaxBound) {</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                    currMaxBound = numBound;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                    currMaxIdx = <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                }</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;            }</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;            <span class="keywordflow">return</span> currMaxIdx;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        };</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sipsChosen == <span class="stringliteral">&quot;max-ratio&quot;</span>) {</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="comment">// Goal: choose the atom with the maximum ratio of bound to unbound</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        getNextAtomSips = [&amp;](std::vector&lt;AstAtom*&gt; atoms, <span class="keyword">const</span> std::set&lt;std::string&gt;&amp; boundVariables) {</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;            <span class="keyword">auto</span> isLargerRatio = [&amp;](std::pair&lt;int, int&gt; <a class="code" href="_resolve_aliases_transformer_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>, std::pair&lt;int, int&gt; <a class="code" href="_resolve_aliases_transformer_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a>) {</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                <span class="keywordflow">return</span> (lhs.first * <a class="code" href="_resolve_aliases_transformer_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a>.second &gt; lhs.second * <a class="code" href="_resolve_aliases_transformer_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a>.first);</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;            };</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;            <span class="keyword">auto</span> currMaxRatio = std::pair&lt;int, int&gt;(-1, 1);  <span class="comment">// set to -1</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> currMaxIdx = 0U;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; atoms.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                <span class="keyword">const</span> AstAtom* currAtom = atoms[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                <span class="keywordflow">if</span> (currAtom == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                    <span class="comment">// already processed - move on</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                }</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a1c608d44d9d95373b73915fd555eeb60">isProposition</a>(currAtom)) {</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                    <span class="comment">// propositions are as bound as possible</span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                }</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;                <span class="keywordtype">int</span> numBound = <a class="code" href="namespacesouffle.html#a84b8ff6e096476fd6097c05b4eb12386">numBoundArguments</a>(currAtom, boundVariables);</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                <span class="keywordtype">int</span> numArgs = currAtom-&gt;getArity();</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                <span class="keyword">auto</span> currRatio = std::pair&lt;int, int&gt;(numBound, numArgs);</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                <span class="keywordflow">if</span> (isLargerRatio(currRatio, currMaxRatio)) {</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                    currMaxRatio = currRatio;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                    currMaxIdx = <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                }</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;            }</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;            <span class="keywordflow">return</span> currMaxIdx;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        };</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sipsChosen == <span class="stringliteral">&quot;least-free&quot;</span>) {</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        <span class="comment">// Goal: choose the atom with the least number of unbound arguments</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        getNextAtomSips = [&amp;](std::vector&lt;AstAtom*&gt; atoms, <span class="keyword">const</span> std::set&lt;std::string&gt;&amp; boundVariables) {</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;            <span class="keywordtype">int</span> currLeastFree = -1;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> currLeastIdx = 0U;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; atoms.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                <span class="keyword">const</span> AstAtom* currAtom = atoms[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                <span class="keywordflow">if</span> (currAtom == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                    <span class="comment">// already processed - move on</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                }</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a1c608d44d9d95373b73915fd555eeb60">isProposition</a>(currAtom)) {</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;                    <span class="comment">// propositions have 0 unbound arguments, which is minimal</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                }</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                <span class="keywordtype">int</span> numBound = <a class="code" href="namespacesouffle.html#a84b8ff6e096476fd6097c05b4eb12386">numBoundArguments</a>(currAtom, boundVariables);</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                <span class="keywordtype">int</span> numFree = currAtom-&gt;getArity() - numBound;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                <span class="keywordflow">if</span> (currLeastFree == -1 || numFree &lt; currLeastFree) {</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                    currLeastFree = numFree;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                    currLeastIdx = <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                }</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;            }</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;            <span class="keywordflow">return</span> currLeastIdx;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        };</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sipsChosen == <span class="stringliteral">&quot;least-free-vars&quot;</span>) {</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        <span class="comment">// Goal: choose the atom with the least amount of unbound variables</span></div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        getNextAtomSips = [&amp;](std::vector&lt;AstAtom*&gt; atoms, <span class="keyword">const</span> std::set&lt;std::string&gt;&amp; boundVariables) {</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;            <span class="keywordtype">int</span> currLeastFree = -1;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> currLeastIdx = 0U;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; atoms.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                <span class="keyword">const</span> AstAtom* currAtom = atoms[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;                <span class="keywordflow">if</span> (currAtom == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                    <span class="comment">// already processed - move on</span></div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                }</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a1c608d44d9d95373b73915fd555eeb60">isProposition</a>(currAtom)) {</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;                    <span class="comment">// propositions have 0 unbound variables, which is minimal</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                }</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                <span class="comment">// use a set to hold all free variables to avoid double-counting</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                std::set&lt;std::string&gt; freeVars;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(*currAtom, [&amp;](<span class="keyword">const</span> AstVariable&amp; var) {</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                    <span class="keywordflow">if</span> (boundVariables.find(var.getName()) == boundVariables.end()) {</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                        freeVars.insert(var.getName());</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                    }</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                });</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                <span class="keywordtype">int</span> numFreeVars = freeVars.size();</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                <span class="keywordflow">if</span> (currLeastFree == -1 || numFreeVars &lt; currLeastFree) {</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                    currLeastFree = numFreeVars;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                    currLeastIdx = <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                }</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;            }</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;            <span class="keywordflow">return</span> currLeastIdx;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;        };</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        <span class="comment">// chosen SIPS is not implemented, so keep the same order</span></div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;        <span class="comment">// Goal: leftmost atom first</span></div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;        getNextAtomSips = [&amp;](std::vector&lt;AstAtom*&gt; atoms,</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                                  <span class="keyword">const</span> std::set&lt;std::string&gt;&amp; <span class="comment">/* boundVariables */</span>) {</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; atoms.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;                <span class="keywordflow">if</span> (atoms[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>] == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                    <span class="comment">// already processed - move on</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                }</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;            }</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            <span class="comment">// fall back to the first</span></div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;            <span class="keywordflow">return</span> 0U;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        };</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    }</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    <span class="keywordflow">return</span> getNextAtomSips;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_ad0dcec7b78fdde7450cb55df1fece164"><div class="ttname"><a href="namespacesouffle.html#ad0dcec7b78fdde7450cb55df1fece164">souffle::sips_t</a></div><div class="ttdeci">std::function&lt; unsigned int(std::vector&lt; AstAtom * &gt;, const std::set&lt; std::string &gt; &amp;)&gt; sips_t</div><div class="ttdef"><b>Definition:</b> <a href="_reorder_literals_transformer_8cpp_source.html#l00040">ReorderLiteralsTransformer.cpp:40</a></div></div>
<div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="namespacesouffle_html_a1c608d44d9d95373b73915fd555eeb60"><div class="ttname"><a href="namespacesouffle.html#a1c608d44d9d95373b73915fd555eeb60">souffle::isProposition</a></div><div class="ttdeci">bool isProposition(const AstAtom *atom)</div><div class="ttdef"><b>Definition:</b> <a href="_reorder_literals_transformer_8cpp_source.html#l00042">ReorderLiteralsTransformer.cpp:42</a></div></div>
<div class="ttc" id="_resolve_aliases_transformer_8cpp_html_a99d7476d0087a8405f52a79852efa6eb"><div class="ttname"><a href="_resolve_aliases_transformer_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; rhs</div><div class="ttdef"><b>Definition:</b> <a href="_resolve_aliases_transformer_8cpp_source.html#l00161">ResolveAliasesTransformer.cpp:161</a></div></div>
<div class="ttc" id="namespacesouffle_html_a84b8ff6e096476fd6097c05b4eb12386"><div class="ttname"><a href="namespacesouffle.html#a84b8ff6e096476fd6097c05b4eb12386">souffle::numBoundArguments</a></div><div class="ttdeci">unsigned int numBoundArguments(const AstAtom *atom, const std::set&lt; std::string &gt; &amp;boundVariables)</div><div class="ttdoc">Counts the number of bound arguments in a given atom. </div><div class="ttdef"><b>Definition:</b> <a href="_reorder_literals_transformer_8cpp_source.html#l00049">ReorderLiteralsTransformer.cpp:49</a></div></div>
<div class="ttc" id="_resolve_aliases_transformer_8cpp_html_aae193eebe112e754a082b152fb272018"><div class="ttname"><a href="_resolve_aliases_transformer_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; lhs</div><div class="ttdef"><b>Definition:</b> <a href="_resolve_aliases_transformer_8cpp_source.html#l00160">ResolveAliasesTransformer.cpp:160</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a34387241fab1e3ecc054fed02cee2d0d_cgraph.png" border="0" usemap="#namespacesouffle_a34387241fab1e3ecc054fed02cee2d0d_cgraph" alt=""/></div>
<map name="namespacesouffle_a34387241fab1e3ecc054fed02cee2d0d_cgraph" id="namespacesouffle_a34387241fab1e3ecc054fed02cee2d0d_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a6728012e15c7e2be0b626c477c5018fd" title="get arity of the atom " alt="" coords="241,5,432,32"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_variable.html#a2b73a95c7b59624d956dee0ed4e13884" title="souffle::AstVariable\l::getName" alt="" coords="533,54,681,95"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a1c608d44d9d95373b73915fd555eeb60" title="souffle::isProposition" alt="" coords="257,107,416,133"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a84b8ff6e096476fd6097c05b4eb12386" title="Counts the number of bound arguments in a given atom. " alt="" coords="229,157,444,184"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="523,191,691,217"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="492,124,723,151"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="781,124,928,151"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="771,183,939,225"/>
<area shape="rect" id="node10" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="987,183,1177,225"/>
</map>
</div>

</div>
</div>
<a id="aa8c9919e28ef370c84f30355144ccb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c9919e28ef370c84f30355144ccb81">&#9670;&nbsp;</a></span>getStarttime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ss&lt;&lt; R&quot;_(&quot;code&quot;: [)_&quot;; bool firstCol = true; while (getline(source_file, <a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>)) { comma(firstCol, &quot;,\n&quot;); ss &lt;&lt; '&quot;' &lt;&lt; Tools::cleanJsonOut(<a class="el" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>) &lt;&lt; '&quot;'; } ss &lt;&lt; &quot;],\n&quot;; source_file.close(); } auto usages = getUsageStats(100); auto beginTime = run-&gt; souffle::getStarttime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a526256b2f4d593cceb8b73068e7de882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526256b2f4d593cceb8b73068e7de882">&#9670;&nbsp;</a></span>getString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::getString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00083">83</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00444">bindArguments()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00147">isBindingConstraint()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00695">souffle::Adornment::run()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                                            {</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    std::stringstream argStream;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    argStream &lt;&lt; *arg;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keywordflow">return</span> argStream.str();</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a9d5684d03fd4d404219e054226b94c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5684d03fd4d404219e054226b94c19">&#9670;&nbsp;</a></span>getSymbolForFunctorOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::getSymbolForFunctorOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a>&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string representation of a functor. </p>
<p>Unary Functor Operators</p>
<p>Binary Functor Operators</p>
<p>Ternary Functor Operators </p>

<p class="definition">Definition at line <a class="el" href="_functor_ops_8h_source.html#l00179">179</a> of file <a class="el" href="_functor_ops_8h_source.html">FunctorOps.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9eeb52badb613229884838847294b90d">ADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aa8a5bbeedca093b94b7f0d3f185b98f7">BAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0fd78279a775c262180e0cfbad6fa9eb">BNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0adf6aac232504c55ea4202e09498bfd">BOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a88d973d6a866ababf2fb28a6112f8d46">BSHIFT_L</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9e74511ce5c138f374559a76abb6e209">BSHIFT_R</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3fdb4dd3e2677523449a3747923d4401">BSHIFT_R_UNSIGNED</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a21506bac4ecfbfe4272b9bf8185446b6">BXOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac01ae1a5f122f25ce5675f86028b536a">CAT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a29bbf66f7f8529ec47e394fb5a36c646">DIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc2cbacfa7c4ef9bc72773ebdd9fe166">FADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9abccb2b7436e0cbfb334fe07304fe28a6">FDIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a107c7a3cc48a0fe27d435e82c8679ef0">FEXP</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1">FMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6">FMIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a26a83f923754f1e7aa12640b8bcca29a">FMUL</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a36da8d8fdce0e080abfcab7af41066c6">FNEG</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a06be1058e817f781f4e0f0641f436247">FSUB</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a81bf488d5db54d36a738384aaf845fdf">FTOI</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a89aa92cb66549459a7d407094aacbcef">FTOU</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc526b23b5b6d76a12984c29bf63c4a3">ITOF</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4c0f1a4930775ab571de3e85aedc623e">ITOU</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a479a809c0b6eaaefd3b1df16f976df06">LAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a81145009eec44ad2c399c9459a01d8f0">LNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ad3335c358811cfc353257e21b1d38229">LOR</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">MAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">MIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac5a28f4b35a2884fa3277150ac5d0967">MOD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2cdf52a55876063ec93b7d18bc741f6c">MUL</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a5dd68b1a7db42a1cce4dce09dbaa179e">NEG</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac23431d0209648a6b31fa837dd56d681">ORD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a00e365acdc6de6b62421116e865bd420">SMAX</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2d9174ad446fde0fc750265f9e075977">SMIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc37711c3936f2459ef27e1dbe4f6480">STRLEN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a241dd841abade20fcb27b8a9f494e1eb">SUB</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0f85e58dd75e7025beb47ee590ff7669">SUBSTR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aae9c007a17eb01f69e2dba22cf15cf30">TONUMBER</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a91b8cf1c9769ddb9cb64191c89becc1b">TOSTRING</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a1f0002abde2c29615d914ab0228c68d3">UADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ab5755f546c5f5ca6a3f1720ef8e642ef">UBAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac2fc8ad7a275c06c870529f9f9f07caa">UBNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4803dabeb7190f48195a26654eafaa42">UBOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a653789f2eb8bfa402c5f60ceceac247b">UBSHIFT_L</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aab623d5679ac1cc907cb363e2d51eb14">UBSHIFT_R</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a07da89f09f961f63a15696ac57bbc1c3">UBSHIFT_R_UNSIGNED</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a70f4367aed9601f37bfbdd4586b327df">UBXOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a56d5c96c848631ef14e1f2a6e0f15d49">UDIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a59407eef1229dea3aac5dc8d77d06c92">UEXP</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3d0f34d8e784f8a48332424dd598a27a">ULAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a7fdc4b2848234d42fe9a22b78fd68910">ULNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9addb2113545b6bd7fbe64ed7bff507964">ULOR</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059">UMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb">UMIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4bbe00e945b01d43cb7edecf51b0de5c">UMOD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ae89690f1278cca1400678daaa4a6a3b7">UMUL</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9af8aba91736be4bad67181a8cce032337">USUB</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9d0ef69432b16260e9622b4f614bc9c5">UTOF</a>, and <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac059c9401f1af0e831f9f180f3c6bfef">UTOI</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ram_expression_8h_source.html#l00113">souffle::RamIntrinsicOperator::print()</a>, and <a class="el" href="_ast_argument_8h_source.html#l00318">souffle::AstIntrinsicFunctor::print()</a>.</p>
<div class="fragment"><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                                                           {</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="keywordflow">switch</span> (op) {<span class="comment"></span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="comment">        /** Unary Functor Operators */</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ITOF:</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;itof&quot;</span>;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ITOU:</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;itou&quot;</span>;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UTOF:</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;utof&quot;</span>;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UTOI:</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;utoi&quot;</span>;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FTOI:</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;ftoi&quot;</span>;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FTOU:</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;ftou&quot;</span>;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ORD:</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;ord&quot;</span>;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        <span class="keywordflow">case</span> FunctorOp::STRLEN:</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;strlen&quot;</span>;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        <span class="keywordflow">case</span> FunctorOp::NEG:</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FNEG:</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;-&quot;</span>;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BNOT:</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBNOT:</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;bnot&quot;</span>;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LNOT:</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ULNOT:</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;lnot&quot;</span>;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        <span class="keywordflow">case</span> FunctorOp::TONUMBER:</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;to_number&quot;</span>;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        <span class="keywordflow">case</span> FunctorOp::TOSTRING:</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;to_string&quot;</span>;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment">        /** Binary Functor Operators */</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ADD:</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FADD:</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UADD:</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;+&quot;</span>;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SUB:</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        <span class="keywordflow">case</span> FunctorOp::USUB:</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FSUB:</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;-&quot;</span>;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MUL:</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMUL:</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FMUL:</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;*&quot;</span>;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        <span class="keywordflow">case</span> FunctorOp::DIV:</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UDIV:</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FDIV:</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;/&quot;</span>;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        <span class="keywordflow">case</span> FunctorOp::EXP:</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FEXP:</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UEXP:</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;^&quot;</span>;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MOD:</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMOD:</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;%&quot;</span>;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BAND:</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBAND:</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;band&quot;</span>;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BOR:</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBOR:</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;bor&quot;</span>;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BXOR:</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBXOR:</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;bxor&quot;</span>;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_L:</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBSHIFT_L:</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;bshl&quot;</span>;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_R:</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBSHIFT_R:</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;bshr&quot;</span>;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_R_UNSIGNED:</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBSHIFT_R_UNSIGNED:</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;bshru&quot;</span>;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LAND:</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ULAND:</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;land&quot;</span>;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LOR:</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ULOR:</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;lor&quot;</span>;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        <span class="comment">/* N-ary Functor Operators */</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MAX:</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMAX:</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FMAX:</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SMAX:</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;max&quot;</span>;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MIN:</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMIN:</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FMIN:</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SMIN:</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;min&quot;</span>;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        <span class="keywordflow">case</span> FunctorOp::CAT:</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;cat&quot;</span>;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment">        /** Ternary Functor Operators */</span></div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SUBSTR:</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;substr&quot;</span>;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    }</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;unsupported operator&quot;</span>);</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    exit(EXIT_FAILURE);</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    <span class="keywordflow">return</span> <span class="stringliteral">&quot;?&quot;</span>;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a0df5320dfcc5fe6ad9bbda0edc5876bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df5320dfcc5fe6ad9bbda0edc5876bc">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsouffle_1_1_ast_type.html">AstType</a> * souffle::getType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type with the given name in the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>the program </td></tr>
    <tr><td class="paramname">name</td><td>the name of the type to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type if it exists; nullptr otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00060">60</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00318">getIf()</a>, and <a class="el" href="_ast_program_8h_source.html#l00052">souffle::AstProgram::getTypes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_parser_driver_8cpp_source.html#l00139">souffle::ParserDriver::addType()</a>, <a class="el" href="_ast_program_8h_source.html#l00282">souffle::AstProgram::addType()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00789">souffle::AstSemanticChecker::checkRecordType()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00699">souffle::AstSemanticChecker::checkRelationDeclaration()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00769">souffle::AstSemanticChecker::checkUnionType()</a>, <a class="el" href="_ast_argument_8h_source.html#l00173">souffle::AstNumericConstant::clone()</a>, <a class="el" href="_type_system_8h_source.html#l00372">souffle::TypeEnvironment::createRecordType()</a>, <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>, <a class="el" href="_type_system_8h_source.html#l00392">souffle::TypeEnvironment::getFloatType()</a>, <a class="el" href="_type_system_8h_source.html#l00384">souffle::TypeEnvironment::getNumberType()</a>, <a class="el" href="_type_system_8h_source.html#l00396">souffle::TypeEnvironment::getSymbolType()</a>, <a class="el" href="_type_system_8h_source.html#l00388">souffle::TypeEnvironment::getUnsignedType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00054">souffle::TypeEnvironment::initializePredefinedTypes()</a>, <a class="el" href="_type_system_8h_source.html#l00400">souffle::TypeEnvironment::isPredefinedType()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00085">souffle::TypeEnvironment::isType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                                                                                {</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa">getIf</a>(program.getTypes(), [&amp;](<span class="keyword">const</span> AstType* t) { <span class="keywordflow">return</span> t-&gt;getQualifiedName() == name; });</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a62f80c157a6a365d78a43592732a8efa"><div class="ttname"><a href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa">souffle::getIf</a></div><div class="ttdeci">C::value_type getIf(const C &amp;container, std::function&lt; bool(const typename C::value_type)&gt; pred)</div><div class="ttdoc">Returns the first element in a container that satisfies a given predicate, nullptr otherwise...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00318">Util.h:318</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a0df5320dfcc5fe6ad9bbda0edc5876bc_cgraph.png" border="0" usemap="#namespacesouffle_a0df5320dfcc5fe6ad9bbda0edc5876bc_cgraph" alt=""/></div>
<map name="namespacesouffle_a0df5320dfcc5fe6ad9bbda0edc5876bc_cgraph" id="namespacesouffle_a0df5320dfcc5fe6ad9bbda0edc5876bc_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="202,5,306,32"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="179,57,329,98"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="377,64,524,91"/>
</map>
</div>

</div>
</div>
<a id="afe2ff9f374555126a532203710149346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2ff9f374555126a532203710149346">&#9670;&nbsp;</a></span>getTypeAttribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> souffle::getTypeAttribute </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a type analysis' type/set of type to the the TypeAttribute. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8h_source.html#l00485">485</a> of file <a class="el" href="_type_system_8h_source.html">TypeSystem.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a22ae0e2b89e5e3d477f988cc36d3272b">Float</a>, <a class="el" href="_type_system_8cpp_source.html#l00331">isFloatType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00339">isNumberType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00363">isRecordType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00355">isSymbolType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00347">isUnsignedType()</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a6a0d9eaee314c567fd72fb97ee707a36">Record</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379">Signed</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a02c86eb2792f3262c21d030a87e19793">Symbol</a>, and <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0aa1a914735b205424ba6c40b85528d78a">Unsigned</a>.</p>

<p class="reference">Referenced by <a class="el" href="_type_system_8cpp_source.html#l00253">getTypeQualifier()</a>.</p>
<div class="fragment"><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;                                              {</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    <a class="code" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> primitiveType;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743">isNumberType</a>(type)) {</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;        primitiveType = TypeAttribute::Signed;</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a5c4839a38da22a968ab01e81a67d793c">isUnsignedType</a>(type)) {</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;        primitiveType = TypeAttribute::Unsigned;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a1a7d8cb2f6a29f825e650a7c98487718">isFloatType</a>(type)) {</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        primitiveType = TypeAttribute::Float;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a34c8a82b8d9ed840b32e93186002d18c">isRecordType</a>(type)) {</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;        primitiveType = TypeAttribute::Record;</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b">isSymbolType</a>(type)) {</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        primitiveType = TypeAttribute::Symbol;</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown type class&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;        std::exit(EXIT_FAILURE);</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    }</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    <span class="keywordflow">return</span> primitiveType;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a5c4839a38da22a968ab01e81a67d793c"><div class="ttname"><a href="namespacesouffle.html#a5c4839a38da22a968ab01e81a67d793c">souffle::isUnsignedType</a></div><div class="ttdeci">bool isUnsignedType(const Type &amp;type)</div><div class="ttdoc">Determines whether the given type is a number type. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00347">TypeSystem.cpp:347</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4e502e6abb9a3e9a8e4c1168dbf23743"><div class="ttname"><a href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743">souffle::isNumberType</a></div><div class="ttdeci">bool isNumberType(const Type &amp;type)</div><div class="ttdoc">Determines whether the given type is a number type. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00339">TypeSystem.cpp:339</a></div></div>
<div class="ttc" id="namespacesouffle_html_a1a7d8cb2f6a29f825e650a7c98487718"><div class="ttname"><a href="namespacesouffle.html#a1a7d8cb2f6a29f825e650a7c98487718">souffle::isFloatType</a></div><div class="ttdeci">bool isFloatType(const Type &amp;type)</div><div class="ttdoc">Determines whether the given type is a float type. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00331">TypeSystem.cpp:331</a></div></div>
<div class="ttc" id="namespacesouffle_html_a34c8a82b8d9ed840b32e93186002d18c"><div class="ttname"><a href="namespacesouffle.html#a34c8a82b8d9ed840b32e93186002d18c">souffle::isRecordType</a></div><div class="ttdeci">bool isRecordType(const Type &amp;type)</div><div class="ttdoc">Determines whether the given type is a record type. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00363">TypeSystem.cpp:363</a></div></div>
<div class="ttc" id="namespacesouffle_html_af5361aa1e84030b37d7c8df1bf45e1c0"><div class="ttname"><a href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">souffle::TypeAttribute</a></div><div class="ttdeci">TypeAttribute</div><div class="ttdef"><b>Definition:</b> <a href="_ram_types_8h_source.html#l00028">RamTypes.h:28</a></div></div>
<div class="ttc" id="namespacesouffle_html_a11f6c352eec6bde7b5a0b143ffe64e3b"><div class="ttname"><a href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b">souffle::isSymbolType</a></div><div class="ttdeci">bool isSymbolType(const Type &amp;type)</div><div class="ttdoc">Determines whether the given type is a symbol type. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00355">TypeSystem.cpp:355</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_afe2ff9f374555126a532203710149346_cgraph.png" border="0" usemap="#namespacesouffle_afe2ff9f374555126a532203710149346_cgraph" alt=""/></div>
<map name="namespacesouffle_afe2ff9f374555126a532203710149346_cgraph" id="namespacesouffle_afe2ff9f374555126a532203710149346_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a1a7d8cb2f6a29f825e650a7c98487718" title="Determines whether the given type is a float type. " alt="" coords="251,213,397,239"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="241,61,407,87"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a34c8a82b8d9ed840b32e93186002d18c" title="Determines whether the given type is a record type. " alt="" coords="245,263,403,290"/>
<area shape="rect" id="node12" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="242,111,406,138"/>
<area shape="rect" id="node14" href="namespacesouffle.html#a5c4839a38da22a968ab01e81a67d793c" title="Determines whether the given type is a number type. " alt="" coords="236,162,412,189"/>
<area shape="rect" id="node3" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="460,137,707,163"/>
<area shape="rect" id="node4" href="classsouffle_1_1_type_environment.html#a5569e54d58b6ca69f1fffbdd77143545" title="souffle::TypeEnvironment\l::getFloatType" alt="" coords="490,253,677,295"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="755,137,880,163"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="951,107,1055,134"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="928,159,1079,200"/>
<area shape="rect" id="node8" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1127,166,1273,193"/>
<area shape="rect" id="node10" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="490,5,677,47"/>
<area shape="rect" id="node13" href="classsouffle_1_1_type_environment.html#a72fa419d33bf813f22efabec629a4627" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="490,71,677,112"/>
<area shape="rect" id="node15" href="classsouffle_1_1_type_environment.html#a0b191b7782e170a23b54f7ec347a32ab" title="souffle::TypeEnvironment\l::getUnsignedType" alt="" coords="490,188,677,229"/>
</map>
</div>

</div>
</div>
<a id="ab9ad723d37a06f19c0789053f63a3e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ad723d37a06f19c0789053f63a3e6b">&#9670;&nbsp;</a></span>getTypeAttributeAggregate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a> souffle::getTypeAttributeAggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">AggregateOp</a>&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get return type of the aggregate. </p>

<p class="definition">Definition at line <a class="el" href="_aggregate_op_8h_source.html#l00044">44</a> of file <a class="el" href="_aggregate_op_8h_source.html">AggregateOp.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a4905ac9d6a22bdfc1ae096094ce6248d">COUNT</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a22ae0e2b89e5e3d477f988cc36d3272b">Float</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1">FMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6">FMIN</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a0645fcc11b74dbdbf2d7501942fa6f6f">FSUM</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">MAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a4ea6d1161ea24d7599365f574aff6610">MEAN</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">MIN</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379">Signed</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a6970bdc2201030b9c03fbdcf3973858a">SUM</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059">UMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb">UMIN</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0aa1a914735b205424ba6c40b85528d78a">Unsigned</a>, and <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ae6246115490f016a4ecb2604ba5fc2ed">USUM</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, and <a class="el" href="_synthesiser_8cpp_source.html#l00172">souffle::Synthesiser::emitCode()</a>.</p>
<div class="fragment"><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;                                                                     {</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordflow">switch</span> (op) {</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        <span class="keywordflow">case</span> AggregateOp::COUNT:</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        <span class="keywordflow">case</span> AggregateOp::MAX:</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        <span class="keywordflow">case</span> AggregateOp::MIN:</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        <span class="keywordflow">case</span> AggregateOp::SUM:</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Signed;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        <span class="keywordflow">case</span> AggregateOp::MEAN:</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        <span class="keywordflow">case</span> AggregateOp::FMAX:</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        <span class="keywordflow">case</span> AggregateOp::FMIN:</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keywordflow">case</span> AggregateOp::FSUM:</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Float;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        <span class="keywordflow">case</span> AggregateOp::UMAX:</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        <span class="keywordflow">case</span> AggregateOp::UMIN:</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        <span class="keywordflow">case</span> AggregateOp::USUM:</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;            <span class="keywordflow">return</span> TypeAttribute::Unsigned;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    }</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;invalid argument&quot;</span>);</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    exit(EXIT_FAILURE);</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a0d6fe661fa54da7de4dccc65c8f82834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6fe661fa54da7de4dccc65c8f82834">&#9670;&nbsp;</a></span>getTypeQualifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::getTypeQualifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns full type qualifier for a given type. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00253">253</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a22ae0e2b89e5e3d477f988cc36d3272b">Float</a>, <a class="el" href="_type_system_8h_source.html#l00128">souffle::UnionType::getElementTypes()</a>, <a class="el" href="_type_system_8h_source.html#l00158">souffle::RecordType::getFields()</a>, <a class="el" href="_type_system_8h_source.html#l00047">souffle::Type::getName()</a>, <a class="el" href="_type_system_8h_source.html#l00485">getTypeAttribute()</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a6a0d9eaee314c567fd72fb97ee707a36">Record</a>, <a class="el" href="_type_system_8cpp_source.html#l00173">seen</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379">Signed</a>, <a class="el" href="json11_8h_source.html#l00650">str</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a02c86eb2792f3262c21d030a87e19793">Symbol</a>, <a class="el" href="_util_8h_source.html#l00793">toString()</a>, and <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0aa1a914735b205424ba6c40b85528d78a">Unsigned</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_translator_8cpp_source.html#l01699">souffle::AstTranslator::getRecordsTypes()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00100">souffle::AstTranslator::translateDirectives()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l01518">souffle::AstTranslator::translateProgram()</a>.</p>
<div class="fragment"><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;                                             {</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    <span class="keyword">struct </span>visitor : <span class="keyword">public</span> VisitOnceTypeVisitor&lt;std::string&gt; {</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        std::string visitUnionType(<span class="keyword">const</span> UnionType&amp; type)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            std::string <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a> = visitType(type);</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            str += <span class="stringliteral">&quot;[&quot;</span>;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            <span class="keywordtype">bool</span> first = <span class="keyword">true</span>;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> unionType : type.getElementTypes()) {</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;                <span class="keywordflow">if</span> (first) {</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                    first = <span class="keyword">false</span>;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;                } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                    str += <span class="stringliteral">&quot;,&quot;</span>;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                }</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                str += visit(*unionType);</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            }</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            str += <span class="stringliteral">&quot;]&quot;</span>;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        }</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;        std::string visitRecordType(<span class="keyword">const</span> RecordType&amp; type)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;            std::string str = visitType(type);</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;            str += <span class="stringliteral">&quot;{&quot;</span>;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;            <span class="keywordtype">bool</span> first = <span class="keyword">true</span>;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> field : type.getFields()) {</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                <span class="keywordflow">if</span> (first) {</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                    first = <span class="keyword">false</span>;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                    str += <span class="stringliteral">&quot;,&quot;</span>;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                }</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                str += field.name;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                str += <span class="stringliteral">&quot;#&quot;</span>;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                str += visit(field.type);</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;            }</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;            str += <span class="stringliteral">&quot;}&quot;</span>;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;        }</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        std::string visitType(<span class="keyword">const</span> Type&amp; type)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;            std::string <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>;</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;            <span class="keywordflow">switch</span> (<a class="code" href="namespacesouffle.html#afe2ff9f374555126a532203710149346">getTypeAttribute</a>(type)) {</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                <span class="keywordflow">case</span> TypeAttribute::Signed:</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                    str.append(<span class="stringliteral">&quot;i&quot;</span>);</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;                <span class="keywordflow">case</span> TypeAttribute::Unsigned:</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;                    str.append(<span class="stringliteral">&quot;u&quot;</span>);</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                <span class="keywordflow">case</span> TypeAttribute::Float:</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                    str.append(<span class="stringliteral">&quot;f&quot;</span>);</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                <span class="keywordflow">case</span> TypeAttribute::Symbol:</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                    str.append(<span class="stringliteral">&quot;s&quot;</span>);</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                <span class="keywordflow">case</span> TypeAttribute::Record:</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                    str.append(<span class="stringliteral">&quot;r&quot;</span>);</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;            }</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;            str.append(<span class="stringliteral">&quot;:&quot;</span>);</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            str.append(<a class="code" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">toString</a>(type.getName()));</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;            <a class="code" href="_type_system_8cpp.html#a157c8fc15ecc360f080bfd2d5d6ddbff">seen</a>[&amp;type] = <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        }</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    };</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <span class="keywordflow">return</span> visitor().visit(type);</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_aecc08c83ad9634fc515b7aa094702949"><div class="ttname"><a href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">souffle::toString</a></div><div class="ttdeci">const std::string &amp; toString(const std::string &amp;str)</div><div class="ttdoc">A generic function converting strings into strings (trivial case). </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00793">Util.h:793</a></div></div>
<div class="ttc" id="json11_8h_html_a25fda444d34d64acade61be6f9d35367"><div class="ttname"><a href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a></div><div class="ttdeci">const std::string &amp; str</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00650">json11.h:650</a></div></div>
<div class="ttc" id="_type_system_8cpp_html_a157c8fc15ecc360f080bfd2d5d6ddbff"><div class="ttname"><a href="_type_system_8cpp.html#a157c8fc15ecc360f080bfd2d5d6ddbff">seen</a></div><div class="ttdeci">std::map&lt; const Type *, R &gt; seen</div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00173">TypeSystem.cpp:173</a></div></div>
<div class="ttc" id="namespacesouffle_html_afe2ff9f374555126a532203710149346"><div class="ttname"><a href="namespacesouffle.html#afe2ff9f374555126a532203710149346">souffle::getTypeAttribute</a></div><div class="ttdeci">TypeAttribute getTypeAttribute(const T &amp;type)</div><div class="ttdoc">Convert a type analysis&amp;#39; type/set of type to the the TypeAttribute. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8h_source.html#l00485">TypeSystem.h:485</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a0d6fe661fa54da7de4dccc65c8f82834_cgraph.png" border="0" usemap="#namespacesouffle_a0d6fe661fa54da7de4dccc65c8f82834_cgraph" alt=""/></div>
<map name="namespacesouffle_a0d6fe661fa54da7de4dccc65c8f82834_cgraph" id="namespacesouffle_a0d6fe661fa54da7de4dccc65c8f82834_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_union_type.html#a0175bce933a70c1d3691114860ac17fc" title="souffle::UnionType\l::getElementTypes" alt="" coords="253,71,396,112"/>
<area shape="rect" id="node4" href="structsouffle_1_1_record_type.html#a338320267386a93ab482f1e25d50ef7a" title="souffle::RecordType\l::getFields" alt="" coords="251,5,399,47"/>
<area shape="rect" id="node5" href="classsouffle_1_1_type.html#a18ec0572ed2548e580166a4b51abde18" title="souffle::Type::getName" alt="" coords="239,137,411,163"/>
<area shape="rect" id="node6" href="namespacesouffle.html#afe2ff9f374555126a532203710149346" title="Convert a type analysis&#39; type/set of type to the the TypeAttribute. " alt="" coords="233,187,416,214"/>
<area shape="rect" id="node21" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949" title="A generic function converting strings into strings (trivial case). " alt="" coords="262,238,387,265"/>
<area shape="rect" id="node3" href="classsouffle_1_1_type.html#a00437c665d598367ff16229c823c728f" title="souffle::Type::print" alt="" coords="481,23,623,50"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a1a7d8cb2f6a29f825e650a7c98487718" title="Determines whether the given type is a float type. " alt="" coords="479,137,625,163"/>
<area shape="rect" id="node14" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="469,238,635,265"/>
<area shape="rect" id="node16" href="namespacesouffle.html#a34c8a82b8d9ed840b32e93186002d18c" title="Determines whether the given type is a record type. " alt="" coords="473,187,631,214"/>
<area shape="rect" id="node17" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="470,289,634,315"/>
<area shape="rect" id="node19" href="namespacesouffle.html#a5c4839a38da22a968ab01e81a67d793c" title="Determines whether the given type is a number type. " alt="" coords="464,86,640,113"/>
<area shape="rect" id="node8" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="688,187,935,214"/>
<area shape="rect" id="node9" href="classsouffle_1_1_type_environment.html#a5569e54d58b6ca69f1fffbdd77143545" title="souffle::TypeEnvironment\l::getFloatType" alt="" coords="718,121,905,163"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="983,187,1108,214"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1179,158,1283,185"/>
<area shape="rect" id="node12" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="1156,209,1307,251"/>
<area shape="rect" id="node13" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1355,217,1501,243"/>
<area shape="rect" id="node15" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="718,239,905,280"/>
<area shape="rect" id="node18" href="classsouffle_1_1_type_environment.html#a72fa419d33bf813f22efabec629a4627" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="718,304,905,345"/>
<area shape="rect" id="node20" href="classsouffle_1_1_type_environment.html#a0b191b7782e170a23b54f7ec347a32ab" title="souffle::TypeEnvironment\l::getUnsignedType" alt="" coords="718,56,905,97"/>
</map>
</div>

</div>
</div>
<a id="acd078c141c96076832b98038f39e4d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd078c141c96076832b98038f39e4d48">&#9670;&nbsp;</a></span>getVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const <a class="el" href="classsouffle_1_1_ast_variable.html">AstVariable</a> * &gt; souffle::getVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a list of all variables referenced within the AST rooted by the given root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be searched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of all variables referenced within </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00028">28</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>.</p>
<div class="fragment"><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;                                                                {</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <span class="comment">// simply collect the list of all variables by visiting all variables</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    std::vector&lt;const AstVariable*&gt; vars;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(root, [&amp;](<span class="keyword">const</span> AstVariable&amp; var) { vars.push_back(&amp;var); });</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <span class="keywordflow">return</span> vars;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_acd078c141c96076832b98038f39e4d48_cgraph.png" border="0" usemap="#namespacesouffle_acd078c141c96076832b98038f39e4d48_cgraph" alt=""/></div>
<map name="namespacesouffle_acd078c141c96076832b98038f39e4d48_cgraph" id="namespacesouffle_acd078c141c96076832b98038f39e4d48_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="208,13,376,39"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="424,5,592,47"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="640,5,831,47"/>
</map>
</div>

</div>
</div>
<a id="a2c1c5f7d59161b1c204ead73986cc0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1c5f7d59161b1c204ead73986cc0cf">&#9670;&nbsp;</a></span>hasBoundArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::hasBoundArgument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&#160;</td>
          <td class="paramname"><em>atom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;&#160;</td>
          <td class="paramname"><em>compositeBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00136">136</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_literal_8h_source.html#l00078">souffle::AstAtom::getArguments()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00115">isBoundArgument()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00470">getNextAtomNaiveSIPS()</a>.</p>
<div class="fragment"><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                                                                                            {</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="keywordflow">for</span> (AstArgument* arg : atom-&gt;getArguments()) {</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a5048549cddd623327a828a4cc90fe746">isBoundArgument</a>(arg, boundArgs, compositeBindings)) {</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        }</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    }</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a5048549cddd623327a828a4cc90fe746"><div class="ttname"><a href="namespacesouffle.html#a5048549cddd623327a828a4cc90fe746">souffle::isBoundArgument</a></div><div class="ttdeci">bool isBoundArgument(AstArgument *arg, const std::set&lt; std::string &gt; &amp;boundArgs, BindingStore &amp;compositeBindings)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00115">MagicSet.cpp:115</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a2c1c5f7d59161b1c204ead73986cc0cf_cgraph.png" border="0" usemap="#namespacesouffle_a2c1c5f7d59161b1c204ead73986cc0cf_cgraph" alt=""/></div>
<map name="namespacesouffle_a2c1c5f7d59161b1c204ead73986cc0cf_cgraph" id="namespacesouffle_a2c1c5f7d59161b1c204ead73986cc0cf_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="256,19,487,45"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a5048549cddd623327a828a4cc90fe746" title="souffle::isBoundArgument" alt="" coords="276,81,467,108"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="559,5,706,32"/>
<area shape="rect" id="node5" href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198" title="souffle::hasPrefix" alt="" coords="565,56,700,83"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a4d2a34e7c27740b381cf558eeebb28e4" title="souffle::isBoundComposite" alt="" coords="535,161,731,188"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333" title="souffle::contains" alt="" coords="823,103,953,129"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_variable.html#a2b73a95c7b59624d956dee0ed4e13884" title="souffle::AstVariable\l::getName" alt="" coords="814,154,962,195"/>
<area shape="rect" id="node10" href="classsouffle_1_1_binding_store.html#a9ce08dc8e33c130b291f57e9d72d0c78" title="souffle::BindingStore\l::getVariableDependencies" alt="" coords="790,219,986,261"/>
<area shape="rect" id="node11" href="classsouffle_1_1_binding_store.html#a0da8360ecba6d9b26e9d075a0b285740" title="souffle::BindingStore\l::addVariableBoundComposite" alt="" coords="779,285,997,326"/>
<area shape="rect" id="node9" href="namespacesouffle.html#aae135d2382a133fa5b036296fbd7f60a" title="souffle::isEqualAdornment" alt="" coords="1045,103,1239,129"/>
</map>
</div>

</div>
</div>
<a id="aae039656df27f6089ef34a0a4455dce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae039656df27f6089ef34a0a4455dce5">&#9670;&nbsp;</a></span>hasClauseWithAggregatedRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::hasClauseWithAggregatedRelation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&#160;</td>
          <td class="paramname"><em>aggRelation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *&amp;&#160;</td>
          <td class="paramname"><em>foundLiteral</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the given relation has any clauses which contain an aggregation over of a specific relation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>the relation to search the clauses of </td></tr>
    <tr><td class="paramname">aggRelation</td><td>the relation to search for in aggregations in clause bodies </td></tr>
    <tr><td class="paramname">program</td><td>the program containing the relations </td></tr>
    <tr><td class="paramname">foundLiteral</td><td>set to the literal found in an aggregation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00129">129</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_utils_8cpp_source.html#l00075">getAtomRelation()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00042">getClauses()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, and <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>.</p>
<div class="fragment"><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                                                                    {</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> AstClause* cl : <a class="code" href="namespacesouffle.html#a4ca5420316b1f3e64bc8f87a26a0c05c">getClauses</a>(*program, *<a class="code" href="_reader_8h.html#abd6f77243e31b9c48f104efeed27c546">relation</a>)) {</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        <span class="keywordtype">bool</span> hasAgg = <span class="keyword">false</span>;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(*cl, [&amp;](<span class="keyword">const</span> AstAggregator&amp; cur) {</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;            <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(cur, [&amp;](<span class="keyword">const</span> AstAtom&amp; atom) {</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                <span class="keywordflow">if</span> (aggRelation == <a class="code" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">getAtomRelation</a>(&amp;atom, program)) {</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                    foundLiteral = &amp;atom;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                    hasAgg = <span class="keyword">true</span>;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                }</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;            });</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        });</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        <span class="keywordflow">if</span> (hasAgg) {</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        }</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    }</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4ca5420316b1f3e64bc8f87a26a0c05c"><div class="ttname"><a href="namespacesouffle.html#a4ca5420316b1f3e64bc8f87a26a0c05c">souffle::getClauses</a></div><div class="ttdeci">std::vector&lt; AstClause * &gt; getClauses(const AstProgram &amp;program, const AstRelation &amp;rel)</div><div class="ttdoc">Returns a vector of clauses in the program describing the given relation. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00052">AstUtils.cpp:52</a></div></div>
<div class="ttc" id="_reader_8h_html_abd6f77243e31b9c48f104efeed27c546"><div class="ttname"><a href="_reader_8h.html#abd6f77243e31b9c48f104efeed27c546">relation</a></div><div class="ttdeci">Relation &amp; relation</div><div class="ttdef"><b>Definition:</b> <a href="_reader_8h_source.html#l00130">Reader.h:130</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab18cbb3adc2ab328de0db30a3fddf7e0"><div class="ttname"><a href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">souffle::getAtomRelation</a></div><div class="ttdeci">const AstRelation * getAtomRelation(const AstAtom *atom, const AstProgram *program)</div><div class="ttdoc">Returns the relation referenced by the given atom. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00075">AstUtils.cpp:75</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aae039656df27f6089ef34a0a4455dce5_cgraph.png" border="0" usemap="#namespacesouffle_aae039656df27f6089ef34a0a4455dce5_cgraph" alt=""/></div>
<map name="namespacesouffle_aae039656df27f6089ef34a0a4455dce5_cgraph" id="namespacesouffle_aae039656df27f6089ef34a0a4455dce5_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0" title="Returns the relation referenced by the given atom. " alt="" coords="300,64,483,91"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="318,129,465,156"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="307,184,475,211"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="531,13,787,40"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="585,64,733,91"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="878,5,982,32"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="855,57,1005,98"/>
<area shape="rect" id="node7" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1073,97,1220,124"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="855,122,1005,163"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="575,183,743,225"/>
<area shape="rect" id="node12" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="835,187,1025,229"/>
</map>
</div>

</div>
</div>
<a id="ab93b9d78c10c77c6d4ab227d5f9b389a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93b9d78c10c77c6d4ab227d5f9b389a">&#9670;&nbsp;</a></span>hasClauseWithNegatedRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::hasClauseWithNegatedRelation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> *&#160;</td>
          <td class="paramname"><em>negRelation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *&amp;&#160;</td>
          <td class="paramname"><em>foundLiteral</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the given relation has any clauses which contain a negation of a specific relation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>the relation to search the clauses of </td></tr>
    <tr><td class="paramname">negRelation</td><td>the relation to search for negations of in clause bodies </td></tr>
    <tr><td class="paramname">program</td><td>the program containing the relations </td></tr>
    <tr><td class="paramname">foundLiteral</td><td>set to the negation literal that was found </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00116">116</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_utils_8cpp_source.html#l00075">getAtomRelation()</a>, and <a class="el" href="_ast_utils_8cpp_source.html#l00042">getClauses()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, and <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>.</p>
<div class="fragment"><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;                                                                    {</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> AstClause* cl : <a class="code" href="namespacesouffle.html#a4ca5420316b1f3e64bc8f87a26a0c05c">getClauses</a>(*program, *<a class="code" href="_reader_8h.html#abd6f77243e31b9c48f104efeed27c546">relation</a>)) {</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* neg : getBodyLiterals&lt;AstNegation&gt;(*cl)) {</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;            <span class="keywordflow">if</span> (negRelation == <a class="code" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">getAtomRelation</a>(neg-&gt;getAtom(), program)) {</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                foundLiteral = neg;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;            }</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        }</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    }</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a4ca5420316b1f3e64bc8f87a26a0c05c"><div class="ttname"><a href="namespacesouffle.html#a4ca5420316b1f3e64bc8f87a26a0c05c">souffle::getClauses</a></div><div class="ttdeci">std::vector&lt; AstClause * &gt; getClauses(const AstProgram &amp;program, const AstRelation &amp;rel)</div><div class="ttdoc">Returns a vector of clauses in the program describing the given relation. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00052">AstUtils.cpp:52</a></div></div>
<div class="ttc" id="_reader_8h_html_abd6f77243e31b9c48f104efeed27c546"><div class="ttname"><a href="_reader_8h.html#abd6f77243e31b9c48f104efeed27c546">relation</a></div><div class="ttdeci">Relation &amp; relation</div><div class="ttdef"><b>Definition:</b> <a href="_reader_8h_source.html#l00130">Reader.h:130</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab18cbb3adc2ab328de0db30a3fddf7e0"><div class="ttname"><a href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0">souffle::getAtomRelation</a></div><div class="ttdeci">const AstRelation * getAtomRelation(const AstAtom *atom, const AstProgram *program)</div><div class="ttdoc">Returns the relation referenced by the given atom. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00075">AstUtils.cpp:75</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ab93b9d78c10c77c6d4ab227d5f9b389a_cgraph.png" border="0" usemap="#namespacesouffle_ab93b9d78c10c77c6d4ab227d5f9b389a_cgraph" alt=""/></div>
<map name="namespacesouffle_ab93b9d78c10c77c6d4ab227d5f9b389a_cgraph" id="namespacesouffle_ab93b9d78c10c77c6d4ab227d5f9b389a_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ab18cbb3adc2ab328de0db30a3fddf7e0" title="Returns the relation referenced by the given atom. " alt="" coords="280,64,463,91"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="298,121,445,148"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="511,13,767,40"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="565,64,713,91"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="838,5,942,32"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="815,57,965,98"/>
<area shape="rect" id="node7" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1013,97,1160,124"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="815,122,965,163"/>
</map>
</div>

</div>
</div>
<a id="a732d351e2af0d4c5578be62e979a8a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732d351e2af0d4c5578be62e979a8a32">&#9670;&nbsp;</a></span>hasFloatType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::hasFloatType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is any value in the set float. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00327">327</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l01010">any_of()</a>, <a class="el" href="_type_system_8h_source.html#l00213">souffle::TypeSet::isAll()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00331">isFloatType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_type_system_8h_source.html#l00513">isOrderableType()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l01253">souffle::PolymorphicObjectsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                                        {</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>.isAll() || <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(<a class="code" href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>, (<span class="keywordtype">bool</span> (*)(<span class="keyword">const</span> Type&amp;)) &amp; <a class="code" href="namespacesouffle.html#a2f74749ac26b7299879fe633fcdc105b">isFloatType</a>);</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;}</div><div class="ttc" id="_component_instantiation_transformer_8cpp_html_a769811c621f0af455fbefd863c0f1a0c"><div class="ttname"><a href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a></div><div class="ttdeci">std::vector&lt; std::unique_ptr&lt; AstType &gt; &gt; types</div><div class="ttdef"><b>Definition:</b> <a href="_component_instantiation_transformer_8cpp_source.html#l00046">ComponentInstantiationTransformer.cpp:46</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2f74749ac26b7299879fe633fcdc105b"><div class="ttname"><a href="namespacesouffle.html#a2f74749ac26b7299879fe633fcdc105b">souffle::isFloatType</a></div><div class="ttdeci">bool isFloatType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are float types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00335">TypeSystem.cpp:335</a></div></div>
<div class="ttc" id="namespacesouffle_html_a34f8eecb81c090fca9e58d3357b63ed9"><div class="ttname"><a href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">souffle::any_of</a></div><div class="ttdeci">bool any_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether any elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01010">Util.h:1010</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a732d351e2af0d4c5578be62e979a8a32_cgraph.png" border="0" usemap="#namespacesouffle_a732d351e2af0d4c5578be62e979a8a32_cgraph" alt=""/></div>
<map name="namespacesouffle_a732d351e2af0d4c5578be62e979a8a32_cgraph" id="namespacesouffle_a732d351e2af0d4c5578be62e979a8a32_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="233,5,352,32"/>
<area shape="rect" id="node3" href="structsouffle_1_1_type_set.html#ae26622401685d8ac9080b2f5a83d7eaa" title="Universality check. " alt="" coords="212,56,373,83"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a1a7d8cb2f6a29f825e650a7c98487718" title="Determines whether the given type is a float type. " alt="" coords="219,107,366,133"/>
<area shape="rect" id="node5" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="421,77,668,104"/>
<area shape="rect" id="node6" href="classsouffle_1_1_type_environment.html#a5569e54d58b6ca69f1fffbdd77143545" title="souffle::TypeEnvironment\l::getFloatType" alt="" coords="451,129,638,170"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="716,136,841,163"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="913,107,1017,133"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="889,158,1040,199"/>
<area shape="rect" id="node10" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1088,165,1235,192"/>
</map>
</div>

</div>
</div>
<a id="ae0c80a38e0b1c4617f373aba8d2c7198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c80a38e0b1c4617f373aba8d2c7198">&#9670;&nbsp;</a></span>hasPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::hasPrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00057">57</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00062">isAggRel()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00115">isBoundArgument()</a>, <a class="el" href="_magic_set_8cpp_source.html#l01017">replaceUnderscores()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;                                                              {</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>.substr(0, prefix.size()) == prefix;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;}</div><div class="ttc" id="json11_8h_html_a25fda444d34d64acade61be6f9d35367"><div class="ttname"><a href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a></div><div class="ttdeci">const std::string &amp; str</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00650">json11.h:650</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a31bb9767056b00fd49a4097b59cb07d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31bb9767056b00fd49a4097b59cb07d9">&#9670;&nbsp;</a></span>hasSignedType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::hasSignedType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is any value in the set signed. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00319">319</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l01010">any_of()</a>, <a class="el" href="_type_system_8h_source.html#l00213">souffle::TypeSet::isAll()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00339">isNumberType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_type_system_8h_source.html#l00513">isOrderableType()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l01253">souffle::PolymorphicObjectsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                                         {</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>.isAll() || <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(<a class="code" href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>, (<span class="keywordtype">bool</span> (*)(<span class="keyword">const</span> Type&amp;)) &amp; <a class="code" href="namespacesouffle.html#aae6c863e60901e130475672aff3942ac">isNumberType</a>);</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;}</div><div class="ttc" id="_component_instantiation_transformer_8cpp_html_a769811c621f0af455fbefd863c0f1a0c"><div class="ttname"><a href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a></div><div class="ttdeci">std::vector&lt; std::unique_ptr&lt; AstType &gt; &gt; types</div><div class="ttdef"><b>Definition:</b> <a href="_component_instantiation_transformer_8cpp_source.html#l00046">ComponentInstantiationTransformer.cpp:46</a></div></div>
<div class="ttc" id="namespacesouffle_html_aae6c863e60901e130475672aff3942ac"><div class="ttname"><a href="namespacesouffle.html#aae6c863e60901e130475672aff3942ac">souffle::isNumberType</a></div><div class="ttdeci">bool isNumberType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are number types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00343">TypeSystem.cpp:343</a></div></div>
<div class="ttc" id="namespacesouffle_html_a34f8eecb81c090fca9e58d3357b63ed9"><div class="ttname"><a href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">souffle::any_of</a></div><div class="ttdeci">bool any_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether any elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01010">Util.h:1010</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a31bb9767056b00fd49a4097b59cb07d9_cgraph.png" border="0" usemap="#namespacesouffle_a31bb9767056b00fd49a4097b59cb07d9_cgraph" alt=""/></div>
<map name="namespacesouffle_a31bb9767056b00fd49a4097b59cb07d9_cgraph" id="namespacesouffle_a31bb9767056b00fd49a4097b59cb07d9_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="248,5,367,32"/>
<area shape="rect" id="node3" href="structsouffle_1_1_type_set.html#ae26622401685d8ac9080b2f5a83d7eaa" title="Universality check. " alt="" coords="227,56,388,83"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="224,107,391,133"/>
<area shape="rect" id="node5" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="439,77,685,104"/>
<area shape="rect" id="node6" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="469,129,655,170"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="733,136,859,163"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="930,107,1034,133"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="907,158,1057,199"/>
<area shape="rect" id="node10" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1105,165,1252,192"/>
</map>
</div>

</div>
</div>
<a id="a2c77d8cc2a9414cd6aeb5d02c74e162d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c77d8cc2a9414cd6aeb5d02c74e162d">&#9670;&nbsp;</a></span>hasUnnamedVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool souffle::hasUnnamedVariable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00402">402</a> of file <a class="el" href="_ast_semantic_checker_8cpp_source.html">AstSemanticChecker.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l01010">any_of()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00629">souffle::AstSemanticChecker::checkClause()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00449">souffle::AstSemanticChecker::checkLiteral()</a>, and <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00429">hasUnnamedVariable()</a>.</p>
<div class="fragment"><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                                                       {</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="keywordflow">if</span> (dynamic_cast&lt;const AstUnnamedVariable*&gt;(arg) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    }</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    <span class="keywordflow">if</span> (dynamic_cast&lt;const AstVariable*&gt;(arg) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    }</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    <span class="keywordflow">if</span> (dynamic_cast&lt;const AstConstant*&gt;(arg) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    }</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    <span class="keywordflow">if</span> (dynamic_cast&lt;const AstCounter*&gt;(arg) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    }</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* cast = dynamic_cast&lt;const AstTypeCast*&gt;(arg)) {</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>(cast-&gt;getValue());</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    }</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* term = dynamic_cast&lt;const AstTerm*&gt;(arg)) {</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(term-&gt;getArguments(), <a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>);</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    }</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    <span class="keywordflow">if</span> (dynamic_cast&lt;const AstAggregator*&gt;(arg) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    }</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Unsupported Argument type: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(*arg).name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported Argument Type!&quot;</span>);</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_abb328ce61aedddf363f53be8e445a8e0"><div class="ttname"><a href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">souffle::hasUnnamedVariable</a></div><div class="ttdeci">static bool hasUnnamedVariable(const AstLiteral *lit)</div><div class="ttdef"><b>Definition:</b> <a href="_ast_semantic_checker_8cpp_source.html#l00429">AstSemanticChecker.cpp:429</a></div></div>
<div class="ttc" id="namespacesouffle_html_a34f8eecb81c090fca9e58d3357b63ed9"><div class="ttname"><a href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">souffle::any_of</a></div><div class="ttdeci">bool any_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether any elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01010">Util.h:1010</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a2c77d8cc2a9414cd6aeb5d02c74e162d_cgraph.png" border="0" usemap="#namespacesouffle_a2c77d8cc2a9414cd6aeb5d02c74e162d_cgraph" alt=""/></div>
<map name="namespacesouffle_a2c77d8cc2a9414cd6aeb5d02c74e162d_cgraph" id="namespacesouffle_a2c77d8cc2a9414cd6aeb5d02c74e162d_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="267,5,385,32"/>
</map>
</div>

</div>
</div>
<a id="abb328ce61aedddf363f53be8e445a8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb328ce61aedddf363f53be8e445a8e0">&#9670;&nbsp;</a></span>hasUnnamedVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool souffle::hasUnnamedVariable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *&#160;</td>
          <td class="paramname"><em>lit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00429">429</a> of file <a class="el" href="_ast_semantic_checker_8cpp_source.html">AstSemanticChecker.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l01010">any_of()</a>, and <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00402">hasUnnamedVariable()</a>.</p>
<div class="fragment"><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;                                                      {</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* at = dynamic_cast&lt;const AstAtom*&gt;(lit)) {</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(at-&gt;getArguments(), (bool (*)(<span class="keyword">const</span> AstArgument*))<a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>);</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    }</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* neg = dynamic_cast&lt;const AstNegation*&gt;(lit)) {</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>(neg-&gt;getAtom());</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    }</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    <span class="keywordflow">if</span> (dynamic_cast&lt;const AstConstraint*&gt;(lit) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;        <span class="keywordflow">if</span> (dynamic_cast&lt;const AstBooleanConstraint*&gt;(lit) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        }</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* br = dynamic_cast&lt;const AstBinaryConstraint*&gt;(lit)) {</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>(br-&gt;getLHS()) || <a class="code" href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">hasUnnamedVariable</a>(br-&gt;getRHS());</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        }</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    }</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Unsupported Literal type: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(lit).name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported Argument Type!&quot;</span>);</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_abb328ce61aedddf363f53be8e445a8e0"><div class="ttname"><a href="namespacesouffle.html#abb328ce61aedddf363f53be8e445a8e0">souffle::hasUnnamedVariable</a></div><div class="ttdeci">static bool hasUnnamedVariable(const AstLiteral *lit)</div><div class="ttdef"><b>Definition:</b> <a href="_ast_semantic_checker_8cpp_source.html#l00429">AstSemanticChecker.cpp:429</a></div></div>
<div class="ttc" id="namespacesouffle_html_a34f8eecb81c090fca9e58d3357b63ed9"><div class="ttname"><a href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">souffle::any_of</a></div><div class="ttdeci">bool any_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether any elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01010">Util.h:1010</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_abb328ce61aedddf363f53be8e445a8e0_cgraph.png" border="0" usemap="#namespacesouffle_abb328ce61aedddf363f53be8e445a8e0_cgraph" alt=""/></div>
<map name="namespacesouffle_abb328ce61aedddf363f53be8e445a8e0_cgraph" id="namespacesouffle_abb328ce61aedddf363f53be8e445a8e0_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="528,5,647,32"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a2c77d8cc2a9414cd6aeb5d02c74e162d" title="souffle::hasUnnamedVariable" alt="" coords="267,31,480,57"/>
</map>
</div>

</div>
</div>
<a id="a40316bc7e86831e18498b814b5af7fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40316bc7e86831e18498b814b5af7fbc">&#9670;&nbsp;</a></span>hasUnsignedType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::hasUnsignedType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is any value in the set unsigned. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00323">323</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l01010">any_of()</a>, <a class="el" href="_type_system_8h_source.html#l00213">souffle::TypeSet::isAll()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00347">isUnsignedType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_type_system_8h_source.html#l00513">isOrderableType()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l01253">souffle::PolymorphicObjectsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                                           {</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>.isAll() || <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(<a class="code" href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a>, (<span class="keywordtype">bool</span> (*)(<span class="keyword">const</span> Type&amp;)) &amp; <a class="code" href="namespacesouffle.html#a3b4bd063028ddb747c726ca9fa04f85e">isUnsignedType</a>);</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;}</div><div class="ttc" id="_component_instantiation_transformer_8cpp_html_a769811c621f0af455fbefd863c0f1a0c"><div class="ttname"><a href="_component_instantiation_transformer_8cpp.html#a769811c621f0af455fbefd863c0f1a0c">types</a></div><div class="ttdeci">std::vector&lt; std::unique_ptr&lt; AstType &gt; &gt; types</div><div class="ttdef"><b>Definition:</b> <a href="_component_instantiation_transformer_8cpp_source.html#l00046">ComponentInstantiationTransformer.cpp:46</a></div></div>
<div class="ttc" id="namespacesouffle_html_a34f8eecb81c090fca9e58d3357b63ed9"><div class="ttname"><a href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">souffle::any_of</a></div><div class="ttdeci">bool any_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether any elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01010">Util.h:1010</a></div></div>
<div class="ttc" id="namespacesouffle_html_a3b4bd063028ddb747c726ca9fa04f85e"><div class="ttname"><a href="namespacesouffle.html#a3b4bd063028ddb747c726ca9fa04f85e">souffle::isUnsignedType</a></div><div class="ttdeci">bool isUnsignedType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are number types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00351">TypeSystem.cpp:351</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a40316bc7e86831e18498b814b5af7fbc_cgraph.png" border="0" usemap="#namespacesouffle_a40316bc7e86831e18498b814b5af7fbc_cgraph" alt=""/></div>
<map name="namespacesouffle_a40316bc7e86831e18498b814b5af7fbc_cgraph" id="namespacesouffle_a40316bc7e86831e18498b814b5af7fbc_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="270,5,389,32"/>
<area shape="rect" id="node3" href="structsouffle_1_1_type_set.html#ae26622401685d8ac9080b2f5a83d7eaa" title="Universality check. " alt="" coords="249,56,410,83"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a5c4839a38da22a968ab01e81a67d793c" title="Determines whether the given type is a number type. " alt="" coords="241,107,417,133"/>
<area shape="rect" id="node5" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="465,77,712,104"/>
<area shape="rect" id="node6" href="classsouffle_1_1_type_environment.html#a0b191b7782e170a23b54f7ec347a32ab" title="souffle::TypeEnvironment\l::getUnsignedType" alt="" coords="495,129,682,170"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="760,136,885,163"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="957,107,1061,133"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="933,158,1084,199"/>
<area shape="rect" id="node10" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1132,165,1279,192"/>
</map>
</div>

</div>
</div>
<a id="ad0e8debde5608979e041dd30e044612a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e8debde5608979e041dd30e044612a">&#9670;&nbsp;</a></span>identifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::identifier </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Valid C++ identifier, note that this does not ensure the uniqueness of identifiers returned. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01307">1307</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ram_expression_8h_source.html#l00219">souffle::RamTupleElement::clone()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00273">souffle::MakeIndexTransformer::constructPattern()</a>, <a class="el" href="_synthesiser_8cpp_source.html#l00172">souffle::Synthesiser::emitCode()</a>, <a class="el" href="_ram_operation_8h_source.html#l00149">souffle::RamTupleOperation::equal()</a>, <a class="el" href="_ram_expression_8h_source.html#l00228">souffle::RamTupleElement::equal()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00249">souffle::MakeIndexTransformer::getExpression()</a>, <a class="el" href="_ram_transforms_8h_source.html#l00353">souffle::MakeIndexTransformer::getName()</a>, <a class="el" href="_ram_operation_8h_source.html#l00135">souffle::RamTupleOperation::getTupleId()</a>, <a class="el" href="_ram_expression_8h_source.html#l00210">souffle::RamTupleElement::getTupleId()</a>, <a class="el" href="main_8cpp_source.html#l00124">main()</a>, <a class="el" href="_ram_expression_8h_source.html#l00224">souffle::RamTupleElement::print()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00316">souffle::MakeIndexTransformer::rewriteAggregate()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00355">souffle::MakeIndexTransformer::rewriteIndexScan()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00545">souffle::ChoiceConversionTransformer::rewriteIndexScan()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00335">souffle::MakeIndexTransformer::rewriteScan()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00512">souffle::ChoiceConversionTransformer::rewriteScan()</a>, and <a class="el" href="_ram_operation_8h_source.html#l00140">souffle::RamTupleOperation::setTupleId()</a>.</p>
<div class="fragment"><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;                                          {</div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; <span class="keywordtype">id</span>.length(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;        <span class="keywordflow">if</span> (((isalpha(<span class="keywordtype">id</span>[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>]) == 0) &amp;&amp; i == 0) || ((isalnum(<span class="keywordtype">id</span>[i]) == 0) &amp;&amp; <span class="keywordtype">id</span>[i] != <span class="charliteral">&#39;_&#39;</span>)) {</div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;            <span class="keywordtype">id</span>[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>] = <span class="charliteral">&#39;_&#39;</span>;</div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;        }</div><div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;    }</div><div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;    <span class="keywordflow">return</span> id;</div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3c6cb3ac93eb86027865121aff551fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6cb3ac93eb86027865121aff551fde">&#9670;&nbsp;</a></span>identifierToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string souffle::identifierToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper functions. </p>

<p class="definition">Definition at line <a class="el" href="_provenance_transformer_8cpp_source.html#l00048">48</a> of file <a class="el" href="_provenance_transformer_8cpp_source.html">ProvenanceTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_tui_8h_source.html#l00319">souffle::profile::ss</a>.</p>

<p class="reference">Referenced by <a class="el" href="_provenance_transformer_8cpp_source.html#l00065">makeInfoRelation()</a>, and <a class="el" href="_provenance_transformer_8cpp_source.html#l00054">makeRelationName()</a>.</p>
<div class="fragment"><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                                                                 {</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    std::stringstream <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a>;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    ss &lt;&lt; name;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="keywordflow">return</span> ss.str();</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;}</div><div class="ttc" id="namespacesouffle_1_1profile_html_a6b765acdf677f188e059ac9860c5046d"><div class="ttname"><a href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">souffle::profile::ss</a></div><div class="ttdeci">class souffle::profile::Tui ss</div><div class="ttdef"><b>Definition:</b> <a href="_tui_8h_source.html#l00319">Tui.h:319</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7dfca9e9addfda4f3e1ee38cbef0d7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dfca9e9addfda4f3e1ee38cbef0d7c0">&#9670;&nbsp;</a></span>inlineBodyLiterals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt;<a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a>*&gt;, std::vector&lt;<a class="el" href="classsouffle_1_1_ast_binary_constraint.html">AstBinaryConstraint</a>*&gt; &gt; souffle::inlineBodyLiterals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&#160;</td>
          <td class="paramname"><em>atom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td>
          <td class="paramname"><em>atomInlineClause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inlines the given atom based on a given clause. </p>
<p>Returns the vector of replacement literals and the necessary constraints. If unification is unsuccessful, the vector of literals is marked as invalid. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00281">281</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_clause_8h_source.html#l00203">souffle::AstClause::apply()</a>, <a class="el" href="_ast_clause_8h_source.html#l00190">souffle::AstClause::clone()</a>, <a class="el" href="_ast_constraint_analysis_8h_source.html#l00132">constraints</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="_ast_clause_8h_source.html#l00171">souffle::AstClause::getBodyLiterals()</a>, <a class="el" href="_ast_clause_8h_source.html#l00166">souffle::AstClause::getHead()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00057">souffle::NullableVector&lt; T &gt;::getVector()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00053">souffle::NullableVector&lt; T &gt;::isValid()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00255">unifyAtoms()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00422">formNegatedLiterals()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00787">getInlinedLiteral()</a>.</p>
<div class="fragment"><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                                                    {</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    std::vector&lt;AstLiteral*&gt; addedLits;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    std::vector&lt;AstBinaryConstraint*&gt; <a class="code" href="_ast_constraint_analysis_8h.html#a4551a78b0ee37ec3710ad8cda752cf2e">constraints</a>;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    <span class="comment">// Rename the variables in the inlined clause to avoid conflicts when unifying multiple atoms</span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    <span class="comment">// - particularly when an inlined relation appears twice in a clause.</span></div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">int</span> inlineCount = 0;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    <span class="comment">// Make a temporary clone so we can rename variables without fear</span></div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    AstClause* atomClause = atomInlineClause-&gt;clone();</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    <span class="keyword">struct </span>VariableRenamer : <span class="keyword">public</span> AstNodeMapper {</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        <span class="keywordtype">int</span> varnum;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        VariableRenamer(<span class="keywordtype">int</span> varnum) : varnum(varnum) {}</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;        std::unique_ptr&lt;AstNode&gt; operator()(std::unique_ptr&lt;AstNode&gt; node)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">auto</span>* var = dynamic_cast&lt;AstVariable*&gt;(node.get())) {</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                <span class="comment">// Rename the variable</span></div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                <span class="keyword">auto</span> newVar = std::unique_ptr&lt;AstVariable&gt;(var-&gt;clone());</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                std::stringstream newName;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                newName &lt;&lt; <span class="stringliteral">&quot;&lt;inlined_&quot;</span> &lt;&lt; var-&gt;getName() &lt;&lt; <span class="stringliteral">&quot;_&quot;</span> &lt;&lt; varnum &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span>;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                newVar-&gt;setName(newName.str());</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                <span class="keywordflow">return</span> newVar;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;            }</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;            <span class="keywordflow">return</span> node;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        }</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    };</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    VariableRenamer update(inlineCount);</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    atomClause-&gt;apply(update);</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    inlineCount++;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <span class="comment">// Get the constraints needed to unify the two atoms</span></div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    NullableVector&lt;std::pair&lt;AstArgument*, AstArgument*&gt;&gt; res = <a class="code" href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d">unifyAtoms</a>(atomClause-&gt;getHead(), atom);</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    <span class="keywordflow">if</span> (res.isValid()) {</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;        <span class="keywordflow">for</span> (std::pair&lt;AstArgument*, AstArgument*&gt; pair : res.getVector()) {</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;            <span class="comment">// FIXME: float equiv (`FEQ`)</span></div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;            constraints.push_back(<span class="keyword">new</span> AstBinaryConstraint(BinaryConstraintOp::EQ,</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                    std::unique_ptr&lt;AstArgument&gt;(pair.first-&gt;clone()),</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                    std::unique_ptr&lt;AstArgument&gt;(pair.second-&gt;clone())));</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        }</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        <span class="comment">// Add in the body of the current clause of the inlined atom</span></div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        <span class="keywordflow">for</span> (AstLiteral* lit : atomClause-&gt;getBodyLiterals()) {</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;            addedLits.push_back(lit-&gt;clone());</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;        }</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    }</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="keyword">delete</span> atomClause;</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="keywordflow">if</span> (changed) {</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        <span class="keywordflow">return</span> std::make_pair(NullableVector&lt;AstLiteral*&gt;(addedLits), constraints);</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        <span class="keywordflow">return</span> std::make_pair(NullableVector&lt;AstLiteral*&gt;(), constraints);</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    }</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_ab66c00257a9f4ce44653d82cee9c563d"><div class="ttname"><a href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d">souffle::unifyAtoms</a></div><div class="ttdeci">NullableVector&lt; std::pair&lt; AstArgument *, AstArgument * &gt; &gt; unifyAtoms(AstAtom *first, AstAtom *second)</div><div class="ttdoc">Returns the nullable vector of substitutions needed to unify the two given atoms. ...</div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00255">InlineRelationsTransformer.cpp:255</a></div></div>
<div class="ttc" id="_ast_constraint_analysis_8h_html_a4551a78b0ee37ec3710ad8cda752cf2e"><div class="ttname"><a href="_ast_constraint_analysis_8h.html#a4551a78b0ee37ec3710ad8cda752cf2e">constraints</a></div><div class="ttdeci">Problem&lt; AnalysisVar &gt; constraints</div><div class="ttdoc">The list of constraints making underlying this analysis. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_constraint_analysis_8h_source.html#l00132">AstConstraintAnalysis.h:132</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a7dfca9e9addfda4f3e1ee38cbef0d7c0_cgraph.png" border="0" usemap="#namespacesouffle_a7dfca9e9addfda4f3e1ee38cbef0d7c0_cgraph" alt=""/></div>
<map name="namespacesouffle_a7dfca9e9addfda4f3e1ee38cbef0d7c0_cgraph" id="namespacesouffle_a7dfca9e9addfda4f3e1ee38cbef0d7c0_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_clause.html#ab7a5b630d02cd69873aab066c2bd9c46" title="Apply the mapper to all child nodes. " alt="" coords="259,166,398,208"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Create a clone (i.e. " alt="" coords="1020,689,1159,730"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="490,114,629,156"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="259,334,398,376"/>
<area shape="rect" id="node9" href="classsouffle_1_1_nullable_vector.html#ad94b793fbfe9e5d0175becd240539fbc" title="souffle::NullableVector\l::getVector" alt="" coords="244,400,413,441"/>
<area shape="rect" id="node25" href="classsouffle_1_1_nullable_vector.html#ab04c65c2ed18c2756c463c50de1912e8" title="souffle::NullableVector\l::isValid" alt="" coords="1285,354,1455,396"/>
<area shape="rect" id="node36" href="namespacesouffle.html#ab66c00257a9f4ce44653d82cee9c563d" title="Returns the nullable vector of substitutions needed to unify the two given atoms. ..." alt="" coords="254,536,403,563"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="1763,638,1963,664"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="1315,536,1425,563"/>
<area shape="rect" id="node7" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1543,103,1689,130"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a25b07f1c5efea50145140a31f755e0d1" title="Tries to perform a single step of inlining on the given literal. " alt="" coords="469,283,649,310"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a2e5ef82376f71d4d7ebfcfa64437d540" title="Forms the bodies that will replace the negation of a given inlined atom. " alt="" coords="705,284,913,311"/>
<area shape="rect" id="node19" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="1016,70,1163,96"/>
<area shape="rect" id="node22" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="1015,131,1163,158"/>
<area shape="rect" id="node26" href="namespacesouffle.html#aeddc699418d426e1ffcb965e37ccb3a2" title="Returns a vector of arguments that should replace the given argument after one step of inlining..." alt="" coords="988,536,1191,563"/>
<area shape="rect" id="node33" href="namespacesouffle.html#a8ae2dc0fd43bd8abb26027c3f2f448d1" title="Returns a vector of atoms that should replace the given atom after one step of inlining. " alt="" coords="722,411,897,438"/>
<area shape="rect" id="node35" href="classsouffle_1_1_ast_relation.html#a698481c4da3f71880cb2cf8c622a9cdc" title="check for a relation qualifier " alt="" coords="735,168,883,209"/>
<area shape="rect" id="node12" href="namespacesouffle.html#a0e3e2145b6ac09dba3c7ba2e5535935f" title="Return the negated version of a disjunction of conjunctions. " alt="" coords="973,232,1206,259"/>
<area shape="rect" id="node21" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="961,334,1217,360"/>
<area shape="rect" id="node13" href="namespacesouffle.html#a72ca390c0235d50be215fdc25bb24e4d" title="Returns the negated version of a given literal. " alt="" coords="1290,299,1450,326"/>
<area shape="rect" id="node14" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Create a clone (i.e. " alt="" coords="1529,414,1703,440"/>
<area shape="rect" id="node16" href="classsouffle_1_1_ast_constraint.html#a4bc070302396ff2bee073f62c00b5e21" title="Create a clone (i.e. " alt="" coords="1535,321,1697,362"/>
<area shape="rect" id="node17" href="namespacesouffle.html#a4a2b4fc7558b8bce98ff88f8e10b516e" title="Negate an ast constraint. " alt="" coords="1523,270,1709,296"/>
<area shape="rect" id="node15" href="classsouffle_1_1_ast_atom.html#acef18129b13ce45477044717ded051d2" title="souffle::AstAtom::AstAtom" alt="" coords="1766,414,1961,440"/>
<area shape="rect" id="node18" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="1757,270,1969,296"/>
<area shape="rect" id="node20" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="1295,62,1445,104"/>
<area shape="rect" id="node23" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1318,194,1422,220"/>
<area shape="rect" id="node24" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="1295,128,1445,169"/>
<area shape="rect" id="node27" href="namespacesouffle.html#a42c2f399b871f8fe7f0ba652812e2db5" title="souffle::combineAggregators" alt="" coords="1265,587,1475,614"/>
<area shape="rect" id="node31" href="classsouffle_1_1_ast_aggregator.html#a427d81a0d8eb9c03d0ab86ef3ef78d5d" title="souffle::AstAggregator\l::setBody" alt="" coords="1287,420,1453,461"/>
<area shape="rect" id="node32" href="classsouffle_1_1_ast_node.html#a0b664297f0971c6ce32ff2e0e4f2603f" title="Set source location for the AstNode. " alt="" coords="1271,486,1469,512"/>
<area shape="rect" id="node28" href="namespacesouffle.html#a1193e67992e4f0591e4011faccb4abe2" title="Checks whether a functor operation can have a given argument count. " alt="" coords="1525,521,1707,562"/>
<area shape="rect" id="node29" href="namespacesouffle.html#af790a6a39a388c256d64af7140f3a961" title="Renames all variables in a given argument uniquely. " alt="" coords="1524,587,1708,614"/>
<area shape="rect" id="node30" href="classsouffle_1_1_ast_node.html#ad7c4f8ce0322749e72ed60f543c6fd93" title="Apply the mapper to all child nodes. " alt="" coords="1777,587,1950,614"/>
<area shape="rect" id="node34" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="974,384,1205,411"/>
<area shape="rect" id="node37" href="namespacesouffle.html#a659ae2c89cfab47908f27a660f82c147" title="Reduces a vector of substitutions. " alt="" coords="461,638,657,664"/>
<area shape="rect" id="node38" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828" title="A generic factory for constraints of the form. " alt="" coords="761,638,858,664"/>
</map>
</div>

</div>
</div>
<a id="ac79a8035af8360fb110ee30292d9280d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79a8035af8360fb110ee30292d9280d">&#9670;&nbsp;</a></span>isAggRel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isAggRel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00062">62</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_qualified_name_8h_source.html#l00061">souffle::AstQualifiedName::getQualifiers()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00057">hasPrefix()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;                                           {</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <span class="comment">// TODO (azreika): this covers too much (e.g. user-defined __agg_rel_x)</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="comment">//                 need a way to determine if created by aggregates</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198">hasPrefix</a>(rel.getQualifiers()[0], <span class="stringliteral">&quot;__agg_rel_&quot;</span>);</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_ae0c80a38e0b1c4617f373aba8d2c7198"><div class="ttname"><a href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198">souffle::hasPrefix</a></div><div class="ttdeci">bool hasPrefix(const std::string &amp;str, const std::string &amp;prefix)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00057">MagicSet.cpp:57</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ac79a8035af8360fb110ee30292d9280d_cgraph.png" border="0" usemap="#namespacesouffle_ac79a8035af8360fb110ee30292d9280d_cgraph" alt=""/></div>
<map name="namespacesouffle_ac79a8035af8360fb110ee30292d9280d_cgraph" id="namespacesouffle_ac79a8035af8360fb110ee30292d9280d_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_qualified_name.html#a4b36798d8506689de4ec2794f4777bfa" title="get qualifiers " alt="" coords="184,5,376,47"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198" title="souffle::hasPrefix" alt="" coords="213,71,347,98"/>
</map>
</div>

</div>
</div>
<a id="a01f8bfe9b5546db6b9c75d4c5b968d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f8bfe9b5546db6b9c75d4c5b968d74">&#9670;&nbsp;</a></span>isBindingConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isBindingConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>boundArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00147">147</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_magic_set_8cpp_source.html#l00083">getString()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00695">souffle::Adornment::run()</a>.</p>
<div class="fragment"><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                                                                                          {</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    std::string lhs_name = <a class="code" href="namespacesouffle.html#a526256b2f4d593cceb8b73068e7de882">getString</a>(<a class="code" href="_resolve_aliases_transformer_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>);</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    std::string rhs_name = <a class="code" href="namespacesouffle.html#a526256b2f4d593cceb8b73068e7de882">getString</a>(<a class="code" href="_resolve_aliases_transformer_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a>);</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <span class="comment">// only want to check variables we have not bound yet</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <span class="keywordflow">if</span> ((dynamic_cast&lt;AstVariable*&gt;(<a class="code" href="_resolve_aliases_transformer_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>) != <span class="keyword">nullptr</span>) &amp;&amp; (boundArgs.find(lhs_name) == boundArgs.end())) {</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        <span class="comment">// return true if the rhs is a bound variable or a constant</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        <span class="keywordflow">if</span> ((dynamic_cast&lt;AstVariable*&gt;(<a class="code" href="_resolve_aliases_transformer_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a>) != <span class="keyword">nullptr</span>) &amp;&amp; (boundArgs.find(rhs_name) != boundArgs.end())) {</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;AstConstant*&gt;(<a class="code" href="_resolve_aliases_transformer_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a>) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        }</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    }</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a526256b2f4d593cceb8b73068e7de882"><div class="ttname"><a href="namespacesouffle.html#a526256b2f4d593cceb8b73068e7de882">souffle::getString</a></div><div class="ttdeci">std::string getString(const AstArgument *arg)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00083">MagicSet.cpp:83</a></div></div>
<div class="ttc" id="_resolve_aliases_transformer_8cpp_html_a99d7476d0087a8405f52a79852efa6eb"><div class="ttname"><a href="_resolve_aliases_transformer_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; rhs</div><div class="ttdef"><b>Definition:</b> <a href="_resolve_aliases_transformer_8cpp_source.html#l00161">ResolveAliasesTransformer.cpp:161</a></div></div>
<div class="ttc" id="_resolve_aliases_transformer_8cpp_html_aae193eebe112e754a082b152fb272018"><div class="ttname"><a href="_resolve_aliases_transformer_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; lhs</div><div class="ttdef"><b>Definition:</b> <a href="_resolve_aliases_transformer_8cpp_source.html#l00160">ResolveAliasesTransformer.cpp:160</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a01f8bfe9b5546db6b9c75d4c5b968d74_cgraph.png" border="0" usemap="#namespacesouffle_a01f8bfe9b5546db6b9c75d4c5b968d74_cgraph" alt=""/></div>
<map name="namespacesouffle_a01f8bfe9b5546db6b9c75d4c5b968d74_cgraph" id="namespacesouffle_a01f8bfe9b5546db6b9c75d4c5b968d74_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a526256b2f4d593cceb8b73068e7de882" title="souffle::getString" alt="" coords="255,5,388,32"/>
</map>
</div>

</div>
</div>
<a id="a5048549cddd623327a828a4cc90fe746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5048549cddd623327a828a4cc90fe746">&#9670;&nbsp;</a></span>isBoundArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isBoundArgument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;&#160;</td>
          <td class="paramname"><em>compositeBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00115">115</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_magic_set_8cpp_source.html#l00046">contains()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00057">hasPrefix()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00090">isBoundComposite()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00444">bindArguments()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00511">getNextAtomMaxBoundSIPS()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00546">getNextAtomMaxRatioSIPS()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00136">hasBoundArgument()</a>.</p>
<div class="fragment"><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                                                                                               {</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span>* var = dynamic_cast&lt;AstVariable*&gt;(arg)) {</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        std::string variableName = var-&gt;getName();</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198">hasPrefix</a>(variableName, <span class="stringliteral">&quot;+functor&quot;</span>) || <a class="code" href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198">hasPrefix</a>(variableName, <span class="stringliteral">&quot;+record&quot;</span>)) {</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a4d2a34e7c27740b381cf558eeebb28e4">isBoundComposite</a>(var, boundArgs, compositeBindings)) {</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;            }</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        }</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">contains</a>(boundArgs, variableName)) {</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;  <span class="comment">// found a bound argument, so can stop</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        }</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;incomplete checks (MST)&quot;</span>);</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    }</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a8a825f62e860ca448e7e16ab1a3a4333"><div class="ttname"><a href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">souffle::contains</a></div><div class="ttdeci">bool contains(std::set&lt; AdornedPredicate &gt; adornedPredicates, const AstQualifiedName &amp;atomName, const std::string &amp;atomAdornment)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00046">MagicSet.cpp:46</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4d2a34e7c27740b381cf558eeebb28e4"><div class="ttname"><a href="namespacesouffle.html#a4d2a34e7c27740b381cf558eeebb28e4">souffle::isBoundComposite</a></div><div class="ttdeci">bool isBoundComposite(const AstVariable *compositeVariable, const std::set&lt; std::string &gt; &amp;boundArgs, BindingStore &amp;compositeBindings)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00090">MagicSet.cpp:90</a></div></div>
<div class="ttc" id="namespacesouffle_html_ae0c80a38e0b1c4617f373aba8d2c7198"><div class="ttname"><a href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198">souffle::hasPrefix</a></div><div class="ttdeci">bool hasPrefix(const std::string &amp;str, const std::string &amp;prefix)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00057">MagicSet.cpp:57</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a5048549cddd623327a828a4cc90fe746_cgraph.png" border="0" usemap="#namespacesouffle_a5048549cddd623327a828a4cc90fe746_cgraph" alt=""/></div>
<map name="namespacesouffle_a5048549cddd623327a828a4cc90fe746_cgraph" id="namespacesouffle_a5048549cddd623327a828a4cc90fe746_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333" title="souffle::contains" alt="" coords="533,5,662,32"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198" title="souffle::hasPrefix" alt="" coords="275,56,409,83"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a4d2a34e7c27740b381cf558eeebb28e4" title="souffle::isBoundComposite" alt="" coords="244,107,440,133"/>
<area shape="rect" id="node3" href="namespacesouffle.html#aae135d2382a133fa5b036296fbd7f60a" title="souffle::isEqualAdornment" alt="" coords="755,5,948,32"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_variable.html#a2b73a95c7b59624d956dee0ed4e13884" title="souffle::AstVariable\l::getName" alt="" coords="523,57,671,98"/>
<area shape="rect" id="node7" href="classsouffle_1_1_binding_store.html#a9ce08dc8e33c130b291f57e9d72d0c78" title="souffle::BindingStore\l::getVariableDependencies" alt="" coords="499,122,695,163"/>
<area shape="rect" id="node8" href="classsouffle_1_1_binding_store.html#a0da8360ecba6d9b26e9d075a0b285740" title="souffle::BindingStore\l::addVariableBoundComposite" alt="" coords="488,187,707,229"/>
</map>
</div>

</div>
</div>
<a id="a4d2a34e7c27740b381cf558eeebb28e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2a34e7c27740b381cf558eeebb28e4">&#9670;&nbsp;</a></span>isBoundComposite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isBoundComposite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_variable.html">AstVariable</a> *&#160;</td>
          <td class="paramname"><em>compositeVariable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_binding_store.html">BindingStore</a> &amp;&#160;</td>
          <td class="paramname"><em>compositeBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00090">90</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_magic_set_8h_source.html#l00157">souffle::BindingStore::addVariableBoundComposite()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00046">contains()</a>, <a class="el" href="_ast_argument_8h_source.html#l00052">souffle::AstVariable::getName()</a>, and <a class="el" href="_magic_set_8h_source.html#l00144">souffle::BindingStore::getVariableDependencies()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00115">isBoundArgument()</a>.</p>
<div class="fragment"><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;                                         {</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    std::string variableName = compositeVariable-&gt;getName();</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">contains</a>(boundArgs, variableName)) {</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    }</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="keywordtype">bool</span> bound = <span class="keyword">true</span>;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="comment">// a composite argument is bound iff all its subvariables are bound</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="keyword">auto</span> dependencies = compositeBindings.getVariableDependencies(variableName);</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::string&amp; var : dependencies) {</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">contains</a>(boundArgs, var)) {</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            bound = <span class="keyword">false</span>;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        }</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    }</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keywordflow">if</span> (bound) {</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        <span class="comment">// composite variable bound only because its constituent variables are bound</span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        compositeBindings.addVariableBoundComposite(variableName);</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    }</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="keywordflow">return</span> bound;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a8a825f62e860ca448e7e16ab1a3a4333"><div class="ttname"><a href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333">souffle::contains</a></div><div class="ttdeci">bool contains(std::set&lt; AdornedPredicate &gt; adornedPredicates, const AstQualifiedName &amp;atomName, const std::string &amp;atomAdornment)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00046">MagicSet.cpp:46</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a4d2a34e7c27740b381cf558eeebb28e4_cgraph.png" border="0" usemap="#namespacesouffle_a4d2a34e7c27740b381cf558eeebb28e4_cgraph" alt=""/></div>
<map name="namespacesouffle_a4d2a34e7c27740b381cf558eeebb28e4_cgraph" id="namespacesouffle_a4d2a34e7c27740b381cf558eeebb28e4_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_binding_store.html#a0da8360ecba6d9b26e9d075a0b285740" title="souffle::BindingStore\l::addVariableBoundComposite" alt="" coords="249,5,468,47"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a8a825f62e860ca448e7e16ab1a3a4333" title="souffle::contains" alt="" coords="294,71,423,98"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_variable.html#a2b73a95c7b59624d956dee0ed4e13884" title="souffle::AstVariable\l::getName" alt="" coords="285,123,433,164"/>
<area shape="rect" id="node6" href="classsouffle_1_1_binding_store.html#a9ce08dc8e33c130b291f57e9d72d0c78" title="souffle::BindingStore\l::getVariableDependencies" alt="" coords="261,188,457,229"/>
<area shape="rect" id="node4" href="namespacesouffle.html#aae135d2382a133fa5b036296fbd7f60a" title="souffle::isEqualAdornment" alt="" coords="516,71,709,98"/>
</map>
</div>

</div>
</div>
<a id="a2d324369b5fc672d6cde86cb6c20e304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d324369b5fc672d6cde86cb6c20e304">&#9670;&nbsp;</a></span>isConstantArithExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool souffle::isConstantArithExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> &amp;&#160;</td>
          <td class="paramname"><em>argument</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00566">566</a> of file <a class="el" href="_ast_semantic_checker_8cpp_source.html">AstSemanticChecker.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00996">all_of()</a>, and <a class="el" href="_ram_types_8h_source.html#l00061">isNumericType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00582">souffle::AstSemanticChecker::checkConstant()</a>.</p>
<div class="fragment"><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;                                                             {</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;    <span class="keywordflow">if</span> (dynamic_cast&lt;const AstNumericConstant*&gt;(&amp;argument) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;    }</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* functor = dynamic_cast&lt;const AstIntrinsicFunctor*&gt;(&amp;argument)) {</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;        <span class="comment">// Check return type.</span></div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#aa91abe89b1490abcc00848fc5d9daf3a">isNumericType</a>(functor-&gt;getReturnType())) {</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;        }</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;        <span class="comment">// Check arguments</span></div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">all_of</a>(functor-&gt;getArguments(), [](<span class="keyword">auto</span>* arg) { <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a2d324369b5fc672d6cde86cb6c20e304">isConstantArithExpr</a>(*arg); });</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;    }</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a14b5f9eb9ec09c40e558b242e75de872"><div class="ttname"><a href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">souffle::all_of</a></div><div class="ttdeci">bool all_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether all elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00996">Util.h:996</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2d324369b5fc672d6cde86cb6c20e304"><div class="ttname"><a href="namespacesouffle.html#a2d324369b5fc672d6cde86cb6c20e304">souffle::isConstantArithExpr</a></div><div class="ttdeci">static bool isConstantArithExpr(const AstArgument &amp;argument)</div><div class="ttdef"><b>Definition:</b> <a href="_ast_semantic_checker_8cpp_source.html#l00566">AstSemanticChecker.cpp:566</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa91abe89b1490abcc00848fc5d9daf3a"><div class="ttname"><a href="namespacesouffle.html#aa91abe89b1490abcc00848fc5d9daf3a">souffle::isNumericType</a></div><div class="ttdeci">bool isNumericType(TypeAttribute ramType)</div><div class="ttdoc">Check if type is numeric. </div><div class="ttdef"><b>Definition:</b> <a href="_ram_types_8h_source.html#l00061">RamTypes.h:61</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a2d324369b5fc672d6cde86cb6c20e304_cgraph.png" border="0" usemap="#namespacesouffle_a2d324369b5fc672d6cde86cb6c20e304_cgraph" alt=""/></div>
<map name="namespacesouffle_a2d324369b5fc672d6cde86cb6c20e304_cgraph" id="namespacesouffle_a2d324369b5fc672d6cde86cb6c20e304_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872" title="A generic test checking whether all elements within a container satisfy a certain predicate..." alt="" coords="286,5,397,32"/>
<area shape="rect" id="node3" href="namespacesouffle.html#aa91abe89b1490abcc00848fc5d9daf3a" title="Check if type is numeric. " alt="" coords="256,56,427,83"/>
</map>
</div>

</div>
</div>
<a id="a6befeedfd76433e1bd51a1f6cd42afec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6befeedfd76433e1bd51a1f6cd42afec">&#9670;&nbsp;</a></span>isEqConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isEqConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a>&#160;</td>
          <td class="paramname"><em>constraintOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_binary_constraint_ops_8h_source.html#l00061">61</a> of file <a class="el" href="_binary_constraint_ops_8h_source.html">BinaryConstraintOps.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, and <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa123e958001611b441dab45ff11ba98a">FEQ</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_transforms_8cpp_source.html#l01455">souffle::FoldAnonymousRecords::expandRecordBinaryConstraint()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l01566">souffle::ResolveAnonymousRecordsAliases::findVariablesRecordMapping()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00249">souffle::MakeIndexTransformer::getExpression()</a>, <a class="el" href="_ast_ground_analysis_8cpp_source.html#l00148">getGroundedTerms()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l01417">souffle::FoldAnonymousRecords::isValidRecordConstraint()</a>, <a class="el" href="_resolve_aliases_transformer_8cpp_source.html#l00339">souffle::ResolveAliasesTransformer::removeTrivialEquality()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l01650">souffle::ResolveAnonymousRecordsAliases::replaceUnnamedVariable()</a>, <a class="el" href="_resolve_aliases_transformer_8cpp_source.html#l00202">souffle::ResolveAliasesTransformer::resolveAliases()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00695">souffle::Adornment::run()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l01489">souffle::FoldAnonymousRecords::transformClause()</a>.</p>
<div class="fragment"><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                                                                  {</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <span class="keywordflow">switch</span> (constraintOp) {</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::EQ:</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FEQ:</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    }</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aae135d2382a133fa5b036296fbd7f60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae135d2382a133fa5b036296fbd7f60a">&#9670;&nbsp;</a></span>isEqualAdornment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isEqualAdornment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>pred1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>adorn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>pred2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>adorn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00040">40</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00046">contains()</a>.</p>
<div class="fragment"><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;                                 {</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <span class="keywordflow">return</span> ((pred1 == pred2) &amp;&amp; (adorn1 == adorn2));</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a64753e143a37bb9414121fc75987cb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64753e143a37bb9414121fc75987cb14">&#9670;&nbsp;</a></span>isExecutable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isExecutable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a given file exists and it is an executable. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01084">1084</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="main_8cpp_source.html#l00063">executeBinary()</a>, and <a class="el" href="main_8cpp_source.html#l00124">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;                                                {</div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">existFile</a>(name) &amp;&amp; (access(name.c_str(), X_OK) == 0);</div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a69107e934a60222580ee8ba6882dc3d3"><div class="ttname"><a href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">souffle::existFile</a></div><div class="ttdeci">bool existFile(const std::string &amp;name)</div><div class="ttdoc">Check whether a file exists in the file system. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01058">Util.h:1058</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae4b6e248ec714e64f38ce032caf5f477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b6e248ec714e64f38ce032caf5f477">&#9670;&nbsp;</a></span>isFact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isFact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the given clause is a fact. </p>
<dl class="section return"><dt>Returns</dt><dd>true iff the clause is a fact </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00159">159</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_clause_8h_source.html#l00171">souffle::AstClause::getBodyLiterals()</a>, <a class="el" href="_ast_clause_8h_source.html#l00166">souffle::AstClause::getHead()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00629">souffle::AstSemanticChecker::checkClause()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00610">souffle::AstSemanticChecker::checkFact()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00096">getClauseNum()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00175">isRule()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00079">souffle::RemoveRelationCopiesTransformer::removeRelationCopies()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00695">souffle::Adornment::run()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00899">separateDBs()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l01118">souffle::NormaliseConstraintsTransformer::transform()</a>, <a class="el" href="_provenance_transformer_8cpp_source.html#l00387">souffle::ProvenanceTransformer::transformMaxHeight()</a>, <a class="el" href="_provenance_transformer_8cpp_source.html#l00249">souffle::ProvenanceTransformer::transformSubtreeHeights()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l00704">souffle::AstTranslator::ClauseTranslator::translateClause()</a>.</p>
<div class="fragment"><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                                     {</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    <span class="comment">// there must be a head</span></div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    <span class="keywordflow">if</span> (clause.getHead() == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    }</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    <span class="comment">// there must not be any body clauses</span></div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    <span class="keywordflow">if</span> (!clause.getBodyLiterals().empty()) {</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    }</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    <span class="comment">// and there are no aggregates</span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="keywordtype">bool</span> hasAggregates = <span class="keyword">false</span>;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(*clause.getHead(), [&amp;](<span class="keyword">const</span> AstAggregator&amp;) { hasAggregates = <span class="keyword">true</span>; });</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    <span class="keywordflow">return</span> !hasAggregates;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ae4b6e248ec714e64f38ce032caf5f477_cgraph.png" border="0" usemap="#namespacesouffle_ae4b6e248ec714e64f38ce032caf5f477_cgraph" alt=""/></div>
<map name="namespacesouffle_ae4b6e248ec714e64f38ce032caf5f477_cgraph" id="namespacesouffle_ae4b6e248ec714e64f38ce032caf5f477_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="179,5,317,47"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="179,71,317,112"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="164,137,332,163"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="391,13,537,39"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="380,129,548,171"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="596,129,787,171"/>
</map>
</div>

</div>
</div>
<a id="a1a7d8cb2f6a29f825e650a7c98487718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7d8cb2f6a29f825e650a7c98487718">&#9670;&nbsp;</a></span>isFloatType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isFloatType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given type is a float type. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00331">331</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_type_system_8h_source.html#l00392">souffle::TypeEnvironment::getFloatType()</a>, and <a class="el" href="_type_system_8h_source.html#l00051">souffle::Type::getTypeEnvironment()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_type_system_8h_source.html#l00464">eqTypeTypeAttribute()</a>, <a class="el" href="_type_system_8h_source.html#l00485">getTypeAttribute()</a>, <a class="el" href="_type_system_8cpp_source.html#l00327">hasFloatType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00335">isFloatType()</a>, <a class="el" href="_type_system_8h_source.html#l00508">isNumericType()</a>, <a class="el" href="_type_system_8h_source.html#l00513">isOrderableType()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l01253">souffle::PolymorphicObjectsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                                   {</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="keywordflow">return</span> isOfRootType(type, type.getTypeEnvironment().getFloatType());</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a1a7d8cb2f6a29f825e650a7c98487718_cgraph.png" border="0" usemap="#namespacesouffle_a1a7d8cb2f6a29f825e650a7c98487718_cgraph" alt=""/></div>
<map name="namespacesouffle_a1a7d8cb2f6a29f825e650a7c98487718_cgraph" id="namespacesouffle_a1a7d8cb2f6a29f825e650a7c98487718_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_type_environment.html#a5569e54d58b6ca69f1fffbdd77143545" title="souffle::TypeEnvironment\l::getFloatType" alt="" coords="230,27,417,69"/>
<area shape="rect" id="node7" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="200,93,447,120"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="495,35,620,61"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="691,5,795,32"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="668,57,819,98"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="867,64,1013,91"/>
</map>
</div>

</div>
</div>
<a id="a2f74749ac26b7299879fe633fcdc105b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f74749ac26b7299879fe633fcdc105b">&#9670;&nbsp;</a></span>isFloatType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isFloatType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether all the types in the given set are float types. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00335">335</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00996">all_of()</a>, <a class="el" href="_type_system_8h_source.html#l00208">souffle::TypeSet::empty()</a>, <a class="el" href="_type_system_8h_source.html#l00213">souffle::TypeSet::isAll()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00331">isFloatType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                                   {</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    <span class="keywordflow">return</span> !s.empty() &amp;&amp; !s.isAll() &amp;&amp; <a class="code" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">all_of</a>(s, (<span class="keywordtype">bool</span> (*)(<span class="keyword">const</span> Type&amp;)) &amp; <a class="code" href="namespacesouffle.html#a2f74749ac26b7299879fe633fcdc105b">isFloatType</a>);</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a2f74749ac26b7299879fe633fcdc105b"><div class="ttname"><a href="namespacesouffle.html#a2f74749ac26b7299879fe633fcdc105b">souffle::isFloatType</a></div><div class="ttdeci">bool isFloatType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are float types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00335">TypeSystem.cpp:335</a></div></div>
<div class="ttc" id="namespacesouffle_html_a14b5f9eb9ec09c40e558b242e75de872"><div class="ttname"><a href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">souffle::all_of</a></div><div class="ttdeci">bool all_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether all elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00996">Util.h:996</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a2f74749ac26b7299879fe633fcdc105b_cgraph.png" border="0" usemap="#namespacesouffle_a2f74749ac26b7299879fe633fcdc105b_cgraph" alt=""/></div>
<map name="namespacesouffle_a2f74749ac26b7299879fe633fcdc105b_cgraph" id="namespacesouffle_a2f74749ac26b7299879fe633fcdc105b_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872" title="A generic test checking whether all elements within a container satisfy a certain predicate..." alt="" coords="232,5,343,32"/>
<area shape="rect" id="node3" href="structsouffle_1_1_type_set.html#a2110dea550ae2c1eaf6ef65e2854f925" title="Emptiness check. " alt="" coords="200,56,375,83"/>
<area shape="rect" id="node4" href="structsouffle_1_1_type_set.html#ae26622401685d8ac9080b2f5a83d7eaa" title="Universality check. " alt="" coords="207,107,368,133"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a1a7d8cb2f6a29f825e650a7c98487718" title="Determines whether the given type is a float type. " alt="" coords="214,157,361,184"/>
<area shape="rect" id="node6" href="classsouffle_1_1_type_environment.html#a5569e54d58b6ca69f1fffbdd77143545" title="souffle::TypeEnvironment\l::getFloatType" alt="" coords="453,121,639,162"/>
<area shape="rect" id="node11" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="423,187,669,213"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="717,128,843,155"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="914,99,1018,125"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="891,150,1041,191"/>
<area shape="rect" id="node10" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1089,157,1236,184"/>
</map>
</div>

</div>
</div>
<a id="a8b1d652d2d52b327b057b11fd0eb1331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1d652d2d52b327b057b11fd0eb1331">&#9670;&nbsp;</a></span>isInfixFunctorOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isInfixFunctorOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a>&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a functor should be written using infix notation (e.g. </p>
<p><code>a + b + c</code>) or prefix notation (e.g. <code>+(a,b,c)</code>) </p>

<p class="definition">Definition at line <a class="el" href="_functor_ops_8h_source.html#l00598">598</a> of file <a class="el" href="_functor_ops_8h_source.html">FunctorOps.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9eeb52badb613229884838847294b90d">ADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aa8a5bbeedca093b94b7f0d3f185b98f7">BAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0adf6aac232504c55ea4202e09498bfd">BOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a88d973d6a866ababf2fb28a6112f8d46">BSHIFT_L</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9e74511ce5c138f374559a76abb6e209">BSHIFT_R</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3fdb4dd3e2677523449a3747923d4401">BSHIFT_R_UNSIGNED</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a21506bac4ecfbfe4272b9bf8185446b6">BXOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a29bbf66f7f8529ec47e394fb5a36c646">DIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc2cbacfa7c4ef9bc72773ebdd9fe166">FADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9abccb2b7436e0cbfb334fe07304fe28a6">FDIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a107c7a3cc48a0fe27d435e82c8679ef0">FEXP</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a26a83f923754f1e7aa12640b8bcca29a">FMUL</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a06be1058e817f781f4e0f0641f436247">FSUB</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a479a809c0b6eaaefd3b1df16f976df06">LAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ad3335c358811cfc353257e21b1d38229">LOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac5a28f4b35a2884fa3277150ac5d0967">MOD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2cdf52a55876063ec93b7d18bc741f6c">MUL</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a241dd841abade20fcb27b8a9f494e1eb">SUB</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a1f0002abde2c29615d914ab0228c68d3">UADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ab5755f546c5f5ca6a3f1720ef8e642ef">UBAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4803dabeb7190f48195a26654eafaa42">UBOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a653789f2eb8bfa402c5f60ceceac247b">UBSHIFT_L</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aab623d5679ac1cc907cb363e2d51eb14">UBSHIFT_R</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a07da89f09f961f63a15696ac57bbc1c3">UBSHIFT_R_UNSIGNED</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a70f4367aed9601f37bfbdd4586b327df">UBXOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a56d5c96c848631ef14e1f2a6e0f15d49">UDIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a59407eef1229dea3aac5dc8d77d06c92">UEXP</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3d0f34d8e784f8a48332424dd598a27a">ULAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9addb2113545b6bd7fbe64ed7bff507964">ULOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4bbe00e945b01d43cb7edecf51b0de5c">UMOD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ae89690f1278cca1400678daaa4a6a3b7">UMUL</a>, and <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9af8aba91736be4bad67181a8cce032337">USUB</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ram_expression_8h_source.html#l00113">souffle::RamIntrinsicOperator::print()</a>, and <a class="el" href="_ast_argument_8h_source.html#l00318">souffle::AstIntrinsicFunctor::print()</a>.</p>
<div class="fragment"><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;                                                 {</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    <span class="keywordflow">switch</span> (op) {</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ADD:</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FADD:</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UADD:</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SUB:</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;        <span class="keywordflow">case</span> FunctorOp::USUB:</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FSUB:</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MUL:</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FMUL:</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMUL:</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;        <span class="keywordflow">case</span> FunctorOp::DIV:</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FDIV:</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UDIV:</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;        <span class="keywordflow">case</span> FunctorOp::EXP:</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FEXP:</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UEXP:</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BAND:</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBAND:</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BOR:</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBOR:</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BXOR:</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_L:</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBSHIFT_L:</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_R:</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBSHIFT_R:</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_R_UNSIGNED:</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBSHIFT_R_UNSIGNED:</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBXOR:</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LAND:</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ULAND:</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LOR:</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ULOR:</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MOD:</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMOD:</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;    }</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a56909036ae0514924e306d0a1a180837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56909036ae0514924e306d0a1a180837">&#9670;&nbsp;</a></span>isNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isNumber </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a string is a sequence of digits. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00275">275</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_explain_provenance_impl_8h_source.html#l00327">souffle::ExplainProvenanceImpl::explainNegation()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00261">souffle::ExplainProvenanceImpl::explainNegationGetVariables()</a>, and <a class="el" href="main_8cpp_source.html#l00124">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                                      {</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a> == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    }</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    <span class="keywordflow">while</span> (*<a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a> != 0) {</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;        <span class="keywordflow">if</span> (isdigit(*<a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>) == 0) {</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        }</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>++;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    }</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;}</div><div class="ttc" id="json11_8h_html_a25fda444d34d64acade61be6f9d35367"><div class="ttname"><a href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a></div><div class="ttdeci">const std::string &amp; str</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00650">json11.h:650</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4e502e6abb9a3e9a8e4c1168dbf23743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e502e6abb9a3e9a8e4c1168dbf23743">&#9670;&nbsp;</a></span>isNumberType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isNumberType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given type is a number type. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00339">339</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_type_system_8h_source.html#l00384">souffle::TypeEnvironment::getNumberType()</a>, and <a class="el" href="_type_system_8h_source.html#l00051">souffle::Type::getTypeEnvironment()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_type_system_8h_source.html#l00464">eqTypeTypeAttribute()</a>, <a class="el" href="_type_system_8h_source.html#l00485">getTypeAttribute()</a>, <a class="el" href="_type_system_8cpp_source.html#l00319">hasSignedType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00343">isNumberType()</a>, <a class="el" href="_type_system_8h_source.html#l00508">isNumericType()</a>, <a class="el" href="_type_system_8h_source.html#l00513">isOrderableType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00401">isSubtypeOf()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l00224">souffle::MaterializeAggregationQueriesTransformer::materializeAggregationQueries()</a>.</p>
<div class="fragment"><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;                                    {</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="keywordflow">return</span> isOfRootType(type, type.getTypeEnvironment().getNumberType());</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a4e502e6abb9a3e9a8e4c1168dbf23743_cgraph.png" border="0" usemap="#namespacesouffle_a4e502e6abb9a3e9a8e4c1168dbf23743_cgraph" alt=""/></div>
<map name="namespacesouffle_a4e502e6abb9a3e9a8e4c1168dbf23743_cgraph" id="namespacesouffle_a4e502e6abb9a3e9a8e4c1168dbf23743_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="250,27,437,69"/>
<area shape="rect" id="node7" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="220,93,467,120"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="515,35,640,61"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="711,5,815,32"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="688,57,839,98"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="887,64,1033,91"/>
</map>
</div>

</div>
</div>
<a id="aae6c863e60901e130475672aff3942ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6c863e60901e130475672aff3942ac">&#9670;&nbsp;</a></span>isNumberType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isNumberType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether all the types in the given set are number types. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00343">343</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00996">all_of()</a>, <a class="el" href="_type_system_8h_source.html#l00208">souffle::TypeSet::empty()</a>, <a class="el" href="_type_system_8h_source.html#l00213">souffle::TypeSet::isAll()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00339">isNumberType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                                    {</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <span class="keywordflow">return</span> !s.empty() &amp;&amp; !s.isAll() &amp;&amp; <a class="code" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">all_of</a>(s, (<span class="keywordtype">bool</span> (*)(<span class="keyword">const</span> Type&amp;)) &amp; <a class="code" href="namespacesouffle.html#aae6c863e60901e130475672aff3942ac">isNumberType</a>);</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_aae6c863e60901e130475672aff3942ac"><div class="ttname"><a href="namespacesouffle.html#aae6c863e60901e130475672aff3942ac">souffle::isNumberType</a></div><div class="ttdeci">bool isNumberType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are number types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00343">TypeSystem.cpp:343</a></div></div>
<div class="ttc" id="namespacesouffle_html_a14b5f9eb9ec09c40e558b242e75de872"><div class="ttname"><a href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">souffle::all_of</a></div><div class="ttdeci">bool all_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether all elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00996">Util.h:996</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aae6c863e60901e130475672aff3942ac_cgraph.png" border="0" usemap="#namespacesouffle_aae6c863e60901e130475672aff3942ac_cgraph" alt=""/></div>
<map name="namespacesouffle_aae6c863e60901e130475672aff3942ac_cgraph" id="namespacesouffle_aae6c863e60901e130475672aff3942ac_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872" title="A generic test checking whether all elements within a container satisfy a certain predicate..." alt="" coords="252,5,363,32"/>
<area shape="rect" id="node3" href="structsouffle_1_1_type_set.html#a2110dea550ae2c1eaf6ef65e2854f925" title="Emptiness check. " alt="" coords="220,56,395,83"/>
<area shape="rect" id="node4" href="structsouffle_1_1_type_set.html#ae26622401685d8ac9080b2f5a83d7eaa" title="Universality check. " alt="" coords="227,107,388,133"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="224,157,391,184"/>
<area shape="rect" id="node6" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="473,121,659,162"/>
<area shape="rect" id="node11" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="443,187,689,213"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="737,128,863,155"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="934,99,1038,125"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="911,150,1061,191"/>
<area shape="rect" id="node10" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1109,157,1256,184"/>
</map>
</div>

</div>
</div>
<a id="aa91abe89b1490abcc00848fc5d9daf3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91abe89b1490abcc00848fc5d9daf3a">&#9670;&nbsp;</a></span>isNumericType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isNumericType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a>&#160;</td>
          <td class="paramname"><em>ramType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if type is numeric. </p>

<p class="definition">Definition at line <a class="el" href="_ram_types_8h_source.html#l00061">61</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a22ae0e2b89e5e3d477f988cc36d3272b">Float</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a6a0d9eaee314c567fd72fb97ee707a36">Record</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379">Signed</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a02c86eb2792f3262c21d030a87e19793">Symbol</a>, and <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0aa1a914735b205424ba6c40b85528d78a">Unsigned</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00566">isConstantArithExpr()</a>, and <a class="el" href="_type_system_8h_source.html#l00513">isOrderableType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                                                 {</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <span class="keywordflow">switch</span> (ramType) {</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        <span class="keywordflow">case</span> TypeAttribute::Signed:</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keywordflow">case</span> TypeAttribute::Unsigned:</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        <span class="keywordflow">case</span> TypeAttribute::Float:</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        <span class="keywordflow">case</span> TypeAttribute::Symbol:</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        <span class="keywordflow">case</span> TypeAttribute::Record:</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    }</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;  <span class="comment">// silence warning</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aef21c7dc86fd4e9cc7ecf88e4f5c34a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef21c7dc86fd4e9cc7ecf88e4f5c34a0">&#9670;&nbsp;</a></span>isNumericType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isNumericType </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the type is numeric. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8h_source.html#l00508">508</a> of file <a class="el" href="_type_system_8h_source.html">TypeSystem.h</a>.</p>

<p class="reference">References <a class="el" href="_type_system_8cpp_source.html#l00331">isFloatType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00339">isNumberType()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00347">isUnsignedType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;                                         {</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a1a7d8cb2f6a29f825e650a7c98487718">isFloatType</a>(type) || <a class="code" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743">isNumberType</a>(type) || <a class="code" href="namespacesouffle.html#a5c4839a38da22a968ab01e81a67d793c">isUnsignedType</a>(type);</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a5c4839a38da22a968ab01e81a67d793c"><div class="ttname"><a href="namespacesouffle.html#a5c4839a38da22a968ab01e81a67d793c">souffle::isUnsignedType</a></div><div class="ttdeci">bool isUnsignedType(const Type &amp;type)</div><div class="ttdoc">Determines whether the given type is a number type. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00347">TypeSystem.cpp:347</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4e502e6abb9a3e9a8e4c1168dbf23743"><div class="ttname"><a href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743">souffle::isNumberType</a></div><div class="ttdeci">bool isNumberType(const Type &amp;type)</div><div class="ttdoc">Determines whether the given type is a number type. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00339">TypeSystem.cpp:339</a></div></div>
<div class="ttc" id="namespacesouffle_html_a1a7d8cb2f6a29f825e650a7c98487718"><div class="ttname"><a href="namespacesouffle.html#a1a7d8cb2f6a29f825e650a7c98487718">souffle::isFloatType</a></div><div class="ttdeci">bool isFloatType(const Type &amp;type)</div><div class="ttdoc">Determines whether the given type is a float type. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00331">TypeSystem.cpp:331</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aef21c7dc86fd4e9cc7ecf88e4f5c34a0_cgraph.png" border="0" usemap="#namespacesouffle_aef21c7dc86fd4e9cc7ecf88e4f5c34a0_cgraph" alt=""/></div>
<map name="namespacesouffle_aef21c7dc86fd4e9cc7ecf88e4f5c34a0_cgraph" id="namespacesouffle_aef21c7dc86fd4e9cc7ecf88e4f5c34a0_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a1a7d8cb2f6a29f825e650a7c98487718" title="Determines whether the given type is a float type. " alt="" coords="239,61,385,87"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="229,111,395,138"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a5c4839a38da22a968ab01e81a67d793c" title="Determines whether the given type is a number type. " alt="" coords="224,162,400,189"/>
<area shape="rect" id="node3" href="classsouffle_1_1_type_environment.html#a5569e54d58b6ca69f1fffbdd77143545" title="souffle::TypeEnvironment\l::getFloatType" alt="" coords="478,5,665,47"/>
<area shape="rect" id="node8" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="448,137,695,163"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="743,78,868,105"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="939,49,1043,75"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="916,100,1067,141"/>
<area shape="rect" id="node7" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1115,107,1261,134"/>
<area shape="rect" id="node10" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="478,71,665,112"/>
<area shape="rect" id="node12" href="classsouffle_1_1_type_environment.html#a0b191b7782e170a23b54f7ec347a32ab" title="souffle::TypeEnvironment\l::getUnsignedType" alt="" coords="478,188,665,229"/>
</map>
</div>

</div>
</div>
<a id="a01ad84055112fcf03bb4ba36a662e76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ad84055112fcf03bb4ba36a662e76a">&#9670;&nbsp;</a></span>isOrderableType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isOrderableType </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_system_8h_source.html#l00513">513</a> of file <a class="el" href="_type_system_8h_source.html">TypeSystem.h</a>.</p>

<p class="reference">References <a class="el" href="_type_system_8cpp_source.html#l00435">areSubtypesOf()</a>, <a class="el" href="html_js_chartist_min_8h_source.html#l00015">b</a>, <a class="el" href="_type_system_8cpp_source.html#l00446">getLeastCommonSupertypes()</a>, <a class="el" href="_type_system_8cpp_source.html#l00327">hasFloatType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00319">hasSignedType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00323">hasUnsignedType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00331">isFloatType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00339">isNumberType()</a>, <a class="el" href="_ram_types_8h_source.html#l00061">isNumericType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00363">isRecordType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00371">isRecursiveType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00401">isSubtypeOf()</a>, <a class="el" href="_type_system_8cpp_source.html#l00355">isSymbolType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00347">isUnsignedType()</a>, and <a class="el" href="_component_instantiation_transformer_8cpp_source.html#l00046">types</a>.</p>
<div class="fragment"><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;                                           {</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#aef21c7dc86fd4e9cc7ecf88e4f5c34a0">isNumericType</a>(type) || <a class="code" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b">isSymbolType</a>(type);</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_aef21c7dc86fd4e9cc7ecf88e4f5c34a0"><div class="ttname"><a href="namespacesouffle.html#aef21c7dc86fd4e9cc7ecf88e4f5c34a0">souffle::isNumericType</a></div><div class="ttdeci">bool isNumericType(const T &amp;type)</div><div class="ttdoc">Determines whether the type is numeric. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8h_source.html#l00508">TypeSystem.h:508</a></div></div>
<div class="ttc" id="namespacesouffle_html_a11f6c352eec6bde7b5a0b143ffe64e3b"><div class="ttname"><a href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b">souffle::isSymbolType</a></div><div class="ttdeci">bool isSymbolType(const Type &amp;type)</div><div class="ttdoc">Determines whether the given type is a symbol type. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00355">TypeSystem.cpp:355</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a01ad84055112fcf03bb4ba36a662e76a_cgraph.png" border="0" usemap="#namespacesouffle_a01ad84055112fcf03bb4ba36a662e76a_cgraph" alt=""/></div>
<map name="namespacesouffle_a01ad84055112fcf03bb4ba36a662e76a_cgraph" id="namespacesouffle_a01ad84055112fcf03bb4ba36a662e76a_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ac810dd526309dc398254f53e18edf50a" title="Determines whether all types in s are subtypes of type b. " alt="" coords="278,134,449,160"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3" title="Determines whether type a is a subtype of type b. " alt="" coords="559,134,713,160"/>
<area shape="rect" id="node12" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="787,352,954,379"/>
<area shape="rect" id="node14" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="789,16,953,43"/>
<area shape="rect" id="node16" href="namespacesouffle.html#a8aecaefb22443dc01bb4c208cb6aabdf" title="Computes the least common super types of the two given types. " alt="" coords="232,352,495,379"/>
<area shape="rect" id="node20" href="namespacesouffle.html#a732d351e2af0d4c5578be62e979a8a32" title="Is any value in the set float. " alt="" coords="284,682,443,708"/>
<area shape="rect" id="node22" href="namespacesouffle.html#a1a7d8cb2f6a29f825e650a7c98487718" title="Determines whether the given type is a float type. " alt="" coords="797,606,944,632"/>
<area shape="rect" id="node24" href="namespacesouffle.html#a31bb9767056b00fd49a4097b59cb07d9" title="Is any value in the set signed. " alt="" coords="278,580,449,607"/>
<area shape="rect" id="node25" href="namespacesouffle.html#a40316bc7e86831e18498b814b5af7fbc" title="Is any value in the set unsigned. " alt="" coords="269,631,457,658"/>
<area shape="rect" id="node26" href="namespacesouffle.html#a5c4839a38da22a968ab01e81a67d793c" title="Determines whether the given type is a number type. " alt="" coords="548,504,724,531"/>
<area shape="rect" id="node28" href="namespacesouffle.html#aa91abe89b1490abcc00848fc5d9daf3a" title="Check if type is numeric. " alt="" coords="278,783,449,810"/>
<area shape="rect" id="node29" href="namespacesouffle.html#a34c8a82b8d9ed840b32e93186002d18c" title="Determines whether the given type is a record type. " alt="" coords="284,834,443,860"/>
<area shape="rect" id="node30" href="namespacesouffle.html#ac79c60fce08f12e1f11d9d342c17ce56" title="Determines whether the given type is a recursive type. " alt="" coords="274,732,453,759"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872" title="A generic test checking whether all elements within a container satisfy a certain predicate..." alt="" coords="581,83,691,110"/>
<area shape="rect" id="node5" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="1012,432,1259,459"/>
<area shape="rect" id="node6" href="classsouffle_1_1_type_environment.html#a5ead83575e9abfebb3a0b180a33a7d96" title="souffle::TypeEnvironment\l::isType" alt="" coords="777,286,964,328"/>
<area shape="rect" id="node7" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="1042,345,1229,386"/>
<area shape="rect" id="node13" href="classsouffle_1_1_type_environment.html#a72fa419d33bf813f22efabec629a4627" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="1042,60,1229,101"/>
<area shape="rect" id="node15" href="classsouffle_1_1_subset_type.html#ac5c52e503cbce42370d6ada3f050773d" title="souffle::SubsetType\l::getBaseType" alt="" coords="797,169,945,210"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="1307,418,1432,444"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="1503,388,1607,415"/>
<area shape="rect" id="node10" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="1480,440,1631,481"/>
<area shape="rect" id="node11" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1679,447,1825,474"/>
<area shape="rect" id="node17" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="577,656,695,683"/>
<area shape="rect" id="node18" href="classsouffle_1_1_type_environment.html#af9544bc93704955f168a0803f583ae19" title="souffle::TypeEnvironment\l::getAllTypes" alt="" coords="543,286,729,328"/>
<area shape="rect" id="node19" href="structsouffle_1_1_type_set.html#ad779397583248bcbf50b982e5314c2e2" title="Adds the given type to this set. " alt="" coords="785,403,956,430"/>
<area shape="rect" id="node21" href="structsouffle_1_1_type_set.html#ae26622401685d8ac9080b2f5a83d7eaa" title="Universality check. " alt="" coords="555,606,717,632"/>
<area shape="rect" id="node23" href="classsouffle_1_1_type_environment.html#a5569e54d58b6ca69f1fffbdd77143545" title="souffle::TypeEnvironment\l::getFloatType" alt="" coords="1042,569,1229,610"/>
<area shape="rect" id="node27" href="classsouffle_1_1_type_environment.html#a0b191b7782e170a23b54f7ec347a32ab" title="souffle::TypeEnvironment\l::getUnsignedType" alt="" coords="1042,490,1229,532"/>
<area shape="rect" id="node31" href="classsouffle_1_1_union_type.html#a0175bce933a70c1d3691114860ac17fc" title="souffle::UnionType\l::getElementTypes" alt="" coords="565,758,707,800"/>
<area shape="rect" id="node33" href="structsouffle_1_1_record_type.html#a338320267386a93ab482f1e25d50ef7a" title="souffle::RecordType\l::getFields" alt="" coords="562,824,710,865"/>
<area shape="rect" id="node32" href="classsouffle_1_1_type.html#a00437c665d598367ff16229c823c728f" title="souffle::Type::print" alt="" coords="799,798,942,824"/>
</map>
</div>

</div>
</div>
<a id="ab4197fde9d6be59495c0c8b613de0129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4197fde9d6be59495c0c8b613de0129">&#9670;&nbsp;</a></span>isOrderedBinaryConstraintOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isOrderedBinaryConstraintOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a>&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether arguments of constraint are orderable. </p>

<p class="definition">Definition at line <a class="el" href="_binary_constraint_ops_8h_source.html#l00276">276</a> of file <a class="el" href="_binary_constraint_ops_8h_source.html">BinaryConstraintOps.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b">CONTAINS</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa123e958001611b441dab45ff11ba98a">FEQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa1d7888b08b54d43aeadc58136fa0907">FGE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa302b6b103aca34c46209564002a8252">FGT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a56267eaefed8c4c5255779a597a72363">FLE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a1cc288bb3360b602513d8ffe37a874f9">FLT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a90dc357130ab3c37ef770e959ab49b9c">FNE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">GE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">GT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">LE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">LT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a">MATCH</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">NE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0">NOT_CONTAINS</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01">NOT_MATCH</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49add25db0709d4c7c05b057f311208f753">SGE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a53acb49d0534e8912fec8569e845400f">SGT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a0a1d07df9a43688c7128eefbe3d41b08">SLE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac71563c4ae48cc1bbd2e7913366cdf7e">SLT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ada0d6078de3703b5680eb9361f2d68fd">UGE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7efc25ec6c881b13261c1a6d88762483">UGT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ae29e365fd3b5e59c86218486a0c1c7c1">ULE</a>, and <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2b4652512a6c88f5a39c3288081b6e13">ULT</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, and <a class="el" href="_explain_provenance_impl_8h_source.html#l00074">souffle::ExplainProvenanceImpl::explain()</a>.</p>
<div class="fragment"><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                                                                     {</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    <span class="keywordflow">switch</span> (op) {</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::EQ:</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FEQ:</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NE:</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FNE:</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::LT:</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::ULT:</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FLT:</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::LE:</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::ULE:</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FLE:</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::GE:</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::UGE:</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FGE:</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::GT:</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::UGT:</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FGT:</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::SLT:</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::SLE:</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::SGE:</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::SGT:</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::MATCH:</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NOT_MATCH:</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::CONTAINS:</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NOT_CONTAINS:</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    }</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Uncovered case!&quot;</span>);</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    exit(EXIT_FAILURE);</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="acf7ac56e1539b5fc646d3822edf00bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7ac56e1539b5fc646d3822edf00bc2">&#9670;&nbsp;</a></span>isOverloaded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isOverloaded </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a>&#160;</td>
          <td class="paramname"><em>constraintOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function, informing whether constraint is overloaded. </p>
<p>Only the signed version's are treated as overloaded (as they are returned by the parser). </p>

<p class="definition">Definition at line <a class="el" href="_binary_constraint_ops_8h_source.html#l00076">76</a> of file <a class="el" href="_binary_constraint_ops_8h_source.html">BinaryConstraintOps.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">GE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">GT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">LE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">LT</a>, and <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">NE</a>.</p>

<p class="reference">Referenced by <a class="el" href="_binary_constraint_ops_8h_source.html#l00095">convertOverloadedConstraint()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l01253">souffle::PolymorphicObjectsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                                                                {</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="keywordflow">switch</span> (constraintOp) {</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::EQ:</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NE:</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::LT:</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::LE:</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::GT:</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::GE:</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    }</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a28dce057a5176061ef6f8cfc3f45af19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28dce057a5176061ef6f8cfc3f45af19">&#9670;&nbsp;</a></span>isOverloadedAggregator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isOverloadedAggregator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21">AggregateOp</a>&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_aggregate_op_8h_source.html#l00068">68</a> of file <a class="el" href="_aggregate_op_8h_source.html">AggregateOp.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">MAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">MIN</a>, and <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a6970bdc2201030b9c03fbdcf3973858a">SUM</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_transforms_8cpp_source.html#l01253">souffle::PolymorphicObjectsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;                                                         {</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <span class="keywordflow">switch</span> (op) {</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        <span class="keywordflow">case</span> AggregateOp::MAX:</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        <span class="keywordflow">case</span> AggregateOp::MIN:</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        <span class="keywordflow">case</span> AggregateOp::SUM:</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    }</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a1194839f74c824923896977b98541e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1194839f74c824923896977b98541e2e">&#9670;&nbsp;</a></span>isOverloadedFunctor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isOverloadedFunctor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a>&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicate whether a functor is overloaded. </p>
<p>At the moment, the signed versions are treated as representatives (because parser always returns a signed version). </p>

<p class="definition">Definition at line <a class="el" href="_functor_ops_8h_source.html#l00460">460</a> of file <a class="el" href="_functor_ops_8h_source.html">FunctorOps.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9eeb52badb613229884838847294b90d">ADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aa8a5bbeedca093b94b7f0d3f185b98f7">BAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0fd78279a775c262180e0cfbad6fa9eb">BNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0adf6aac232504c55ea4202e09498bfd">BOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a21506bac4ecfbfe4272b9bf8185446b6">BXOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a29bbf66f7f8529ec47e394fb5a36c646">DIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a479a809c0b6eaaefd3b1df16f976df06">LAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a81145009eec44ad2c399c9459a01d8f0">LNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ad3335c358811cfc353257e21b1d38229">LOR</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">MAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">MIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac5a28f4b35a2884fa3277150ac5d0967">MOD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2cdf52a55876063ec93b7d18bc741f6c">MUL</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a5dd68b1a7db42a1cce4dce09dbaa179e">NEG</a>, and <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a241dd841abade20fcb27b8a9f494e1eb">SUB</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_type_analysis_8cpp_source.html#l00517">souffle::TypeAnalysis::analyseTypes()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l01253">souffle::PolymorphicObjectsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;                                                         {</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    <span class="keywordflow">switch</span> (functor) {</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;        <span class="comment">/* Unary */</span></div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;        <span class="keywordflow">case</span> FunctorOp::NEG:</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BNOT:</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LNOT:</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        <span class="comment">/* Binary */</span></div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ADD:</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SUB:</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MUL:</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;        <span class="keywordflow">case</span> FunctorOp::DIV:</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        <span class="keywordflow">case</span> FunctorOp::EXP:</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BAND:</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BOR:</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BXOR:</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LAND:</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LOR:</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MOD:</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MAX:</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MIN:</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    }</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab9fd86fe230c58e924db2cf47e1ba5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fd86fe230c58e924db2cf47e1ba5e0">&#9670;&nbsp;</a></span>isPrefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isPrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if one string is a prefix of another. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00879">879</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_util_8h_source.html#l00121">RamSignedFromString()</a>, <a class="el" href="_util_8h_source.html#l00180">RamUnsignedFromString()</a>, and <a class="el" href="_read_stream_c_s_v_8h_source.html#l00128">souffle::ReadStreamCSV::readRamUnsigned()</a>.</p>
<div class="fragment"><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;                                                                        {</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;    <span class="keyword">auto</span> itPrefix = prefix.begin();</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;    <span class="keyword">auto</span> itElement = element.begin();</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;    <span class="keywordflow">while</span> (itPrefix != prefix.end() &amp;&amp; itElement != element.end()) {</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;        <span class="keywordflow">if</span> (*itPrefix != *itElement) {</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;        }</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;        ++itPrefix;</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;        ++itElement;</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;    }</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;    <span class="keywordflow">return</span> itPrefix == prefix.end();</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a1c608d44d9d95373b73915fd555eeb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c608d44d9d95373b73915fd555eeb60">&#9670;&nbsp;</a></span>isProposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isProposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&#160;</td>
          <td class="paramname"><em>atom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00042">42</a> of file <a class="el" href="_reorder_literals_transformer_8cpp_source.html">ReorderLiteralsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_literal_8h_source.html#l00078">souffle::AstAtom::getArguments()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00079">getSipsFunction()</a>, and <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00355">souffle::ReorderLiteralsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                                               {</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <span class="keywordflow">return</span> atom-&gt;getArguments().empty();</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a1c608d44d9d95373b73915fd555eeb60_cgraph.png" border="0" usemap="#namespacesouffle_a1c608d44d9d95373b73915fd555eeb60_cgraph" alt=""/></div>
<map name="namespacesouffle_a1c608d44d9d95373b73915fd555eeb60_cgraph" id="namespacesouffle_a1c608d44d9d95373b73915fd555eeb60_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="212,5,443,32"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="491,5,637,32"/>
</map>
</div>

</div>
</div>
<a id="adda7adbee5f19bb274a067facc71d0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda7adbee5f19bb274a067facc71d0e8">&#9670;&nbsp;</a></span>isRamTrue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isRamTrue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ram_condition.html">RamCondition</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a condition represents true. </p>

<p class="definition">Definition at line <a class="el" href="_ram_utils_8h_source.html#l00032">32</a> of file <a class="el" href="_ram_utils_8h_source.html">RamUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_synthesiser_8cpp_source.html#l00172">souffle::Synthesiser::emitCode()</a>, <a class="el" href="_ram_operation_8h_source.html#l00783">souffle::RamAggregate::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00839">souffle::RamIndexAggregate::print()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00355">souffle::MakeIndexTransformer::rewriteIndexScan()</a>, and <a class="el" href="_ram_transforms_8cpp_source.html#l00335">souffle::MakeIndexTransformer::rewriteScan()</a>.</p>
<div class="fragment"><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                                                {</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span> != <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>RamTrue*<span class="keyword">&gt;</span>(cond);</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aaaed06bbcb6b8efcfd2474b1c5d81aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaed06bbcb6b8efcfd2474b1c5d81aa3">&#9670;&nbsp;</a></span>isRamUndefValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isRamUndefValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ram_expression.html">RamExpression</a> *&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if an expression represents an undefined value. </p>

<p class="definition">Definition at line <a class="el" href="_ram_utils_8h_source.html#l00027">27</a> of file <a class="el" href="_ram_utils_8h_source.html">RamUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_synthesiser_8cpp_source.html#l00172">souffle::Synthesiser::emitCode()</a>, <a class="el" href="_ram_index_analysis_8cpp_source.html#l00387">souffle::RamIndexAnalysis::isTotalSignature()</a>, <a class="el" href="_ram_index_analysis_8cpp_source.html#l00307">souffle::RamIndexAnalysis::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00309">souffle::RamIndexOperation::printIndex()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l00704">souffle::AstTranslator::ClauseTranslator::translateClause()</a>.</p>
<div class="fragment"><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;                                                       {</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span> != <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>RamUndefValue*<span class="keyword">&gt;</span>(expr);</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a34c8a82b8d9ed840b32e93186002d18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c8a82b8d9ed840b32e93186002d18c">&#9670;&nbsp;</a></span>isRecordType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isRecordType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given type is a record type. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00363">363</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_type_system_8h_source.html#l00464">eqTypeTypeAttribute()</a>, <a class="el" href="_type_system_8h_source.html#l00485">getTypeAttribute()</a>, <a class="el" href="_type_system_8h_source.html#l00513">isOrderableType()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00367">isRecordType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;                                    {</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>RecordType*<span class="keyword">&gt;</span>(&amp;type) != <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a790e39fcdcb0e62caaee56e0bf7d3b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790e39fcdcb0e62caaee56e0bf7d3b45">&#9670;&nbsp;</a></span>isRecordType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isRecordType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether all the types in the given set are record types. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00367">367</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00996">all_of()</a>, <a class="el" href="_type_system_8h_source.html#l00208">souffle::TypeSet::empty()</a>, <a class="el" href="_type_system_8h_source.html#l00213">souffle::TypeSet::isAll()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00363">isRecordType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                                    {</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    <span class="keywordflow">return</span> !s.empty() &amp;&amp; !s.isAll() &amp;&amp; <a class="code" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">all_of</a>(s, (<span class="keywordtype">bool</span> (*)(<span class="keyword">const</span> Type&amp;)) &amp; <a class="code" href="namespacesouffle.html#a790e39fcdcb0e62caaee56e0bf7d3b45">isRecordType</a>);</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a14b5f9eb9ec09c40e558b242e75de872"><div class="ttname"><a href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">souffle::all_of</a></div><div class="ttdeci">bool all_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether all elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00996">Util.h:996</a></div></div>
<div class="ttc" id="namespacesouffle_html_a790e39fcdcb0e62caaee56e0bf7d3b45"><div class="ttname"><a href="namespacesouffle.html#a790e39fcdcb0e62caaee56e0bf7d3b45">souffle::isRecordType</a></div><div class="ttdeci">bool isRecordType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are record types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00367">TypeSystem.cpp:367</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a790e39fcdcb0e62caaee56e0bf7d3b45_cgraph.png" border="0" usemap="#namespacesouffle_a790e39fcdcb0e62caaee56e0bf7d3b45_cgraph" alt=""/></div>
<map name="namespacesouffle_a790e39fcdcb0e62caaee56e0bf7d3b45_cgraph" id="namespacesouffle_a790e39fcdcb0e62caaee56e0bf7d3b45_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872" title="A generic test checking whether all elements within a container satisfy a certain predicate..." alt="" coords="244,5,355,32"/>
<area shape="rect" id="node3" href="structsouffle_1_1_type_set.html#a2110dea550ae2c1eaf6ef65e2854f925" title="Emptiness check. " alt="" coords="212,56,387,83"/>
<area shape="rect" id="node4" href="structsouffle_1_1_type_set.html#ae26622401685d8ac9080b2f5a83d7eaa" title="Universality check. " alt="" coords="219,107,380,133"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a34c8a82b8d9ed840b32e93186002d18c" title="Determines whether the given type is a record type. " alt="" coords="220,157,379,184"/>
</map>
</div>

</div>
</div>
<a id="aa32d170d4eebb7da45f9322e8b548aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32d170d4eebb7da45f9322e8b548aa8">&#9670;&nbsp;</a></span>isRecursiveClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isRecursiveClause </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the given clause is recursive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clause</td><td>the clause to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the clause is recursive </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00148">148</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_clause_8h_source.html#l00171">souffle::AstClause::getBodyLiterals()</a>, <a class="el" href="_ast_clause_8h_source.html#l00166">souffle::AstClause::getHead()</a>, <a class="el" href="_ast_literal_8h_source.html#l00058">souffle::AstAtom::getQualifiedName()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l00822">souffle::ReduceExistentialsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                                                {</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    AstQualifiedName relationName = clause.getHead()-&gt;getQualifiedName();</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="keywordtype">bool</span> recursive = <span class="keyword">false</span>;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(clause.getBodyLiterals(), [&amp;](<span class="keyword">const</span> AstAtom&amp; atom) {</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        <span class="keywordflow">if</span> (atom.getQualifiedName() == relationName) {</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            recursive = <span class="keyword">true</span>;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        }</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    });</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="keywordflow">return</span> recursive;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aa32d170d4eebb7da45f9322e8b548aa8_cgraph.png" border="0" usemap="#namespacesouffle_aa32d170d4eebb7da45f9322e8b548aa8_cgraph" alt=""/></div>
<map name="namespacesouffle_aa32d170d4eebb7da45f9322e8b548aa8_cgraph" id="namespacesouffle_aa32d170d4eebb7da45f9322e8b548aa8_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="304,5,443,47"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="304,71,443,112"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="245,137,501,163"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="289,187,457,214"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="560,13,707,39"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="549,180,717,221"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="765,180,956,221"/>
</map>
</div>

</div>
</div>
<a id="ac79c60fce08f12e1f11d9d342c17ce56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79c60fce08f12e1f11d9d342c17ce56">&#9670;&nbsp;</a></span>isRecursiveType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isRecursiveType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given type is a recursive type. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00371">371</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l01010">any_of()</a>, <a class="el" href="_type_system_8h_source.html#l00128">souffle::UnionType::getElementTypes()</a>, and <a class="el" href="_type_system_8h_source.html#l00158">souffle::RecordType::getFields()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_type_system_8h_source.html#l00513">isOrderableType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;                                       {</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <span class="keyword">struct </span>visitor : <span class="keyword">public</span> VisitOnceTypeVisitor&lt;bool&gt; {</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        <span class="keyword">const</span> Type&amp; trg;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        visitor(<span class="keyword">const</span> Type&amp; trg) : trg(trg) {}</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;        <span class="keywordtype">bool</span> visit(<span class="keyword">const</span> Type&amp; type)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;            <span class="keywordflow">if</span> (trg == type) {</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;            }</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;            <span class="keywordflow">return</span> VisitOnceTypeVisitor&lt;bool&gt;::visit(type);</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        }</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        <span class="keywordtype">bool</span> visitUnionType(<span class="keyword">const</span> UnionType&amp; type)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;            <span class="keyword">auto</span> reachesTrg = [&amp;](<span class="keyword">const</span> Type* cur) { <span class="keywordflow">return</span> this-&gt;visit(*cur); };</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(type.getElementTypes(), reachesTrg);</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        }</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;        <span class="keywordtype">bool</span> visitRecordType(<span class="keyword">const</span> RecordType&amp; type)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;            <span class="keyword">auto</span> reachesTrg = [&amp;](<span class="keyword">const</span> RecordType::Field&amp; cur) { <span class="keywordflow">return</span> this-&gt;visit(cur.type); };</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(type.getFields(), reachesTrg);</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;        }</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    };</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    <span class="comment">// record types are recursive if they contain themselves</span></div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* r = dynamic_cast&lt;const RecordType*&gt;(&amp;type)) {</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;        <span class="keyword">auto</span> reachesOrigin = visitor(type);</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">any_of</a>(r-&gt;getFields(),</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;                [&amp;](<span class="keyword">const</span> RecordType::Field&amp; field) -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span> reachesOrigin(field.type); });</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    }</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a34f8eecb81c090fca9e58d3357b63ed9"><div class="ttname"><a href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">souffle::any_of</a></div><div class="ttdeci">bool any_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether any elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01010">Util.h:1010</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ac79c60fce08f12e1f11d9d342c17ce56_cgraph.png" border="0" usemap="#namespacesouffle_ac79c60fce08f12e1f11d9d342c17ce56_cgraph" alt=""/></div>
<map name="namespacesouffle_ac79c60fce08f12e1f11d9d342c17ce56_cgraph" id="namespacesouffle_ac79c60fce08f12e1f11d9d342c17ce56_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9" title="A generic test checking whether any elements within a container satisfy a certain predicate..." alt="" coords="247,5,365,32"/>
<area shape="rect" id="node3" href="classsouffle_1_1_union_type.html#a0175bce933a70c1d3691114860ac17fc" title="souffle::UnionType\l::getElementTypes" alt="" coords="235,57,377,98"/>
<area shape="rect" id="node5" href="structsouffle_1_1_record_type.html#a338320267386a93ab482f1e25d50ef7a" title="souffle::RecordType\l::getFields" alt="" coords="232,122,380,163"/>
<area shape="rect" id="node4" href="classsouffle_1_1_type.html#a00437c665d598367ff16229c823c728f" title="souffle::Type::print" alt="" coords="428,97,571,124"/>
</map>
</div>

</div>
</div>
<a id="a3001cd29f8307b210ec039a6f7788636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3001cd29f8307b210ec039a6f7788636">&#9670;&nbsp;</a></span>isRelationQualifierTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isRelationQualifierTag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529f">RelationTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a given relation tag is a relation qualifier. </p>

<p class="definition">Definition at line <a class="el" href="_relation_tag_8h_source.html#l00070">70</a> of file <a class="el" href="_relation_tag_8h_source.html">RelationTag.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">INLINE</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529faa84cc046d48610b05c21fd3670d0c829">INPUT</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa50a87f0d71f7221582dad4bf507a0f34">OUTPUT</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fac9572efed22489a0eb4ab9dcd8132d4b">OVERRIDABLE</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa412e14f57c2f0eeb02d2475ca63bf38c">PRINTSIZE</a>, and <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa749f7196d531a918508ddc75af68469d">SUPPRESSED</a>.</p>
<div class="fragment"><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;                                                           {</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <span class="keywordflow">switch</span> (tag) {</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        <span class="keywordflow">case</span> RelationTag::INPUT:</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        <span class="keywordflow">case</span> RelationTag::OUTPUT:</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        <span class="keywordflow">case</span> RelationTag::PRINTSIZE:</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        <span class="keywordflow">case</span> RelationTag::OVERRIDABLE:</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        <span class="keywordflow">case</span> RelationTag::INLINE:</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        <span class="keywordflow">case</span> RelationTag::SUPPRESSED:</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    }</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ae730235d0fafb09318409c3051334ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae730235d0fafb09318409c3051334ca8">&#9670;&nbsp;</a></span>isRelationRepresentationTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isRelationRepresentationTag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529f">RelationTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a given relation tag sets a relation representation. </p>

<p class="definition">Definition at line <a class="el" href="_relation_tag_8h_source.html#l00056">56</a> of file <a class="el" href="_relation_tag_8h_source.html">RelationTag.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fade0f2c62e46b76fe07b1033a2af15a28">BRIE</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa26daa90bc6e4e7baf2b5781caef22940">BTREE</a>, and <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa06a35dca93aeafc1b0f548410517223a">EQREL</a>.</p>
<div class="fragment"><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                                                                {</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="keywordflow">switch</span> (tag) {</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        <span class="keywordflow">case</span> RelationTag::BRIE:</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        <span class="keywordflow">case</span> RelationTag::BTREE:</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        <span class="keywordflow">case</span> RelationTag::EQREL:</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    }</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ad9a7da374b6da781f82cdc09d5fe0d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a7da374b6da781f82cdc09d5fe0d38">&#9670;&nbsp;</a></span>isRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;&#160;</td>
          <td class="paramname"><em>clause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the given clause is a rule. </p>
<dl class="section return"><dt>Returns</dt><dd>true iff the clause is a rule </dd></dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00175">175</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_clause_8h_source.html#l00166">souffle::AstClause::getHead()</a>, and <a class="el" href="_ast_utils_8cpp_source.html#l00159">isFact()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l00704">souffle::AstTranslator::ClauseTranslator::translateClause()</a>.</p>
<div class="fragment"><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                                     {</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    <span class="keywordflow">return</span> (clause.getHead() != <span class="keyword">nullptr</span>) &amp;&amp; !<a class="code" href="namespacesouffle.html#ae4b6e248ec714e64f38ce032caf5f477">isFact</a>(clause);</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_ae4b6e248ec714e64f38ce032caf5f477"><div class="ttname"><a href="namespacesouffle.html#ae4b6e248ec714e64f38ce032caf5f477">souffle::isFact</a></div><div class="ttdeci">bool isFact(const AstClause &amp;clause)</div><div class="ttdoc">Returns whether the given clause is a fact. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00159">AstUtils.cpp:159</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ad9a7da374b6da781f82cdc09d5fe0d38_cgraph.png" border="0" usemap="#namespacesouffle_ad9a7da374b6da781f82cdc09d5fe0d38_cgraph" alt=""/></div>
<map name="namespacesouffle_ad9a7da374b6da781f82cdc09d5fe0d38_cgraph" id="namespacesouffle_ad9a7da374b6da781f82cdc09d5fe0d38_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="340,5,479,47"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ae4b6e248ec714e64f38ce032caf5f477" title="Returns whether the given clause is a fact. " alt="" coords="167,71,277,98"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="340,71,479,112"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="325,137,493,163"/>
<area shape="rect" id="node5" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="552,78,699,105"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="541,129,709,171"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="757,129,948,171"/>
</map>
</div>

</div>
</div>
<a id="a8cc19c66d9d13ce64e65f14dcabb43b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc19c66d9d13ce64e65f14dcabb43b3">&#9670;&nbsp;</a></span>isSubtypeOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isSubtypeOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether type a is a subtype of type b. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00401">401</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_type_system_8h_source.html#l00084">souffle::Type::environment</a>, <a class="el" href="_type_system_8h_source.html#l00106">souffle::SubsetType::getBaseType()</a>, <a class="el" href="_type_system_8h_source.html#l00384">souffle::TypeEnvironment::getNumberType()</a>, <a class="el" href="_type_system_8h_source.html#l00396">souffle::TypeEnvironment::getSymbolType()</a>, <a class="el" href="_type_system_8h_source.html#l00051">souffle::Type::getTypeEnvironment()</a>, <a class="el" href="_type_system_8cpp_source.html#l00339">isNumberType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00355">isSymbolType()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00081">souffle::TypeEnvironment::isType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_type_analysis_8cpp_source.html#l00517">souffle::TypeAnalysis::analyseTypes()</a>, <a class="el" href="_type_system_8cpp_source.html#l00435">areSubtypesOf()</a>, <a class="el" href="_type_system_8cpp_source.html#l00540">getGreatestCommonSubtypes()</a>, <a class="el" href="_type_system_8cpp_source.html#l00446">getLeastCommonSupertypes()</a>, and <a class="el" href="_type_system_8h_source.html#l00513">isOrderableType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                                               {</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="comment">// make sure they are both in the same environment</span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="keyword">auto</span>&amp; environment = a.getTypeEnvironment();</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    assert(environment.isType(a) &amp;&amp; environment.isType(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>));</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    <span class="comment">// first check - a type is a sub-type of itself</span></div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    <span class="keywordflow">if</span> (a == <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>) {</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    }</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    <span class="comment">// check for predefined types</span></div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a> == environment.getNumberType()) {</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#aae6c863e60901e130475672aff3942ac">isNumberType</a>(a);</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    }</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a> == environment.getSymbolType()) {</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#ae9f1f97bcd38ff9cd112ade89e631b80">isSymbolType</a>(a);</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    }</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    <span class="comment">// check primitive type chains</span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <span class="keywordflow">if</span> (isA&lt;SubsetType&gt;(a)) {</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">isSubtypeOf</a>(as&lt;SubsetType&gt;(a).getBaseType(), <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)) {</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;        }</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    }</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <span class="comment">// next - if b is a union type</span></div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="keywordflow">if</span> (isUnion(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)) {</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;        <span class="keywordflow">return</span> isSubType(a, as&lt;UnionType&gt;(<a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>));</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    }</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    <span class="comment">// done</span></div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_aae6c863e60901e130475672aff3942ac"><div class="ttname"><a href="namespacesouffle.html#aae6c863e60901e130475672aff3942ac">souffle::isNumberType</a></div><div class="ttdeci">bool isNumberType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are number types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00343">TypeSystem.cpp:343</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a8cc19c66d9d13ce64e65f14dcabb43b3"><div class="ttname"><a href="namespacesouffle.html#a8cc19c66d9d13ce64e65f14dcabb43b3">souffle::isSubtypeOf</a></div><div class="ttdeci">bool isSubtypeOf(const Type &amp;a, const Type &amp;b)</div><div class="ttdoc">Determines whether type a is a subtype of type b. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00401">TypeSystem.cpp:401</a></div></div>
<div class="ttc" id="namespacesouffle_html_ae9f1f97bcd38ff9cd112ade89e631b80"><div class="ttname"><a href="namespacesouffle.html#ae9f1f97bcd38ff9cd112ade89e631b80">souffle::isSymbolType</a></div><div class="ttdeci">bool isSymbolType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are symbol types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00359">TypeSystem.cpp:359</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8cc19c66d9d13ce64e65f14dcabb43b3_cgraph.png" border="0" usemap="#namespacesouffle_a8cc19c66d9d13ce64e65f14dcabb43b3_cgraph" alt=""/></div>
<map name="namespacesouffle_a8cc19c66d9d13ce64e65f14dcabb43b3_cgraph" id="namespacesouffle_a8cc19c66d9d13ce64e65f14dcabb43b3_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_subset_type.html#ac5c52e503cbce42370d6ada3f050773d" title="souffle::SubsetType\l::getBaseType" alt="" coords="226,5,374,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1_type_environment.html#a5586a154835d2bfc076b9d5fcc11a50f" title="souffle::TypeEnvironment\l::getNumberType" alt="" coords="471,144,658,185"/>
<area shape="rect" id="node8" href="classsouffle_1_1_type_environment.html#a72fa419d33bf813f22efabec629a4627" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="471,79,658,120"/>
<area shape="rect" id="node9" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="441,223,688,250"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a4e502e6abb9a3e9a8e4c1168dbf23743" title="Determines whether the given type is a number type. " alt="" coords="217,223,383,250"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="218,173,382,199"/>
<area shape="rect" id="node12" href="classsouffle_1_1_type_environment.html#a5ead83575e9abfebb3a0b180a33a7d96" title="souffle::TypeEnvironment\l::isType" alt="" coords="207,325,393,367"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="736,119,861,146"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="933,90,1037,117"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="909,141,1060,183"/>
<area shape="rect" id="node7" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1108,149,1255,175"/>
</map>
</div>

</div>
</div>
<a id="a11f6c352eec6bde7b5a0b143ffe64e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f6c352eec6bde7b5a0b143ffe64e3b">&#9670;&nbsp;</a></span>isSymbolType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isSymbolType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given type is a symbol type. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00355">355</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_type_system_8h_source.html#l00396">souffle::TypeEnvironment::getSymbolType()</a>, and <a class="el" href="_type_system_8h_source.html#l00051">souffle::Type::getTypeEnvironment()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_type_system_8h_source.html#l00464">eqTypeTypeAttribute()</a>, <a class="el" href="_type_system_8h_source.html#l00485">getTypeAttribute()</a>, <a class="el" href="_type_system_8h_source.html#l00513">isOrderableType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00401">isSubtypeOf()</a>, <a class="el" href="_type_system_8cpp_source.html#l00359">isSymbolType()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l01253">souffle::PolymorphicObjectsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                                    {</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="keywordflow">return</span> isOfRootType(type, type.getTypeEnvironment().getSymbolType());</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a11f6c352eec6bde7b5a0b143ffe64e3b_cgraph.png" border="0" usemap="#namespacesouffle_a11f6c352eec6bde7b5a0b143ffe64e3b_cgraph" alt=""/></div>
<map name="namespacesouffle_a11f6c352eec6bde7b5a0b143ffe64e3b_cgraph" id="namespacesouffle_a11f6c352eec6bde7b5a0b143ffe64e3b_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_type_environment.html#a72fa419d33bf813f22efabec629a4627" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="247,27,434,69"/>
<area shape="rect" id="node7" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="217,93,464,120"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="512,35,637,61"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="709,5,813,32"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="685,57,836,98"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="884,64,1031,91"/>
</map>
</div>

</div>
</div>
<a id="ae9f1f97bcd38ff9cd112ade89e631b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f1f97bcd38ff9cd112ade89e631b80">&#9670;&nbsp;</a></span>isSymbolType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isSymbolType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether all the types in the given set are symbol types. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00359">359</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00996">all_of()</a>, <a class="el" href="_type_system_8h_source.html#l00208">souffle::TypeSet::empty()</a>, <a class="el" href="_type_system_8h_source.html#l00213">souffle::TypeSet::isAll()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00355">isSymbolType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;                                    {</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="keywordflow">return</span> !s.empty() &amp;&amp; !s.isAll() &amp;&amp; <a class="code" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">all_of</a>(s, (<span class="keywordtype">bool</span> (*)(<span class="keyword">const</span> Type&amp;)) &amp; <a class="code" href="namespacesouffle.html#ae9f1f97bcd38ff9cd112ade89e631b80">isSymbolType</a>);</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a14b5f9eb9ec09c40e558b242e75de872"><div class="ttname"><a href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">souffle::all_of</a></div><div class="ttdeci">bool all_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether all elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00996">Util.h:996</a></div></div>
<div class="ttc" id="namespacesouffle_html_ae9f1f97bcd38ff9cd112ade89e631b80"><div class="ttname"><a href="namespacesouffle.html#ae9f1f97bcd38ff9cd112ade89e631b80">souffle::isSymbolType</a></div><div class="ttdeci">bool isSymbolType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are symbol types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00359">TypeSystem.cpp:359</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ae9f1f97bcd38ff9cd112ade89e631b80_cgraph.png" border="0" usemap="#namespacesouffle_ae9f1f97bcd38ff9cd112ade89e631b80_cgraph" alt=""/></div>
<map name="namespacesouffle_ae9f1f97bcd38ff9cd112ade89e631b80_cgraph" id="namespacesouffle_ae9f1f97bcd38ff9cd112ade89e631b80_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872" title="A generic test checking whether all elements within a container satisfy a certain predicate..." alt="" coords="249,5,360,32"/>
<area shape="rect" id="node3" href="structsouffle_1_1_type_set.html#a2110dea550ae2c1eaf6ef65e2854f925" title="Emptiness check. " alt="" coords="217,56,392,83"/>
<area shape="rect" id="node4" href="structsouffle_1_1_type_set.html#ae26622401685d8ac9080b2f5a83d7eaa" title="Universality check. " alt="" coords="224,107,385,133"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a11f6c352eec6bde7b5a0b143ffe64e3b" title="Determines whether the given type is a symbol type. " alt="" coords="223,157,387,184"/>
<area shape="rect" id="node6" href="classsouffle_1_1_type_environment.html#a72fa419d33bf813f22efabec629a4627" title="souffle::TypeEnvironment\l::getSymbolType" alt="" coords="470,121,657,162"/>
<area shape="rect" id="node11" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="440,187,687,213"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="735,128,860,155"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="931,99,1035,125"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="908,150,1059,191"/>
<area shape="rect" id="node10" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1107,157,1253,184"/>
</map>
</div>

</div>
</div>
<a id="a5c4839a38da22a968ab01e81a67d793c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4839a38da22a968ab01e81a67d793c">&#9670;&nbsp;</a></span>isUnsignedType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isUnsignedType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given type is a number type. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00347">347</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_type_system_8h_source.html#l00051">souffle::Type::getTypeEnvironment()</a>, and <a class="el" href="_type_system_8h_source.html#l00388">souffle::TypeEnvironment::getUnsignedType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_type_system_8h_source.html#l00464">eqTypeTypeAttribute()</a>, <a class="el" href="_type_system_8h_source.html#l00485">getTypeAttribute()</a>, <a class="el" href="_type_system_8cpp_source.html#l00323">hasUnsignedType()</a>, <a class="el" href="_type_system_8h_source.html#l00508">isNumericType()</a>, <a class="el" href="_type_system_8h_source.html#l00513">isOrderableType()</a>, <a class="el" href="_type_system_8cpp_source.html#l00351">isUnsignedType()</a>, and <a class="el" href="_ast_transforms_8cpp_source.html#l01253">souffle::PolymorphicObjectsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                                      {</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    <span class="keywordflow">return</span> isOfRootType(type, type.getTypeEnvironment().getUnsignedType());</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a5c4839a38da22a968ab01e81a67d793c_cgraph.png" border="0" usemap="#namespacesouffle_a5c4839a38da22a968ab01e81a67d793c_cgraph" alt=""/></div>
<map name="namespacesouffle_a5c4839a38da22a968ab01e81a67d793c_cgraph" id="namespacesouffle_a5c4839a38da22a968ab01e81a67d793c_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="229,5,476,32"/>
<area shape="rect" id="node3" href="classsouffle_1_1_type_environment.html#a0b191b7782e170a23b54f7ec347a32ab" title="souffle::TypeEnvironment\l::getUnsignedType" alt="" coords="259,57,446,98"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="524,64,649,91"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="721,35,825,61"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="697,86,848,127"/>
<area shape="rect" id="node7" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="896,93,1043,120"/>
</map>
</div>

</div>
</div>
<a id="a3b4bd063028ddb747c726ca9fa04f85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4bd063028ddb747c726ca9fa04f85e">&#9670;&nbsp;</a></span>isUnsignedType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isUnsignedType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsouffle_1_1_type_set.html">TypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether all the types in the given set are number types. </p>

<p class="definition">Definition at line <a class="el" href="_type_system_8cpp_source.html#l00351">351</a> of file <a class="el" href="_type_system_8cpp_source.html">TypeSystem.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00996">all_of()</a>, <a class="el" href="_type_system_8h_source.html#l00208">souffle::TypeSet::empty()</a>, <a class="el" href="_type_system_8h_source.html#l00213">souffle::TypeSet::isAll()</a>, and <a class="el" href="_type_system_8cpp_source.html#l00347">isUnsignedType()</a>.</p>
<div class="fragment"><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                                      {</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    <span class="keywordflow">return</span> !s.empty() &amp;&amp; !s.isAll() &amp;&amp; <a class="code" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">all_of</a>(s, (<span class="keywordtype">bool</span> (*)(<span class="keyword">const</span> Type&amp;)) &amp; <a class="code" href="namespacesouffle.html#a3b4bd063028ddb747c726ca9fa04f85e">isUnsignedType</a>);</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a14b5f9eb9ec09c40e558b242e75de872"><div class="ttname"><a href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">souffle::all_of</a></div><div class="ttdeci">bool all_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether all elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00996">Util.h:996</a></div></div>
<div class="ttc" id="namespacesouffle_html_a3b4bd063028ddb747c726ca9fa04f85e"><div class="ttname"><a href="namespacesouffle.html#a3b4bd063028ddb747c726ca9fa04f85e">souffle::isUnsignedType</a></div><div class="ttdeci">bool isUnsignedType(const TypeSet &amp;s)</div><div class="ttdoc">Determines whether all the types in the given set are number types. </div><div class="ttdef"><b>Definition:</b> <a href="_type_system_8cpp_source.html#l00351">TypeSystem.cpp:351</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a3b4bd063028ddb747c726ca9fa04f85e_cgraph.png" border="0" usemap="#namespacesouffle_a3b4bd063028ddb747c726ca9fa04f85e_cgraph" alt=""/></div>
<map name="namespacesouffle_a3b4bd063028ddb747c726ca9fa04f85e_cgraph" id="namespacesouffle_a3b4bd063028ddb747c726ca9fa04f85e_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872" title="A generic test checking whether all elements within a container satisfy a certain predicate..." alt="" coords="262,5,373,32"/>
<area shape="rect" id="node3" href="structsouffle_1_1_type_set.html#a2110dea550ae2c1eaf6ef65e2854f925" title="Emptiness check. " alt="" coords="230,56,405,83"/>
<area shape="rect" id="node4" href="structsouffle_1_1_type_set.html#ae26622401685d8ac9080b2f5a83d7eaa" title="Universality check. " alt="" coords="237,107,398,133"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a5c4839a38da22a968ab01e81a67d793c" title="Determines whether the given type is a number type. " alt="" coords="229,157,405,184"/>
<area shape="rect" id="node6" href="classsouffle_1_1_type.html#a2bc9172d0ce6390a7960b24b16172c79" title="souffle::Type::getTypeEnvironment" alt="" coords="453,128,700,155"/>
<area shape="rect" id="node7" href="classsouffle_1_1_type_environment.html#a0b191b7782e170a23b54f7ec347a32ab" title="souffle::TypeEnvironment\l::getUnsignedType" alt="" coords="483,179,670,221"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a0df5320dfcc5fe6ad9bbda0edc5876bc" title="Returns the type with the given name in the program. " alt="" coords="748,187,873,213"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="945,157,1049,184"/>
<area shape="rect" id="node10" href="classsouffle_1_1_ast_program.html#a0eca120e93df25229f5a39e6895137c2" title="get types " alt="" coords="921,209,1072,250"/>
<area shape="rect" id="node11" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1120,216,1267,243"/>
</map>
</div>

</div>
</div>
<a id="a1193e67992e4f0591e4011faccb4abe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1193e67992e4f0591e4011faccb4abe2">&#9670;&nbsp;</a></span>isValidFunctorOpArity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isValidFunctorOpArity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9">FunctorOp</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>arity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a functor operation can have a given argument count. </p>
<p>Unary Functor Operators</p>
<p>Binary Functor Operators</p>
<p>Ternary Functor Operators</p>
<p>Non-fixed </p>

<p class="definition">Definition at line <a class="el" href="_functor_ops_8h_source.html#l00098">98</a> of file <a class="el" href="_functor_ops_8h_source.html">FunctorOps.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9eeb52badb613229884838847294b90d">ADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aa8a5bbeedca093b94b7f0d3f185b98f7">BAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0fd78279a775c262180e0cfbad6fa9eb">BNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0adf6aac232504c55ea4202e09498bfd">BOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a88d973d6a866ababf2fb28a6112f8d46">BSHIFT_L</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9e74511ce5c138f374559a76abb6e209">BSHIFT_R</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3fdb4dd3e2677523449a3747923d4401">BSHIFT_R_UNSIGNED</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a21506bac4ecfbfe4272b9bf8185446b6">BXOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac01ae1a5f122f25ce5675f86028b536a">CAT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a29bbf66f7f8529ec47e394fb5a36c646">DIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a8c670f8c37b95e1ed14a0ce414b049c7">EXP</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc2cbacfa7c4ef9bc72773ebdd9fe166">FADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9abccb2b7436e0cbfb334fe07304fe28a6">FDIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a107c7a3cc48a0fe27d435e82c8679ef0">FEXP</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a1e692622d3020e12589d7fb475de73b1">FMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21aa188dc14c6a8fb8a3e7204027a3f16e6">FMIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a26a83f923754f1e7aa12640b8bcca29a">FMUL</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a36da8d8fdce0e080abfcab7af41066c6">FNEG</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a06be1058e817f781f4e0f0641f436247">FSUB</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a81bf488d5db54d36a738384aaf845fdf">FTOI</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a89aa92cb66549459a7d407094aacbcef">FTOU</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc526b23b5b6d76a12984c29bf63c4a3">ITOF</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4c0f1a4930775ab571de3e85aedc623e">ITOU</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a479a809c0b6eaaefd3b1df16f976df06">LAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a81145009eec44ad2c399c9459a01d8f0">LNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ad3335c358811cfc353257e21b1d38229">LOR</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a26a4b44a837bf97b972628509912b4a5">MAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21ace31e2a082d17e038fcc6e3006166653">MIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac5a28f4b35a2884fa3277150ac5d0967">MOD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2cdf52a55876063ec93b7d18bc741f6c">MUL</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a5dd68b1a7db42a1cce4dce09dbaa179e">NEG</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac23431d0209648a6b31fa837dd56d681">ORD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a00e365acdc6de6b62421116e865bd420">SMAX</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a2d9174ad446fde0fc750265f9e075977">SMIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9afc37711c3936f2459ef27e1dbe4f6480">STRLEN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a241dd841abade20fcb27b8a9f494e1eb">SUB</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a0f85e58dd75e7025beb47ee590ff7669">SUBSTR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aae9c007a17eb01f69e2dba22cf15cf30">TONUMBER</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a91b8cf1c9769ddb9cb64191c89becc1b">TOSTRING</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a1f0002abde2c29615d914ab0228c68d3">UADD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ab5755f546c5f5ca6a3f1720ef8e642ef">UBAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac2fc8ad7a275c06c870529f9f9f07caa">UBNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4803dabeb7190f48195a26654eafaa42">UBOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a653789f2eb8bfa402c5f60ceceac247b">UBSHIFT_L</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9aab623d5679ac1cc907cb363e2d51eb14">UBSHIFT_R</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a07da89f09f961f63a15696ac57bbc1c3">UBSHIFT_R_UNSIGNED</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a70f4367aed9601f37bfbdd4586b327df">UBXOR</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a56d5c96c848631ef14e1f2a6e0f15d49">UDIV</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a59407eef1229dea3aac5dc8d77d06c92">UEXP</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a3d0f34d8e784f8a48332424dd598a27a">ULAND</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a7fdc4b2848234d42fe9a22b78fd68910">ULNOT</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9addb2113545b6bd7fbe64ed7bff507964">ULOR</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21adf23c745cc30333029ae3a73cd87c059">UMAX</a>, <a class="el" href="namespacesouffle.html#aa26a7e6147aca5568158e38f08ffcf21a925d976d8f961af767954de9f62f40cb">UMIN</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a4bbe00e945b01d43cb7edecf51b0de5c">UMOD</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ae89690f1278cca1400678daaa4a6a3b7">UMUL</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9af8aba91736be4bad67181a8cce032337">USUB</a>, <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9a9d0ef69432b16260e9622b4f614bc9c5">UTOF</a>, and <a class="el" href="namespacesouffle.html#a28ddd8269d2a01a6041800d3b2e3fad9ac059c9401f1af0e831f9f180f3c6bfef">UTOI</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_argument_8h_source.html#l00274">souffle::AstIntrinsicFunctor::AstIntrinsicFunctor()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00504">combineAggregators()</a>.</p>
<div class="fragment"><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                                                                          {</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keywordflow">switch</span> (op) {<span class="comment"></span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="comment">        /** Unary Functor Operators */</span></div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ORD:</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <span class="keywordflow">case</span> FunctorOp::STRLEN:</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        <span class="keywordflow">case</span> FunctorOp::NEG:</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FNEG:</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BNOT:</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBNOT:</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LNOT:</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ULNOT:</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        <span class="keywordflow">case</span> FunctorOp::TONUMBER:</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        <span class="keywordflow">case</span> FunctorOp::TOSTRING:</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ITOU:</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UTOI:</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ITOF:</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FTOI:</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UTOF:</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FTOU:</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;            <span class="keywordflow">return</span> arity == 1;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment">        /** Binary Functor Operators */</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ADD:</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SUB:</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MUL:</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        <span class="keywordflow">case</span> FunctorOp::DIV:</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        <span class="keywordflow">case</span> FunctorOp::EXP:</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MOD:</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BAND:</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BOR:</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BXOR:</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_L:</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_R:</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        <span class="keywordflow">case</span> FunctorOp::BSHIFT_R_UNSIGNED:</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LAND:</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        <span class="keywordflow">case</span> FunctorOp::LOR:</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UADD:</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        <span class="keywordflow">case</span> FunctorOp::USUB:</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMUL:</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UDIV:</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UEXP:</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMOD:</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBAND:</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBOR:</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBXOR:</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBSHIFT_L:</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBSHIFT_R:</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UBSHIFT_R_UNSIGNED:</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ULAND:</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        <span class="keywordflow">case</span> FunctorOp::ULOR:</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FADD:</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FSUB:</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FMUL:</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FDIV:</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FEXP:</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            <span class="keywordflow">return</span> arity == 2;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="comment">        /** Ternary Functor Operators */</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SUBSTR:</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;            <span class="keywordflow">return</span> arity == 3;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="comment">        /** Non-fixed */</span></div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MAX:</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        <span class="keywordflow">case</span> FunctorOp::MIN:</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMAX:</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        <span class="keywordflow">case</span> FunctorOp::UMIN:</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FMAX:</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        <span class="keywordflow">case</span> FunctorOp::FMIN:</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SMAX:</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        <span class="keywordflow">case</span> FunctorOp::SMIN:</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        <span class="keywordflow">case</span> FunctorOp::CAT:</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;            <span class="keywordflow">return</span> arity &gt;= 2;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    }</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;unsupported operator&quot;</span>);</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a90ecff533a6bf91c15209f6fbb56235f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ecff533a6bf91c15209f6fbb56235f">&#9670;&nbsp;</a></span>isValidMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isValidMove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>leftIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rightIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the atom at leftIdx in the left clause can potentially be matched up with the atom at rightIdx in the right clause. </p>
<p>NOTE: index 0 refers to the head atom, index 1 to the first body atom, and so on. </p>

<p class="definition">Definition at line <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00136">136</a> of file <a class="el" href="_minimise_program_transformer_8cpp_source.html">MinimiseProgramTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_clause_8h_source.html#l00171">souffle::AstClause::getBodyLiterals()</a>, <a class="el" href="_ast_clause_8h_source.html#l00166">souffle::AstClause::getHead()</a>, and <a class="el" href="_ast_literal_8h_source.html#l00058">souffle::AstAtom::getQualifiedName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00249">areBijectivelyEquivalent()</a>.</p>
<div class="fragment"><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                                                                                                 {</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    <span class="comment">// handle the case where one of the indices refers to the head</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="keywordflow">if</span> (leftIdx == 0 &amp;&amp; rightIdx == 0) {</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        <span class="keyword">const</span> AstAtom* leftHead = left-&gt;getHead();</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        <span class="keyword">const</span> AstAtom* rightHead = right-&gt;getHead();</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        <span class="keywordflow">return</span> leftHead-&gt;getQualifiedName() == rightHead-&gt;getQualifiedName();</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (leftIdx == 0 || rightIdx == 0) {</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    }</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="comment">// both must hence be body atoms</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <span class="keywordtype">int</span> leftBodyAtomIdx = leftIdx - 1;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    <span class="keyword">const</span> AstAtom* leftAtom = <span class="keyword">dynamic_cast&lt;</span>AstAtom*<span class="keyword">&gt;</span>(left-&gt;getBodyLiterals()[leftBodyAtomIdx]);</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    assert(leftAtom != <span class="keyword">nullptr</span> &amp;&amp; <span class="stringliteral">&quot;expected atom&quot;</span>);</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <span class="keywordtype">int</span> rightBodyAtomIdx = rightIdx - 1;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <span class="keyword">const</span> AstAtom* rightAtom = <span class="keyword">dynamic_cast&lt;</span>AstAtom*<span class="keyword">&gt;</span>(right-&gt;getBodyLiterals()[rightBodyAtomIdx]);</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    assert(rightAtom != <span class="keyword">nullptr</span> &amp;&amp; <span class="stringliteral">&quot;expected atom&quot;</span>);</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <span class="keywordflow">return</span> leftAtom-&gt;getQualifiedName() == rightAtom-&gt;getQualifiedName();</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a90ecff533a6bf91c15209f6fbb56235f_cgraph.png" border="0" usemap="#namespacesouffle_a90ecff533a6bf91c15209f6fbb56235f_cgraph" alt=""/></div>
<map name="namespacesouffle_a90ecff533a6bf91c15209f6fbb56235f_cgraph" id="namespacesouffle_a90ecff533a6bf91c15209f6fbb56235f_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="264,5,403,47"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="264,71,403,112"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="205,137,461,163"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="509,13,656,39"/>
</map>
</div>

</div>
</div>
<a id="aa3867b63ae91058fdbcbff1475240b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3867b63ae91058fdbcbff1475240b16">&#9670;&nbsp;</a></span>isValidPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::isValidPermutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a valid variable mapping exists for the given permutation. </p>

<p class="definition">Definition at line <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00161">161</a> of file <a class="el" href="_minimise_program_transformer_8cpp_source.html">MinimiseProgramTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_clause_8h_source.html#l00190">souffle::AstClause::clone()</a>, <a class="el" href="_ast_clause_8h_source.html#l00171">souffle::AstClause::getBodyLiterals()</a>, <a class="el" href="_ast_clause_8h_source.html#l00166">souffle::AstClause::getHead()</a>, <a class="el" href="_ast_argument_8h_source.html#l00052">souffle::AstVariable::getName()</a>, <a class="el" href="_tui_8h_source.html#l00501">getName</a>, <a class="el" href="json11_8h_source.html#l00651">i</a>, <a class="el" href="html_js_chartist_min_8h_source.html#l00015">j</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00189">reorderAtoms()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00249">areBijectivelyEquivalent()</a>.</p>
<div class="fragment"><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                                                                                                   {</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    <span class="comment">// --- perform the permutation ---</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    <span class="keyword">auto</span> reorderedLeft = std::unique_ptr&lt;AstClause&gt;(left-&gt;clone());</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    <span class="comment">// deduce the body atom permutation from the full clause permutation</span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    std::vector&lt;unsigned int&gt; bodyPermutation(permutation.begin() + 1, permutation.end());</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> : bodyPermutation) {</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> -= 1;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    }</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    <span class="comment">// currently, &lt;permutation[i] == j&gt; indicates that atom i should map to position j</span></div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    <span class="comment">// internally, for the clause class&#39; reordering function, &lt;permutation[i] == j&gt; indicates</span></div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    <span class="comment">// that position i should contain atom j</span></div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    <span class="comment">// rearrange the permutation to match the internals</span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    <span class="comment">// TODO (azreika): perhaps change the internal reordering strategy because this came up in MST too</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    std::vector&lt;unsigned int&gt; reorderedPermutation(bodyPermutation.size());</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; bodyPermutation.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        reorderedPermutation[bodyPermutation[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>]] = <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    }</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    <span class="comment">// perform the permutation</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    reorderedLeft.reset(<a class="code" href="namespacesouffle.html#ae77f3374134c13b638bf7644fcebb5ef">reorderAtoms</a>(reorderedLeft.get(), reorderedPermutation));</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="comment">// --- check if a valid variable exists corresponding to this permutation ---</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    std::map&lt;std::string, std::string&gt; variableMap;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(*reorderedLeft, [&amp;](<span class="keyword">const</span> AstVariable&amp; var) { variableMap[var.getName()] = <span class="stringliteral">&quot;&quot;</span>; });</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    <span class="comment">// need to match the variables in the body</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    std::vector&lt;AstLiteral*&gt; leftAtoms = reorderedLeft-&gt;getBodyLiterals();</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    std::vector&lt;AstLiteral*&gt; rightAtoms = right-&gt;getBodyLiterals();</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="comment">// need to match the variables in the head</span></div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    leftAtoms.push_back(reorderedLeft-&gt;getHead());</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    rightAtoms.push_back(right-&gt;getHead());</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="comment">// check if a valid variable mapping exists</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="keyword">auto</span> isVariable = [](<span class="keyword">const</span> AstArgument* arg) { <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>AstVariable*<span class="keyword">&gt;</span>(arg) != <span class="keyword">nullptr</span>; };</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    <span class="keywordtype">bool</span> validMapping = <span class="keyword">true</span>;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; leftAtoms.size() &amp;&amp; validMapping; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        <span class="comment">// match arguments</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        assert(dynamic_cast&lt;AstAtom*&gt;(leftAtoms[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>]) != <span class="keyword">nullptr</span> &amp;&amp; <span class="stringliteral">&quot;expected atom&quot;</span>);</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        assert(dynamic_cast&lt;AstAtom*&gt;(rightAtoms[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>]) != <span class="keyword">nullptr</span> &amp;&amp; <span class="stringliteral">&quot;expected atom&quot;</span>);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        std::vector&lt;AstArgument*&gt; leftArgs = <span class="keyword">dynamic_cast&lt;</span>AstAtom*<span class="keyword">&gt;</span>(leftAtoms[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>])-&gt;getArguments();</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        std::vector&lt;AstArgument*&gt; rightArgs = <span class="keyword">dynamic_cast&lt;</span>AstAtom*<span class="keyword">&gt;</span>(rightAtoms[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>])-&gt;getArguments();</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> = 0; <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> &lt; leftArgs.size(); <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>++) {</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;            AstArgument* leftArg = leftArgs[<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>];</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;            AstArgument* rightArg = rightArgs[<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>];</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;            <span class="keywordflow">if</span> (isVariable(leftArg) &amp;&amp; isVariable(rightArg)) {</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                <span class="comment">// both variables, their names should match to each other through the clause</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                std::string leftVarName = <span class="keyword">dynamic_cast&lt;</span>AstVariable*<span class="keyword">&gt;</span>(leftArg)-&gt;<a class="code" href="namespacesouffle.html#a30960f5b40f826ffdc4cd2fb12161fe2">getName</a>();</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                std::string rightVarName = <span class="keyword">dynamic_cast&lt;</span>AstVariable*<span class="keyword">&gt;</span>(rightArg)-&gt;<a class="code" href="namespacesouffle.html#a30960f5b40f826ffdc4cd2fb12161fe2">getName</a>();</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                std::string currentMap = variableMap[leftVarName];</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                <span class="keywordflow">if</span> (currentMap.empty()) {</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                    <span class="comment">// unassigned yet, so assign it appropriately</span></div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                    variableMap[leftVarName] = rightVarName;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentMap != rightVarName) {</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                    <span class="comment">// mapping is inconsistent!</span></div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                    <span class="comment">// clauses cannot be equivalent under this permutation</span></div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                    validMapping = <span class="keyword">false</span>;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                }</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (castEq&lt;AstStringConstant&gt;(leftArg, rightArg)) {</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                validMapping = <span class="keyword">true</span>;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (castEq&lt;AstNumericConstant&gt;(leftArg, rightArg)) {</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;                validMapping = <span class="keyword">true</span>;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;AstNilConstant*&gt;(leftArg) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;                validMapping = <span class="keyword">dynamic_cast&lt;</span>AstNilConstant*<span class="keyword">&gt;</span>(rightArg) != <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                <span class="comment">// not the same type, failed!</span></div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;                validMapping = <span class="keyword">false</span>;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;            }</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        }</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    }</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    <span class="comment">// return whether a valid variable mapping exists for this permutation</span></div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    <span class="keywordflow">return</span> validMapping;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_aab858032a95af802114b255fac6f45f2"><div class="ttname"><a href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a></div><div class="ttdeci">var j</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a30960f5b40f826ffdc4cd2fb12161fe2"><div class="ttname"><a href="namespacesouffle.html#a30960f5b40f826ffdc4cd2fb12161fe2">souffle::getName</a></div><div class="ttdeci">ss&lt;&lt; R&quot;_(&quot;usage&quot;: [)_&quot;;bool firstRow=true;Usage previousUsage=*usages.begin();previousUsage.time=beginTime;for(auto usage :usages) { comma(firstRow);ss&lt;&lt; '[';ss&lt;&lt;(usage.time - beginTime).count()/1000000.0&lt;&lt; &quot;, &quot;;ss&lt;&lt; 100.0 *(usage.usertime - previousUsage.usertime)/(usage.time - previousUsage.time)&lt;&lt; &quot;, &quot;;ss&lt;&lt; 100.0 *(usage.systemtime - previousUsage.systemtime)/(usage.time - previousUsage.time)&lt;&lt; &quot;, &quot;;ss&lt;&lt; usage.maxRSS *1024&lt;&lt; &quot;, &quot;;ss&lt;&lt; '&quot;'; bool firstCol = true; for (auto&amp; cur : out.getProgramRun()-&gt;getRelationsAtTime(previousUsage.time, usage.time)) { comma(firstCol); ss &lt;&lt; cur-&gt; getName()</div><div class="ttdef"><b>Definition:</b> <a href="_tui_8h_source.html#l00501">Tui.h:501</a></div></div>
<div class="ttc" id="namespacesouffle_html_ae77f3374134c13b638bf7644fcebb5ef"><div class="ttname"><a href="namespacesouffle.html#ae77f3374134c13b638bf7644fcebb5ef">souffle::reorderAtoms</a></div><div class="ttdeci">AstClause * reorderAtoms(const AstClause *clause, const std::vector&lt; unsigned int &gt; &amp;newOrder)</div><div class="ttdoc">Reorders the atoms of a clause to be in the given order. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00189">AstUtils.cpp:189</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aa3867b63ae91058fdbcbff1475240b16_cgraph.png" border="0" usemap="#namespacesouffle_aa3867b63ae91058fdbcbff1475240b16_cgraph" alt=""/></div>
<map name="namespacesouffle_aa3867b63ae91058fdbcbff1475240b16_cgraph" id="namespacesouffle_aa3867b63ae91058fdbcbff1475240b16_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Create a clone (i.e. " alt="" coords="481,323,620,364"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="481,388,620,429"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="709,5,847,47"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_variable.html#a2b73a95c7b59624d956dee0ed4e13884" title="souffle::AstVariable\l::getName" alt="" coords="261,424,409,465"/>
<area shape="rect" id="node9" href="namespacesouffle.html#ae77f3374134c13b638bf7644fcebb5ef" title="Reorders the atoms of a clause to be in the given order. " alt="" coords="253,265,416,291"/>
<area shape="rect" id="node17" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="251,490,419,517"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="921,191,1121,218"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="723,305,833,331"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="705,406,851,433"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a6aa6d61f4a71ddbb2458d23ce24dbced" title="Returns a clause which contains head of the given clause. " alt="" coords="479,141,622,167"/>
<area shape="rect" id="node15" href="classsouffle_1_1_ast_clause.html#ac5e3416082d23734d1277daa5c9dee81" title="Add a Literal to the body of the clause. " alt="" coords="481,257,620,299"/>
<area shape="rect" id="node16" href="classsouffle_1_1_ast_literal.html#a8e7b7424c40acb87df022913c5928fd8" title="Create a clone (i.e. " alt="" coords="483,192,619,233"/>
<area shape="rect" id="node11" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Create a clone (i.e. " alt="" coords="691,71,865,98"/>
<area shape="rect" id="node13" href="classsouffle_1_1_ast_execution_plan.html#ac657ffa016ae777656585a56fc9a899c" title="Create a clone (i.e. " alt="" coords="685,123,871,164"/>
<area shape="rect" id="node14" href="classsouffle_1_1_ast_clause.html#aa943423c45971e70c837da5b88c8fc04" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="707,188,849,229"/>
<area shape="rect" id="node12" href="classsouffle_1_1_ast_atom.html#acef18129b13ce45477044717ded051d2" title="souffle::AstAtom::AstAtom" alt="" coords="924,71,1119,98"/>
<area shape="rect" id="node18" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="467,483,635,524"/>
<area shape="rect" id="node19" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="683,483,873,524"/>
</map>
</div>

</div>
</div>
<a id="abe4e3f19879707216a2758b03f4e2deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4e3f19879707216a2758b03f4e2deb">&#9670;&nbsp;</a></span>join() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter , typename Printer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">detail::joined_sequence</a>&lt;Iter, Printer&gt; souffle::join </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Printer &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an object to be forwarded to some output stream for printing sequences of elements interspersed by a given separator. </p>
<p>For use cases see the test case {util_test.cpp}. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00701">701</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00382">souffle::range&lt; Iter &gt;::a</a>, <a class="el" href="_util_8h_source.html#l00382">souffle::range&lt; Iter &gt;::b</a>, and <a class="el" href="html_js_chartist_min_8h_source.html#l00015">p</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00823">souffle::AstSemanticChecker::checkRecursiveUnionTypes()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00921">souffle::AstSemanticChecker::checkTypes()</a>, <a class="el" href="_synthesiser_8cpp_source.html#l00172">souffle::Synthesiser::emitCode()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00074">souffle::ExplainProvenanceImpl::explain()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00327">souffle::ExplainProvenanceImpl::explainNegation()</a>, <a class="el" href="_synthesiser_8cpp_source.html#l01730">souffle::Synthesiser::generateCode()</a>, <a class="el" href="_synthesiser_relation_8cpp_source.html#l00217">souffle::SynthesiserDirectRelation::generateTypeStruct()</a>, <a class="el" href="_synthesiser_relation_8cpp_source.html#l00520">souffle::SynthesiserIndirectRelation::generateTypeStruct()</a>, <a class="el" href="_synthesiser_relation_8cpp_source.html#l00788">souffle::SynthesiserBrieRelation::generateTypeStruct()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00182">souffle::AstTranslator::getOutputDirectives()</a>, <a class="el" href="_ast_translator_8h_source.html#l00297">souffle::AstTranslator::getRelationName()</a>, <a class="el" href="_synthesiser_relation_8cpp_source.html#l00201">souffle::SynthesiserDirectRelation::getTypeName()</a>, <a class="el" href="_synthesiser_relation_8cpp_source.html#l00504">souffle::SynthesiserIndirectRelation::getTypeName()</a>, <a class="el" href="_synthesiser_relation_8cpp_source.html#l00772">souffle::SynthesiserBrieRelation::getTypeName()</a>, <a class="el" href="_util_8h_source.html#l00713">join()</a>, <a class="el" href="main_8cpp_source.html#l00124">main()</a>, <a class="el" href="_provenance_transformer_8cpp_source.html#l00065">makeInfoRelation()</a>, <a class="el" href="_ast_parser_utils_8cpp_source.html#l00137">operator&lt;&lt;()</a>, <a class="el" href="_util_8h_source.html#l00760">std::operator&lt;&lt;()</a>, <a class="el" href="_ast_i_o_type_analysis_8cpp_source.html#l00049">souffle::IOType::print()</a>, <a class="el" href="_ast_clause_8h_source.html#l00057">souffle::AstExecutionOrder::print()</a>, <a class="el" href="_ast_functor_declaration_8h_source.html#l00068">souffle::AstFunctorDeclaration::print()</a>, <a class="el" href="_ast_component_8h_source.html#l00073">souffle::AstComponentType::print()</a>, <a class="el" href="_ast_qualified_name_8h_source.html#l00086">souffle::AstQualifiedName::print()</a>, <a class="el" href="_ast_i_o_8h_source.html#l00090">souffle::AstIO::print()</a>, <a class="el" href="_ast_literal_8h_source.html#l00106">souffle::AstAtom::print()</a>, <a class="el" href="_ram_expression_8h_source.html#l00113">souffle::RamIntrinsicOperator::print()</a>, <a class="el" href="_ast_clause_8h_source.html#l00115">souffle::AstExecutionPlan::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00119">souffle::RamIO::print()</a>, <a class="el" href="_type_system_8cpp_source.html#l00033">souffle::UnionType::print()</a>, <a class="el" href="_ast_relation_8h_source.html#l00135">souffle::AstRelation::print()</a>, <a class="el" href="_ast_type_8h_source.html#l00138">souffle::AstUnionType::print()</a>, <a class="el" href="_type_system_8cpp_source.html#l00043">souffle::RecordType::print()</a>, <a class="el" href="_ram_expression_8h_source.html#l00174">souffle::RamUserDefinedOperator::print()</a>, <a class="el" href="_symbol_table_8h_source.html#l00194">souffle::SymbolTable::print()</a>, <a class="el" href="_ast_clause_8h_source.html#l00219">souffle::AstClause::print()</a>, <a class="el" href="_ast_program_8h_source.html#l00221">souffle::AstProgram::print()</a>, <a class="el" href="_ast_translator_8h_source.html#l00273">souffle::AstTranslator::ValueIndex::print()</a>, <a class="el" href="_type_system_8h_source.html#l00304">souffle::TypeSet::print()</a>, <a class="el" href="_ram_condition_8h_source.html#l00306">souffle::RamAbstractExistenceCheck::print()</a>, <a class="el" href="_precedence_graph_8cpp_source.html#l00362">souffle::SCCGraph::print()</a>, <a class="el" href="_ast_argument_8h_source.html#l00318">souffle::AstIntrinsicFunctor::print()</a>, <a class="el" href="_ast_component_8h_source.html#l00341">souffle::AstComponent::print()</a>, <a class="el" href="_precedence_graph_8cpp_source.html#l00502">souffle::TopologicallySortedSCCGraph::print()</a>, <a class="el" href="_ast_argument_8h_source.html#l00389">souffle::AstUserDefinedFunctor::print()</a>, <a class="el" href="_constraints_8h_source.html#l00412">souffle::Problem&lt; Var &gt;::print()</a>, <a class="el" href="_ast_argument_8h_source.html#l00420">souffle::AstRecordInit::print()</a>, <a class="el" href="_ram_expression_8h_source.html#l00427">souffle::RamPackRecord::print()</a>, <a class="el" href="_ast_argument_8h_source.html#l00543">souffle::AstAggregator::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l01079">souffle::RamProject::print()</a>, and <a class="el" href="_ast_qualified_name_8h_source.html#l00066">souffle::AstQualifiedName::toString()</a>.</p>
<div class="fragment"><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;                                                                              {</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classsouffle_1_1detail_1_1joined__sequence.html">souffle::detail::joined_sequence&lt;Iter, Printer&gt;</a>(a, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, sep, <a class="code" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>);</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="classsouffle_1_1detail_1_1joined__sequence_html"><div class="ttname"><a href="classsouffle_1_1detail_1_1joined__sequence.html">souffle::detail::joined_sequence</a></div><div class="ttdoc">A auxiliary class to be returned by the join function aggregating the information required to print a...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00605">Util.h:605</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_a0e2839cf85d4f50ed7cdcc6c1b3adf83"><div class="ttname"><a href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a></div><div class="ttdeci">a horizontalBars(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})):a.axisX.type.call(c, c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})), l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y, b.normalized.series, o,{ticks:k}):a.axisY.type.call(c, c.Axis.units.y, b.normalized.series, o, a.axisY)) var p</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ff8ab73e5403aebf8bc9e0cd8a17655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff8ab73e5403aebf8bc9e0cd8a17655">&#9670;&nbsp;</a></span>join() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter , typename T  = typename Iter::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">detail::joined_sequence</a>&lt;Iter, <a class="el" href="structsouffle_1_1detail_1_1print.html">detail::print</a>&lt;<a class="el" href="structsouffle_1_1id.html">id</a>&lt;T&gt; &gt; &gt; souffle::join </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an object to be forwarded to some output stream for printing sequences of elements interspersed by a given separator. </p>
<p>For use cases see the test case {util_test.cpp}. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00713">713</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00701">join()</a>.</p>
<div class="fragment"><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;                                                                  {</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">join</a>(a, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, sep, detail::print&lt;id&lt;T&gt;&gt;());</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_af2f126a2c7d2ee710ec8600b2af64da3"><div class="ttname"><a href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">souffle::join</a></div><div class="ttdeci">detail::joined_sequence&lt; Iter, detail::print&lt; id&lt; T &gt; &gt; &gt; join(const Container &amp;c, const std::string &amp;sep=&quot;,&quot;)</div><div class="ttdoc">Creates an object to be forwarded to some output stream for printing the content of containers inters...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00737">Util.h:737</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a2ff8ab73e5403aebf8bc9e0cd8a17655_cgraph.png" border="0" usemap="#namespacesouffle_a2ff8ab73e5403aebf8bc9e0cd8a17655_cgraph" alt=""/></div>
<map name="namespacesouffle_a2ff8ab73e5403aebf8bc9e0cd8a17655_cgraph" id="namespacesouffle_a2ff8ab73e5403aebf8bc9e0cd8a17655_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb" title="Creates an object to be forwarded to some output stream for printing sequences of elements interspers..." alt="" coords="152,5,251,32"/>
</map>
</div>

</div>
</div>
<a id="af5411f3812147edc8be88140d80308bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5411f3812147edc8be88140d80308bd">&#9670;&nbsp;</a></span>join() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Printer , typename Iter  = typename Container::const_iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">detail::joined_sequence</a>&lt;Iter, Printer&gt; souffle::join </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Printer &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an object to be forwarded to some output stream for printing the content of containers interspersed by a given separator. </p>
<p>For use cases see the test case {util_test.cpp}. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00725">725</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00701">join()</a>, and <a class="el" href="html_js_chartist_min_8h_source.html#l00015">p</a>.</p>
<div class="fragment"><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;                                                                                                      {</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">join</a>(c.begin(), c.end(), sep, <a class="code" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>);</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a0e2839cf85d4f50ed7cdcc6c1b3adf83"><div class="ttname"><a href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a></div><div class="ttdeci">a horizontalBars(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})):a.axisX.type.call(c, c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})), l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y, b.normalized.series, o,{ticks:k}):a.axisY.type.call(c, c.Axis.units.y, b.normalized.series, o, a.axisY)) var p</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_af2f126a2c7d2ee710ec8600b2af64da3"><div class="ttname"><a href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">souffle::join</a></div><div class="ttdeci">detail::joined_sequence&lt; Iter, detail::print&lt; id&lt; T &gt; &gt; &gt; join(const Container &amp;c, const std::string &amp;sep=&quot;,&quot;)</div><div class="ttdoc">Creates an object to be forwarded to some output stream for printing the content of containers inters...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00737">Util.h:737</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_af5411f3812147edc8be88140d80308bd_cgraph.png" border="0" usemap="#namespacesouffle_af5411f3812147edc8be88140d80308bd_cgraph" alt=""/></div>
<map name="namespacesouffle_af5411f3812147edc8be88140d80308bd_cgraph" id="namespacesouffle_af5411f3812147edc8be88140d80308bd_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb" title="Creates an object to be forwarded to some output stream for printing sequences of elements interspers..." alt="" coords="152,5,251,32"/>
</map>
</div>

</div>
</div>
<a id="af2f126a2c7d2ee710ec8600b2af64da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f126a2c7d2ee710ec8600b2af64da3">&#9670;&nbsp;</a></span>join() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Iter  = typename Container::const_iterator, typename T  = typename Iter::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">detail::joined_sequence</a>&lt;Iter, <a class="el" href="structsouffle_1_1detail_1_1print.html">detail::print</a>&lt;<a class="el" href="structsouffle_1_1id.html">id</a>&lt;T&gt; &gt; &gt; souffle::join </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an object to be forwarded to some output stream for printing the content of containers interspersed by a given separator. </p>
<p>For use cases see the test case {util_test.cpp}. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00737">737</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00701">join()</a>.</p>
<div class="fragment"><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;                                                                                                     {</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">join</a>(c.begin(), c.end(), sep, detail::print&lt;id&lt;T&gt;&gt;());</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_af2f126a2c7d2ee710ec8600b2af64da3"><div class="ttname"><a href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">souffle::join</a></div><div class="ttdeci">detail::joined_sequence&lt; Iter, detail::print&lt; id&lt; T &gt; &gt; &gt; join(const Container &amp;c, const std::string &amp;sep=&quot;,&quot;)</div><div class="ttdoc">Creates an object to be forwarded to some output stream for printing the content of containers inters...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00737">Util.h:737</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_af2f126a2c7d2ee710ec8600b2af64da3_cgraph.png" border="0" usemap="#namespacesouffle_af2f126a2c7d2ee710ec8600b2af64da3_cgraph" alt=""/></div>
<map name="namespacesouffle_af2f126a2c7d2ee710ec8600b2af64da3_cgraph" id="namespacesouffle_af2f126a2c7d2ee710ec8600b2af64da3_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb" title="Creates an object to be forwarded to some output stream for printing sequences of elements interspers..." alt="" coords="152,5,251,32"/>
</map>
</div>

</div>
</div>
<a id="a052d35be8e032f425317fd1b6d7e487a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052d35be8e032f425317fd1b6d7e487a">&#9670;&nbsp;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int souffle::main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ensure that code generation is enabled if using SWIG interface option.</p>

<p class="definition">Definition at line <a class="el" href="main_8cpp_source.html#l00124">124</a> of file <a class="el" href="main_8cpp_source.html">main.cpp</a>.</p>

<p class="reference">References <a class="el" href="_debug_report_8h_source.html#l00100">souffle::DebugReport::addSection()</a>, <a class="el" href="_util_8h_source.html#l01182">baseName()</a>, <a class="el" href="main_8cpp_source.html#l00098">compileToBinary()</a>, <a class="el" href="_global_8h_source.html#l00135">souffle::Global::config()</a>, <a class="el" href="html_js_chartist_min_8h_source.html#l00015">e</a>, <a class="el" href="_debug_report_8h_source.html#l00130">souffle::DebugReport::endSection()</a>, <a class="el" href="main_8cpp_source.html#l00063">executeBinary()</a>, <a class="el" href="_util_8h_source.html#l01071">existDir()</a>, <a class="el" href="_util_8h_source.html#l01058">existFile()</a>, <a class="el" href="_explain_8h_source.html#l00621">explain()</a>, <a class="el" href="_util_8h_source.html#l01165">findTool()</a>, <a class="el" href="_global_8h_source.html#l00117">souffle::MainConfig::help()</a>, <a class="el" href="_util_8h_source.html#l01307">identifier()</a>, <a class="el" href="_util_8h_source.html#l01084">isExecutable()</a>, <a class="el" href="_util_8h_source.html#l00275">isNumber()</a>, <a class="el" href="_util_8h_source.html#l00701">join()</a>, <a class="el" href="_util_8h_source.html#l01037">now()</a>, <a class="el" href="_parser_driver_8cpp_source.html#l00082">souffle::ParserDriver::parseTranslationUnit()</a>, <a class="el" href="_global_8cpp_source.html#l00029">souffle::MainConfig::processArgs()</a>, <a class="el" href="_ram_types_8h_source.html#l00082">RAM_DOMAIN_SIZE</a>, <a class="el" href="_tui_8h_source.html#l00199">souffle::profile::Tui::runProf()</a>, <a class="el" href="_util_8h_source.html#l01202">simpleName()</a>, <a class="el" href="_util_8h_source.html#l00908">splitString()</a>, <a class="el" href="_tui_8h_source.html#l00319">souffle::profile::ss</a>, <a class="el" href="_debug_report_8h_source.html#l00126">souffle::DebugReport::startSection()</a>, <a class="el" href="_util_8h_source.html#l01240">tempFile()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l01731">souffle::AstTranslator::translateUnit()</a>, and <a class="el" href="_util_8h_source.html#l01091">which()</a>.</p>

<p class="reference">Referenced by <a class="el" href="main_8cpp_source.html#l00679">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                                {</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="comment">/* Time taking for overall runtime */</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="keyword">auto</span> souffle_start = <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">std::chrono::high_resolution_clock::now</a>();</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    <span class="comment">/* have all to do with command line arguments in its own scope, as these are accessible through the global</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment">     * configuration only */</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    <span class="keywordflow">try</span> {</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        std::stringstream header;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        header &lt;&lt; <span class="stringliteral">&quot;============================================================================&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        header &lt;&lt; <span class="stringliteral">&quot;souffle -- A datalog engine.&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        header &lt;&lt; <span class="stringliteral">&quot;Usage: souffle [OPTION] FILE.&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        header &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------------------------&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        header &lt;&lt; <span class="stringliteral">&quot;Options:&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        std::stringstream footer;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        footer &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------------------------&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        footer &lt;&lt; <span class="stringliteral">&quot;Version: &quot;</span> &lt;&lt; PACKAGE_VERSION &lt;&lt; <span class="stringliteral">&quot;&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        footer &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------------------------&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        footer &lt;&lt; <span class="stringliteral">&quot;Copyright (c) 2016-20 The Souffle Developers.&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        footer &lt;&lt; <span class="stringliteral">&quot;Copyright (c) 2013-16 Oracle and/or its affiliates.&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        footer &lt;&lt; <span class="stringliteral">&quot;All rights reserved.&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        footer &lt;&lt; <span class="stringliteral">&quot;============================================================================&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        <span class="comment">// command line options, the environment will be filled with the arguments passed to them, or</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        <span class="comment">// the empty string if they take none</span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        <span class="comment">// main option, the datalog program itself, has an empty key</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        std::vector&lt;MainOption&gt; options{{<span class="stringliteral">&quot;&quot;</span>, 0, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;&quot;</span>},</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                {<span class="stringliteral">&quot;fact-dir&quot;</span>, <span class="charliteral">&#39;F&#39;</span>, <span class="stringliteral">&quot;DIR&quot;</span>, <span class="stringliteral">&quot;.&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Specify directory for fact files.&quot;</span>},</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;                {<span class="stringliteral">&quot;include-dir&quot;</span>, <span class="charliteral">&#39;I&#39;</span>, <span class="stringliteral">&quot;DIR&quot;</span>, <span class="stringliteral">&quot;.&quot;</span>, <span class="keyword">true</span>, <span class="stringliteral">&quot;Specify directory for include files.&quot;</span>},</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                {<span class="stringliteral">&quot;output-dir&quot;</span>, <span class="charliteral">&#39;D&#39;</span>, <span class="stringliteral">&quot;DIR&quot;</span>, <span class="stringliteral">&quot;.&quot;</span>, <span class="keyword">false</span>,</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                        <span class="stringliteral">&quot;Specify directory for output files. If &lt;DIR&gt; is `-` then stdout is used.&quot;</span>},</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                {<span class="stringliteral">&quot;jobs&quot;</span>, <span class="charliteral">&#39;j&#39;</span>, <span class="stringliteral">&quot;N&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="keyword">false</span>,</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                        <span class="stringliteral">&quot;Run interpreter/compiler in parallel using N threads, N=auto for system &quot;</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;                        <span class="stringliteral">&quot;default.&quot;</span>},</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                {<span class="stringliteral">&quot;compile&quot;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                        <span class="stringliteral">&quot;Generate C++ source code, compile to a binary executable, then run this &quot;</span></div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                        <span class="stringliteral">&quot;executable.&quot;</span>},</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                {<span class="stringliteral">&quot;generate&quot;</span>, <span class="charliteral">&#39;g&#39;</span>, <span class="stringliteral">&quot;FILE&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                        <span class="stringliteral">&quot;Generate C++ source code for the given Datalog program and write it to &quot;</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                        <span class="stringliteral">&quot;&lt;FILE&gt;. If &lt;FILE&gt; is `-` then stdout is used.&quot;</span>},</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                {<span class="stringliteral">&quot;swig&quot;</span>, <span class="charliteral">&#39;s&#39;</span>, <span class="stringliteral">&quot;LANG&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                        <span class="stringliteral">&quot;Generate SWIG interface for given language. The values &lt;LANG&gt; accepts is java and &quot;</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                        <span class="stringliteral">&quot;python. &quot;</span>},</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                {<span class="stringliteral">&quot;library-dir&quot;</span>, <span class="charliteral">&#39;L&#39;</span>, <span class="stringliteral">&quot;DIR&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">true</span>, <span class="stringliteral">&quot;Specify directory for library files.&quot;</span>},</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                {<span class="stringliteral">&quot;libraries&quot;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="stringliteral">&quot;FILE&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">true</span>, <span class="stringliteral">&quot;Specify libraries.&quot;</span>},</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                {<span class="stringliteral">&quot;no-warn&quot;</span>, <span class="charliteral">&#39;w&#39;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Disable warnings.&quot;</span>},</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                {<span class="stringliteral">&quot;magic-transform&quot;</span>, <span class="charliteral">&#39;m&#39;</span>, <span class="stringliteral">&quot;RELATIONS&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                        <span class="stringliteral">&quot;Enable magic set transformation changes on the given relations, use &#39;*&#39; &quot;</span></div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                        <span class="stringliteral">&quot;for all.&quot;</span>},</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                {<span class="stringliteral">&quot;macro&quot;</span>, <span class="charliteral">&#39;M&#39;</span>, <span class="stringliteral">&quot;MACROS&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Set macro definitions for the pre-processor&quot;</span>},</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                {<span class="stringliteral">&quot;disable-transformers&quot;</span>, <span class="charliteral">&#39;z&#39;</span>, <span class="stringliteral">&quot;TRANSFORMERS&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                        <span class="stringliteral">&quot;Disable the given AST transformers.&quot;</span>},</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                {<span class="stringliteral">&quot;dl-program&quot;</span>, <span class="charliteral">&#39;o&#39;</span>, <span class="stringliteral">&quot;FILE&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                        <span class="stringliteral">&quot;Generate C++ source code, written to &lt;FILE&gt;, and compile this to a &quot;</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                        <span class="stringliteral">&quot;binary executable (without executing it).&quot;</span>},</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                {<span class="stringliteral">&quot;live-profile&quot;</span>, <span class="charliteral">&#39;\2&#39;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Enable live profiling.&quot;</span>},</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                {<span class="stringliteral">&quot;profile&quot;</span>, <span class="charliteral">&#39;p&#39;</span>, <span class="stringliteral">&quot;FILE&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Enable profiling, and write profile data to &lt;FILE&gt;.&quot;</span>},</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                {<span class="stringliteral">&quot;profile-use&quot;</span>, <span class="charliteral">&#39;u&#39;</span>, <span class="stringliteral">&quot;FILE&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                        <span class="stringliteral">&quot;Use profile log-file &lt;FILE&gt; for profile-guided optimization.&quot;</span>},</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                {<span class="stringliteral">&quot;debug-report&quot;</span>, <span class="charliteral">&#39;r&#39;</span>, <span class="stringliteral">&quot;FILE&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Write HTML debug report to &lt;FILE&gt;.&quot;</span>},</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                {<span class="stringliteral">&quot;pragma&quot;</span>, <span class="charliteral">&#39;P&#39;</span>, <span class="stringliteral">&quot;OPTIONS&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Set pragma options.&quot;</span>},</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                {<span class="stringliteral">&quot;provenance&quot;</span>, <span class="charliteral">&#39;t&#39;</span>, <span class="stringliteral">&quot;[ none | explain | explore | subtreeHeights ]&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>,</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                        <span class="stringliteral">&quot;Enable provenance instrumentation and interaction.&quot;</span>},</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                {<span class="stringliteral">&quot;verbose&quot;</span>, <span class="charliteral">&#39;v&#39;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Verbose output.&quot;</span>},</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                {<span class="stringliteral">&quot;version&quot;</span>, <span class="charliteral">&#39;\3&#39;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Version.&quot;</span>},</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                {<span class="stringliteral">&quot;show&quot;</span>, <span class="charliteral">&#39;\4&#39;</span>,</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;                        <span class="stringliteral">&quot;[ parse-errors | precedence-graph | scc-graph | transformed-datalog | &quot;</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                        <span class="stringliteral">&quot;transformed-ram | type-analysis ]&quot;</span>,</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                        <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Print selected program information.&quot;</span>},</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                {<span class="stringliteral">&quot;parse-errors&quot;</span>, <span class="charliteral">&#39;\5&#39;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Show parsing errors, if any, then exit.&quot;</span>},</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                {<span class="stringliteral">&quot;help&quot;</span>, <span class="charliteral">&#39;h&#39;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;Display this help message.&quot;</span>}};</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        Global::config().processArgs(argc, argv, header.str(), footer.str(), options);</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        <span class="comment">// ------ command line arguments -------------</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        <span class="comment">// Take in pragma options from the command line</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;pragma&quot;</span>)) {</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            std::vector&lt;std::string&gt; configOptions = <a class="code" href="namespacesouffle.html#a673608e9453179d30f6607384f54463a">splitString</a>(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;pragma&quot;</span>), <span class="charliteral">&#39;;&#39;</span>);</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> std::string&amp; option : configOptions) {</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                <span class="keywordtype">size_t</span> splitPoint = option.find(<span class="charliteral">&#39;:&#39;</span>);</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                std::string optionName = option.substr(0, splitPoint);</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                std::string optionValue = (splitPoint == std::string::npos)</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;                                                  ? <span class="stringliteral">&quot;&quot;</span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                                                  : option.substr(splitPoint + 1, option.length());</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                <span class="keywordflow">if</span> (!Global::config().has(optionName)) {</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                    Global::config().set(optionName, optionValue);</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                }</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;            }</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        }</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        <span class="comment">/* for the version option, if given print the version text then exit */</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;version&quot;</span>)) {</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;Souffle: &quot;</span> &lt;&lt; PACKAGE_VERSION;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; <a class="code" href="_ram_types_8h.html#a3d9f4f1ce25590d42211c679017d2ac5">RAM_DOMAIN_SIZE</a> &lt;&lt; <span class="stringliteral">&quot;bit Domains)&quot;</span>;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;            std::cout &lt;&lt; std::endl;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;Copyright (c) 2016-19 The Souffle Developers.&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;Copyright (c) 2013-16 Oracle and/or its affiliates.&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;            <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;        }</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        Global::config().set(<span class="stringliteral">&quot;version&quot;</span>, PACKAGE_VERSION);</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        <span class="comment">/* for the help option, if given simply print the help text then exit */</span></div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        <span class="keywordflow">if</span> (!Global::config().has(<span class="stringliteral">&quot;&quot;</span>) || Global::config().has(<span class="stringliteral">&quot;help&quot;</span>)) {</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;            std::cout &lt;&lt; Global::config().help();</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;            <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        }</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <span class="comment">/* check that datalog program exists */</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">existFile</a>(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;&quot;</span>))) {</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;cannot open file &quot;</span> + std::string(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;&quot;</span>)));</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        }</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        <span class="comment">/* for the jobs option, to determine the number of threads used */</span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="preprocessor">#ifdef _OPENMP</span></div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a56909036ae0514924e306d0a1a180837">isNumber</a>(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;jobs&quot;</span>).c_str())) {</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;            <span class="keywordflow">if</span> (std::stoi(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;jobs&quot;</span>)) &lt; 1) {</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;-j/--jobs may only be set to &#39;auto&#39; or an integer greater than 0.&quot;</span>);</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;            }</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;            <span class="keywordflow">if</span> (!Global::config().has(<span class="stringliteral">&quot;jobs&quot;</span>, <span class="stringliteral">&quot;auto&quot;</span>)) {</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;-j/--jobs may only be set to &#39;auto&#39; or an integer greater than 0.&quot;</span>);</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;            }</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;            Global::config().set(<span class="stringliteral">&quot;jobs&quot;</span>, <span class="stringliteral">&quot;0&quot;</span>);</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        }</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        <span class="comment">// Check that -j option has not been changed from the default</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        <span class="keywordflow">if</span> (Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;jobs&quot;</span>) != <span class="stringliteral">&quot;1&quot;</span>) {</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;            std::cerr &lt;&lt; <span class="stringliteral">&quot;\nThis installation of Souffle does not support concurrent jobs.\n&quot;</span>;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        }</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;        <span class="comment">/* if an output directory is given, check it exists */</span></div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;output-dir&quot;</span>) &amp;&amp; !Global::config().has(<span class="stringliteral">&quot;output-dir&quot;</span>, <span class="stringliteral">&quot;-&quot;</span>) &amp;&amp;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                !<a class="code" href="namespacesouffle.html#a79fa4170c4094bc943de6fa5acb5796e">existDir</a>(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;output-dir&quot;</span>)) &amp;&amp;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;                !(Global::config().has(<span class="stringliteral">&quot;generate&quot;</span>) ||</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                        (Global::config().has(<span class="stringliteral">&quot;dl-program&quot;</span>) &amp;&amp; !Global::config().has(<span class="stringliteral">&quot;compile&quot;</span>)))) {</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            <span class="keywordflow">throw</span> std::runtime_error(</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                    <span class="stringliteral">&quot;output directory &quot;</span> + Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;output-dir&quot;</span>) + <span class="stringliteral">&quot; does not exists&quot;</span>);</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        }</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;        <span class="comment">/* collect all input directories for the c pre-processor */</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;include-dir&quot;</span>)) {</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            std::string currentInclude = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;            std::string allIncludes = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>&amp; ch : Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;include-dir&quot;</span>)) {</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39; &#39;</span>) {</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                    <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a79fa4170c4094bc943de6fa5acb5796e">existDir</a>(currentInclude)) {</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;                        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;include directory &quot;</span> + currentInclude + <span class="stringliteral">&quot; does not exists&quot;</span>);</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                        allIncludes += <span class="stringliteral">&quot; -I&quot;</span>;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                        allIncludes += currentInclude;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                        currentInclude = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                    }</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                    currentInclude += ch;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                }</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;            }</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;            allIncludes += <span class="stringliteral">&quot; -I&quot;</span> + currentInclude;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;            Global::config().set(<span class="stringliteral">&quot;include-dir&quot;</span>, allIncludes);</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;        }</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;        <span class="comment">/* collect all macro definitions for the pre-processor */</span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;        <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;macro&quot;</span>)) {</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;            std::string currentMacro = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;            std::string allMacros = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>&amp; ch : Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;macro&quot;</span>)) {</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39; &#39;</span>) {</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                    allMacros += <span class="stringliteral">&quot; -D&quot;</span>;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                    allMacros += currentMacro;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                    currentMacro = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;                } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;                    currentMacro += ch;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                }</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;            }</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;            allMacros += <span class="stringliteral">&quot; -D&quot;</span> + currentMacro;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;            Global::config().set(<span class="stringliteral">&quot;macro&quot;</span>, allMacros);</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        }</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        <span class="comment">/* turn on compilation of executables */</span></div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;dl-program&quot;</span>)) {</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            Global::config().set(<span class="stringliteral">&quot;compile&quot;</span>);</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        }</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;live-profile&quot;</span>) &amp;&amp; !Global::config().has(<span class="stringliteral">&quot;profile&quot;</span>)) {</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            Global::config().set(<span class="stringliteral">&quot;profile&quot;</span>);</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        }</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    } <span class="keywordflow">catch</span> (std::exception&amp; <a class="code" href="html_js_chartist_min_8h.html#af6814cb38d86f56d30772f562eaee28e">e</a>) {</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        exit(1);</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    }</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="comment">     * Ensure that code generation is enabled if using SWIG interface option.</span></div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;swig&quot;</span>) &amp;&amp; !Global::config().has(<span class="stringliteral">&quot;generate&quot;</span>)) {</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        Global::config().set(<span class="stringliteral">&quot;generate&quot;</span>, <a class="code" href="namespacesouffle.html#ab31e06999eb72da2f6d9a85bdd3dda59">simpleName</a>(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;&quot;</span>)));</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    }</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <span class="comment">// ------ start souffle -------------</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    std::string souffleExecutable = <a class="code" href="namespacesouffle.html#a6e9757564e85959db8b14a9be7d544e1">which</a>(argv[0]);</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <span class="keywordflow">if</span> (souffleExecutable.empty()) {</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;failed to determine souffle executable path&quot;</span>);</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    }</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="comment">/* Create the pipe to establish a communication between cpp and souffle */</span></div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    std::string cmd = <a class="code" href="namespacesouffle.html#a6e9757564e85959db8b14a9be7d544e1">::which</a>(<span class="stringliteral">&quot;mcpp&quot;</span>);</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">isExecutable</a>(cmd)) {</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;failed to locate mcpp pre-processor&quot;</span>);</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    }</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    cmd += <span class="stringliteral">&quot; -e utf8 -W0 &quot;</span> + Global::config().get(<span class="stringliteral">&quot;include-dir&quot;</span>);</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;macro&quot;</span>)) {</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        cmd += <span class="stringliteral">&quot; &quot;</span> + Global::config().get(<span class="stringliteral">&quot;macro&quot;</span>);</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    }</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="comment">// Add RamDomain size as a macro</span></div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    cmd += <span class="stringliteral">&quot; -DRAM_DOMAIN_SIZE=&quot;</span> + std::to_string(<a class="code" href="_ram_types_8h.html#a3d9f4f1ce25590d42211c679017d2ac5">RAM_DOMAIN_SIZE</a>);</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    cmd += <span class="stringliteral">&quot; &quot;</span> + Global::config().get(<span class="stringliteral">&quot;&quot;</span>);</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    FILE* in = popen(cmd.c_str(), <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    <span class="comment">/* Time taking for parsing */</span></div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    <span class="keyword">auto</span> parser_start = <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">std::chrono::high_resolution_clock::now</a>();</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    <span class="comment">// ------- parse program -------------</span></div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    <span class="comment">// parse file</span></div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    ErrorReport errReport(Global::config().has(<span class="stringliteral">&quot;no-warn&quot;</span>));</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    DebugReport debugReport;</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    std::unique_ptr&lt;AstTranslationUnit&gt; astTranslationUnit =</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;            ParserDriver::parseTranslationUnit(<span class="stringliteral">&quot;&lt;stdin&gt;&quot;</span>, in, errReport, debugReport);</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <span class="comment">// close input pipe</span></div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="keywordtype">int</span> preprocessor_status = pclose(in);</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    <span class="keywordflow">if</span> (preprocessor_status == -1) {</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;        perror(<span class="keyword">nullptr</span>);</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;failed to close pre-processor pipe&quot;</span>);</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;    }</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    <span class="comment">/* Report run-time of the parser if verbose flag is set */</span></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;verbose&quot;</span>)) {</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        <span class="keyword">auto</span> parser_end = <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">std::chrono::high_resolution_clock::now</a>();</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;Parse Time: &quot;</span> &lt;&lt; std::chrono::duration&lt;double&gt;(parser_end - parser_start).count()</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;                  &lt;&lt; <span class="stringliteral">&quot;sec\n&quot;</span>;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    }</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    <span class="keywordflow">if</span> (Global::config().get(<span class="stringliteral">&quot;show&quot;</span>) == <span class="stringliteral">&quot;parse-errors&quot;</span>) {</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        std::cout &lt;&lt; astTranslationUnit-&gt;getErrorReport();</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;        <span class="keywordflow">return</span> astTranslationUnit-&gt;getErrorReport().getNumErrors();</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    }</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    <span class="comment">// ------- check for parse errors -------------</span></div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    <span class="keywordflow">if</span> (astTranslationUnit-&gt;getErrorReport().getNumErrors() != 0) {</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        std::cerr &lt;&lt; astTranslationUnit-&gt;getErrorReport();</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        std::cerr &lt;&lt; std::to_string(astTranslationUnit-&gt;getErrorReport().getNumErrors()) +</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;                             <span class="stringliteral">&quot; errors generated, evaluation aborted&quot;</span></div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;                  &lt;&lt; std::endl;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        exit(1);</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    }</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    <span class="comment">// ------- rewriting / optimizations -------------</span></div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    <span class="comment">/* set up additional global options based on pragma declaratives */</span></div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    (std::make_unique&lt;AstPragmaChecker&gt;())-&gt;apply(*astTranslationUnit);</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    <span class="comment">/* construct the transformation pipeline */</span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    <span class="comment">// Magic-Set pipeline</span></div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    <span class="keyword">auto</span> magicPipeline = std::make_unique&lt;ConditionalTransformer&gt;(Global::config().has(<span class="stringliteral">&quot;magic-transform&quot;</span>),</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;            std::make_unique&lt;PipelineTransformer&gt;(std::make_unique&lt;NormaliseConstraintsTransformer&gt;(),</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                    std::make_unique&lt;MagicSetTransformer&gt;(), std::make_unique&lt;ResolveAliasesTransformer&gt;(),</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;                    std::make_unique&lt;RemoveRelationCopiesTransformer&gt;(),</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;                    std::make_unique&lt;RemoveEmptyRelationsTransformer&gt;(),</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                    std::make_unique&lt;RemoveRedundantRelationsTransformer&gt;()));</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="comment">// Equivalence pipeline</span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="keyword">auto</span> equivalencePipeline =</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;            std::make_unique&lt;PipelineTransformer&gt;(std::make_unique&lt;MinimiseProgramTransformer&gt;(),</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;                    std::make_unique&lt;RemoveRelationCopiesTransformer&gt;(),</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;                    std::make_unique&lt;RemoveEmptyRelationsTransformer&gt;(),</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;                    std::make_unique&lt;RemoveRedundantRelationsTransformer&gt;());</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    <span class="comment">// Partitioning pipeline</span></div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    <span class="keyword">auto</span> partitionPipeline =</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;            std::make_unique&lt;PipelineTransformer&gt;(std::make_unique&lt;NameUnnamedVariablesTransformer&gt;(),</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;                    std::make_unique&lt;PartitionBodyLiteralsTransformer&gt;(),</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;                    std::make_unique&lt;ReplaceSingletonVariablesTransformer&gt;());</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    <span class="comment">// Provenance pipeline</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    <span class="keyword">auto</span> provenancePipeline = std::make_unique&lt;PipelineTransformer&gt;(std::make_unique&lt;ConditionalTransformer&gt;(</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;            Global::config().has(<span class="stringliteral">&quot;provenance&quot;</span>), std::make_unique&lt;ProvenanceTransformer&gt;()));</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    <span class="comment">// Main pipeline</span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <span class="keyword">auto</span> pipeline = std::make_unique&lt;PipelineTransformer&gt;(std::make_unique&lt;AstComponentChecker&gt;(),</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;            std::make_unique&lt;ComponentInstantiationTransformer&gt;(),</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;            std::make_unique&lt;UniqueAggregationVariablesTransformer&gt;(),</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;            std::make_unique&lt;AstUserDefinedFunctorsTransformer&gt;(),</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;            std::make_unique&lt;FixpointTransformer&gt;(</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;                    std::make_unique&lt;PipelineTransformer&gt;(std::make_unique&lt;ResolveAnonymousRecordsAliases&gt;(),</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;                            std::make_unique&lt;FoldAnonymousRecords&gt;())),</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;            std::make_unique&lt;PolymorphicObjectsTransformer&gt;(), std::make_unique&lt;AstSemanticChecker&gt;(),</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;            std::make_unique&lt;RemoveTypecastsTransformer&gt;(),</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;            std::make_unique&lt;RemoveBooleanConstraintsTransformer&gt;(),</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;            std::make_unique&lt;ResolveAliasesTransformer&gt;(), std::make_unique&lt;MinimiseProgramTransformer&gt;(),</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;            std::make_unique&lt;InlineRelationsTransformer&gt;(), std::make_unique&lt;ResolveAliasesTransformer&gt;(),</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;            std::make_unique&lt;RemoveRedundantRelationsTransformer&gt;(),</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;            std::make_unique&lt;RemoveRelationCopiesTransformer&gt;(),</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;            std::make_unique&lt;RemoveEmptyRelationsTransformer&gt;(),</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;            std::make_unique&lt;ReplaceSingletonVariablesTransformer&gt;(),</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;            std::make_unique&lt;FixpointTransformer&gt;(</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;                    std::make_unique&lt;PipelineTransformer&gt;(std::make_unique&lt;ReduceExistentialsTransformer&gt;(),</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;                            std::make_unique&lt;RemoveRedundantRelationsTransformer&gt;())),</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;            std::make_unique&lt;RemoveRelationCopiesTransformer&gt;(), std::move(partitionPipeline),</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;            std::make_unique&lt;FixpointTransformer&gt;(std::make_unique&lt;MinimiseProgramTransformer&gt;()),</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            std::make_unique&lt;RemoveRelationCopiesTransformer&gt;(),</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;            std::make_unique&lt;ReorderLiteralsTransformer&gt;(),</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;            std::make_unique&lt;PipelineTransformer&gt;(std::make_unique&lt;ResolveAliasesTransformer&gt;(),</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;                    std::make_unique&lt;MaterializeAggregationQueriesTransformer&gt;()),</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;            std::make_unique&lt;RemoveRedundantSumsTransformer&gt;(),</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;            std::make_unique&lt;RemoveEmptyRelationsTransformer&gt;(),</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;            std::make_unique&lt;ReorderLiteralsTransformer&gt;(), std::move(magicPipeline),</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;            std::make_unique&lt;AstExecutionPlanChecker&gt;(), std::move(provenancePipeline));</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    <span class="comment">// Disable unwanted transformations</span></div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;disable-transformers&quot;</span>)) {</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;        std::vector&lt;std::string&gt; givenTransformers =</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                <a class="code" href="namespacesouffle.html#a673608e9453179d30f6607384f54463a">splitString</a>(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;disable-transformers&quot;</span>), <span class="charliteral">&#39;,&#39;</span>);</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;        pipeline-&gt;disableTransformers(</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;                std::set&lt;std::string&gt;(givenTransformers.begin(), givenTransformers.end()));</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    }</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    <span class="comment">// Set up the debug report if necessary</span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;debug-report&quot;</span>)) {</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;        <span class="keyword">auto</span> parser_end = <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">std::chrono::high_resolution_clock::now</a>();</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;        std::stringstream <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a>;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;        <span class="comment">// Add current time</span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;        std::time_t time = std::time(<span class="keyword">nullptr</span>);</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        ss &lt;&lt; <span class="stringliteral">&quot;Executed at &quot;</span>;</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        ss &lt;&lt; std::put_time(std::localtime(&amp;time), <span class="stringliteral">&quot;%F %T&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        <span class="comment">// Add config</span></div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        ss &lt;&lt; <span class="stringliteral">&quot;(\n&quot;</span>;</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;        ss &lt;&lt; <a class="code" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">join</a>(Global::config().data(), <span class="stringliteral">&quot;,\n&quot;</span>, [](std::ostream&amp; out, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; arg) {</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;            out &lt;&lt; <span class="stringliteral">&quot;  \&quot;&quot;</span> &lt;&lt; arg.first &lt;&lt; <span class="stringliteral">&quot;\&quot; -&gt; \&quot;&quot;</span> &lt;&lt; arg.second &lt;&lt; <span class="charliteral">&#39;&quot;&#39;</span>;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        });</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;        ss &lt;&lt; <span class="stringliteral">&quot;\n)&quot;</span>;</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;        debugReport.addSection(<span class="stringliteral">&quot;Configuration&quot;</span>, <span class="stringliteral">&quot;Configuration&quot;</span>, ss.str());</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;        <span class="comment">// Add parsing runtime</span></div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;        std::string runtimeStr =</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;                <span class="stringliteral">&quot;(&quot;</span> + std::to_string(std::chrono::duration&lt;double&gt;(parser_end - parser_start).count()) + <span class="stringliteral">&quot;s)&quot;</span>;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        debugReport.addSection(<span class="stringliteral">&quot;Parsing&quot;</span>, <span class="stringliteral">&quot;Parsing &quot;</span> + runtimeStr, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        pipeline-&gt;setDebugReport();</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    }</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    <span class="comment">// Toggle pipeline verbosity</span></div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    pipeline-&gt;setVerbosity(Global::config().has(<span class="stringliteral">&quot;verbose&quot;</span>));</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    <span class="comment">// Apply all the transformations</span></div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    pipeline-&gt;apply(*astTranslationUnit);</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;show&quot;</span>)) {</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        <span class="comment">// Output the transformed datalog and return</span></div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;        <span class="keywordflow">if</span> (Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;show&quot;</span>) == <span class="stringliteral">&quot;transformed-datalog&quot;</span>) {</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;            std::cout &lt;&lt; *astTranslationUnit-&gt;getProgram() &lt;&lt; std::endl;</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;            <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        }</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        <span class="comment">// Output the precedence graph in graphviz dot format and return</span></div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;        <span class="keywordflow">if</span> (Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;show&quot;</span>) == <span class="stringliteral">&quot;precedence-graph&quot;</span>) {</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;            astTranslationUnit-&gt;getAnalysis&lt;PrecedenceGraph&gt;()-&gt;print(std::cout);</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;            std::cout &lt;&lt; std::endl;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;            <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;        }</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        <span class="comment">// Output the scc graph in graphviz dot format and return</span></div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        <span class="keywordflow">if</span> (Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;show&quot;</span>) == <span class="stringliteral">&quot;scc-graph&quot;</span>) {</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;            astTranslationUnit-&gt;getAnalysis&lt;SCCGraph&gt;()-&gt;print(std::cout);</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;            std::cout &lt;&lt; std::endl;</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;            <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        }</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;        <span class="comment">// Output the type analysis</span></div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;        <span class="keywordflow">if</span> (Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;show&quot;</span>) == <span class="stringliteral">&quot;type-analysis&quot;</span>) {</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;            astTranslationUnit-&gt;getAnalysis&lt;TypeAnalysis&gt;()-&gt;print(std::cout);</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;            std::cout &lt;&lt; std::endl;</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;            <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;        }</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;    }</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    <span class="comment">// ------- execution -------------</span></div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    <span class="comment">/* translate AST to RAM */</span></div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    debugReport.startSection();</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    std::unique_ptr&lt;RamTranslationUnit&gt; ramTranslationUnit =</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;            AstTranslator().translateUnit(*astTranslationUnit);</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    debugReport.endSection(<span class="stringliteral">&quot;ast-to-ram&quot;</span>, <span class="stringliteral">&quot;Translate AST to RAM&quot;</span>);</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    std::unique_ptr&lt;RamTransformer&gt; ramTransform = std::make_unique&lt;RamTransformerSequence&gt;(</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;            std::make_unique&lt;RamLoopTransformer&gt;(</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;                    std::make_unique&lt;RamTransformerSequence&gt;(std::make_unique&lt;ExpandFilterTransformer&gt;(),</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;                            std::make_unique&lt;HoistConditionsTransformer&gt;(),</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;                            std::make_unique&lt;MakeIndexTransformer&gt;())),</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;            std::make_unique&lt;IfConversionTransformer&gt;(), std::make_unique&lt;ChoiceConversionTransformer&gt;(),</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;            std::make_unique&lt;CollapseFiltersTransformer&gt;(), std::make_unique&lt;TupleIdTransformer&gt;(),</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;            std::make_unique&lt;RamLoopTransformer&gt;(std::make_unique&lt;RamTransformerSequence&gt;(</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;                    std::make_unique&lt;HoistAggregateTransformer&gt;(), std::make_unique&lt;TupleIdTransformer&gt;())),</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;            std::make_unique&lt;ExpandFilterTransformer&gt;(), std::make_unique&lt;HoistConditionsTransformer&gt;(),</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;            std::make_unique&lt;CollapseFiltersTransformer&gt;(),</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;            std::make_unique&lt;EliminateDuplicatesTransformer&gt;(),</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;            std::make_unique&lt;ReorderConditionsTransformer&gt;(),</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;            std::make_unique&lt;RamLoopTransformer&gt;(std::make_unique&lt;ReorderFilterBreak&gt;()),</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;            std::make_unique&lt;RamConditionalTransformer&gt;(</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;                    <span class="comment">// job count of 0 means all cores are used.</span></div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;                    []() -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span> std::stoi(Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;jobs&quot;</span>)) != 1; },</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;                    std::make_unique&lt;ParallelTransformer&gt;()),</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;            std::make_unique&lt;ReportIndexTransformer&gt;());</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    ramTransform-&gt;apply(*ramTranslationUnit);</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;    <span class="keywordflow">if</span> (ramTranslationUnit-&gt;getErrorReport().getNumIssues() != 0) {</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;        std::cerr &lt;&lt; ramTranslationUnit-&gt;getErrorReport();</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;    }</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;    <span class="comment">// Output the transformed RAM program and return</span></div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;    <span class="keywordflow">if</span> (Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;show&quot;</span>) == <span class="stringliteral">&quot;transformed-ram&quot;</span>) {</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;        std::cout &lt;&lt; ramTranslationUnit-&gt;getProgram();</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;    }</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;    <span class="keywordflow">try</span> {</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;        <span class="keywordflow">if</span> (!Global::config().has(<span class="stringliteral">&quot;compile&quot;</span>) &amp;&amp; !Global::config().has(<span class="stringliteral">&quot;dl-program&quot;</span>) &amp;&amp;</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;                !Global::config().has(<span class="stringliteral">&quot;generate&quot;</span>) &amp;&amp; !Global::config().has(<span class="stringliteral">&quot;swig&quot;</span>)) {</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;            <span class="comment">// ------- interpreter -------------</span></div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;            std::thread profiler;</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;            <span class="comment">// Start up profiler if needed</span></div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;            <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;live-profile&quot;</span>) &amp;&amp; !Global::config().has(<span class="stringliteral">&quot;compile&quot;</span>)) {</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;                profiler = std::thread([]() { profile::Tui().runProf(); });</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;            }</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;            <span class="comment">// configure and execute interpreter</span></div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;            std::unique_ptr&lt;InterpreterEngine&gt; interpreter(</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;                    std::make_unique&lt;InterpreterEngine&gt;(*ramTranslationUnit));</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;            interpreter-&gt;executeMain();</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;            <span class="comment">// If the profiler was started, join back here once it exits.</span></div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;            <span class="keywordflow">if</span> (profiler.joinable()) {</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;                profiler.join();</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;            }</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;            <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;provenance&quot;</span>)) {</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;                <span class="comment">// Test for bugged combination of provenance, interpreted souffle, and concurrency</span></div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;                <span class="keywordflow">if</span> (Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;jobs&quot;</span>) != <span class="stringliteral">&quot;1&quot;</span>) {</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;                    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Provenance is not supported with parallel interpreted mode&quot;</span>);</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;                }</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;                <span class="comment">// only run explain interface if interpreted</span></div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;                InterpreterProgInterface interface(*interpreter);</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;                <span class="keywordflow">if</span> (Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;provenance&quot;</span>) == <span class="stringliteral">&quot;explain&quot;</span> ||</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;                        Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;provenance&quot;</span>) == <span class="stringliteral">&quot;subtreeHeights&quot;</span>) {</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;                    <a class="code" href="namespacesouffle.html#ab5c20b82d0becb6b4e3b780c2c87cc62">explain</a>(interface, <span class="keyword">false</span>, Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;provenance&quot;</span>) == <span class="stringliteral">&quot;subtreeHeights&quot;</span>);</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Global::config().<span class="keyword">get</span>(<span class="stringliteral">&quot;provenance&quot;</span>) == <span class="stringliteral">&quot;explore&quot;</span>) {</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                    <a class="code" href="namespacesouffle.html#ab5c20b82d0becb6b4e3b780c2c87cc62">explain</a>(interface, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;                }</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;            }</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;            <span class="comment">// ------- compiler -------------</span></div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;            std::unique_ptr&lt;Synthesiser&gt; synthesiser = std::make_unique&lt;Synthesiser&gt;(*ramTranslationUnit);</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;            <span class="comment">// Find the base filename for code generation and execution</span></div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;            std::string baseFilename;</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;            <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;dl-program&quot;</span>)) {</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;                baseFilename = Global::config().get(<span class="stringliteral">&quot;dl-program&quot;</span>);</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;generate&quot;</span>)) {</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;                baseFilename = Global::config().get(<span class="stringliteral">&quot;generate&quot;</span>);</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;                <span class="comment">// trim .cpp extension if it exists</span></div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;                <span class="keywordflow">if</span> (baseFilename.size() &gt;= 4 &amp;&amp; baseFilename.substr(baseFilename.size() - 4) == <span class="stringliteral">&quot;.cpp&quot;</span>) {</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;                    baseFilename = baseFilename.substr(0, baseFilename.size() - 4);</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;                }</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;                baseFilename = <a class="code" href="namespacesouffle.html#a2122cfa5acdee4846ecda0855f0beee4">tempFile</a>();</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;            }</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4">baseName</a>(baseFilename) == <span class="stringliteral">&quot;/&quot;</span> || <a class="code" href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4">baseName</a>(baseFilename) == <span class="stringliteral">&quot;.&quot;</span>) {</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;                baseFilename = <a class="code" href="namespacesouffle.html#a2122cfa5acdee4846ecda0855f0beee4">tempFile</a>();</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;            }</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;            std::string baseIdentifier = <a class="code" href="namespacesouffle.html#ad0e8debde5608979e041dd30e044612a">identifier</a>(<a class="code" href="namespacesouffle.html#ab31e06999eb72da2f6d9a85bdd3dda59">simpleName</a>(baseFilename));</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;            std::string sourceFilename = baseFilename + <span class="stringliteral">&quot;.cpp&quot;</span>;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;            <span class="keywordtype">bool</span> withSharedLibrary;</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">bool</span> emitToStdOut = Global::config().has(<span class="stringliteral">&quot;generate&quot;</span>, <span class="stringliteral">&quot;-&quot;</span>);</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;            <span class="keywordflow">if</span> (emitToStdOut)</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;                synthesiser-&gt;generateCode(std::cout, baseIdentifier, withSharedLibrary);</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;            <span class="keywordflow">else</span> {</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;                std::ofstream os{sourceFilename};</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;                synthesiser-&gt;generateCode(os, baseIdentifier, withSharedLibrary);</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;            }</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;            <span class="keywordflow">if</span> (withSharedLibrary) {</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;                <span class="keywordflow">if</span> (!Global::config().has(<span class="stringliteral">&quot;libraries&quot;</span>)) {</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;                    Global::config().set(<span class="stringliteral">&quot;libraries&quot;</span>, <span class="stringliteral">&quot;functors&quot;</span>);</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;                }</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;                <span class="keywordflow">if</span> (!Global::config().has(<span class="stringliteral">&quot;library-dir&quot;</span>)) {</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;                    Global::config().set(<span class="stringliteral">&quot;library-dir&quot;</span>, <span class="stringliteral">&quot;.&quot;</span>);</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;                }</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;            }</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;            <span class="keyword">auto</span> findCompileCmd = [&amp;] {</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;                <span class="keyword">auto</span> cmd = <a class="code" href="namespacesouffle.html#af944f0c474df29e5c8e45e4b7df60be5">::findTool</a>(<span class="stringliteral">&quot;souffle-compile&quot;</span>, souffleExecutable, <span class="stringliteral">&quot;.&quot;</span>);</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;                <span class="comment">/* Fail if a souffle-compile executable is not found */</span></div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;                <span class="keywordflow">if</span> (!<a class="code" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">isExecutable</a>(cmd)) {</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;                    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;failed to locate souffle-compile&quot;</span>);</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;                }</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;                <span class="keywordflow">return</span> cmd;</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;            };</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;            <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;swig&quot;</span>)) {</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;                <span class="keyword">auto</span> compileCmd = findCompileCmd() + <span class="stringliteral">&quot; -s &quot;</span> + Global::config().get(<span class="stringliteral">&quot;swig&quot;</span>) + <span class="stringliteral">&quot; &quot;</span>;</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;                <a class="code" href="namespacesouffle.html#a97d640155c037c468924198354aae2ea">compileToBinary</a>(compileCmd, sourceFilename);</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;compile&quot;</span>)) {</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;                <span class="keyword">auto</span> start = <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">std::chrono::high_resolution_clock::now</a>();</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;                <a class="code" href="namespacesouffle.html#a97d640155c037c468924198354aae2ea">compileToBinary</a>(findCompileCmd(), sourceFilename);</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;                <span class="comment">/* Report overall run-time in verbose mode */</span></div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;                <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;verbose&quot;</span>)) {</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;                    <span class="keyword">auto</span> end = <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">std::chrono::high_resolution_clock::now</a>();</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;                    std::cout &lt;&lt; <span class="stringliteral">&quot;Compilation Time: &quot;</span> &lt;&lt; std::chrono::duration&lt;double&gt;(end - start).count()</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;                              &lt;&lt; <span class="stringliteral">&quot;sec\n&quot;</span>;</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;                }</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;                <span class="comment">// run compiled C++ program if requested.</span></div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;                <span class="keywordflow">if</span> (!Global::config().has(<span class="stringliteral">&quot;dl-program&quot;</span>) &amp;&amp; !Global::config().has(<span class="stringliteral">&quot;swig&quot;</span>)) {</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                    <a class="code" href="namespacesouffle.html#a1752bf432062837ed19ae6ac73ab177c">executeBinary</a>(baseFilename);</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;                }</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;            }</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;        }</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;    } <span class="keywordflow">catch</span> (std::exception&amp; e) {</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;        std::exit(1);</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;    }</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;    <span class="comment">/* Report overall run-time in verbose mode */</span></div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;    <span class="keywordflow">if</span> (Global::config().has(<span class="stringliteral">&quot;verbose&quot;</span>)) {</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;        <span class="keyword">auto</span> souffle_end = <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">std::chrono::high_resolution_clock::now</a>();</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;Total Time: &quot;</span> &lt;&lt; std::chrono::duration&lt;double&gt;(souffle_end - souffle_start).count()</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;                  &lt;&lt; <span class="stringliteral">&quot;sec\n&quot;</span>;</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;    }</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_ab31e06999eb72da2f6d9a85bdd3dda59"><div class="ttname"><a href="namespacesouffle.html#ab31e06999eb72da2f6d9a85bdd3dda59">souffle::simpleName</a></div><div class="ttdeci">std::string simpleName(const std::string &amp;path)</div><div class="ttdoc">File name, with extension removed. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01202">Util.h:1202</a></div></div>
<div class="ttc" id="namespacesouffle_1_1profile_html_a6b765acdf677f188e059ac9860c5046d"><div class="ttname"><a href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">souffle::profile::ss</a></div><div class="ttdeci">class souffle::profile::Tui ss</div><div class="ttdef"><b>Definition:</b> <a href="_tui_8h_source.html#l00319">Tui.h:319</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_af6814cb38d86f56d30772f562eaee28e"><div class="ttname"><a href="html_js_chartist_min_8h.html#af6814cb38d86f56d30772f562eaee28e">e</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter e</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a1c65551944c7ecf6f44ec851b49bdbb0"><div class="ttname"><a href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">souffle::now</a></div><div class="ttdeci">time_point now()</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01037">Util.h:1037</a></div></div>
<div class="ttc" id="namespacesouffle_html_abe4e3f19879707216a2758b03f4e2deb"><div class="ttname"><a href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">souffle::join</a></div><div class="ttdeci">detail::joined_sequence&lt; Iter, Printer &gt; join(const Iter &amp;a, const Iter &amp;b, const std::string &amp;sep, const Printer &amp;p)</div><div class="ttdoc">Creates an object to be forwarded to some output stream for printing sequences of elements interspers...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00701">Util.h:701</a></div></div>
<div class="ttc" id="namespacesouffle_html_a64753e143a37bb9414121fc75987cb14"><div class="ttname"><a href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">souffle::isExecutable</a></div><div class="ttdeci">bool isExecutable(const std::string &amp;name)</div><div class="ttdoc">Check whether a given file exists and it is an executable. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01084">Util.h:1084</a></div></div>
<div class="ttc" id="namespacesouffle_html_ad0e8debde5608979e041dd30e044612a"><div class="ttname"><a href="namespacesouffle.html#ad0e8debde5608979e041dd30e044612a">souffle::identifier</a></div><div class="ttdeci">std::string identifier(std::string id)</div><div class="ttdoc">Valid C++ identifier, note that this does not ensure the uniqueness of identifiers returned...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01307">Util.h:1307</a></div></div>
<div class="ttc" id="namespacesouffle_html_a79fa4170c4094bc943de6fa5acb5796e"><div class="ttname"><a href="namespacesouffle.html#a79fa4170c4094bc943de6fa5acb5796e">souffle::existDir</a></div><div class="ttdeci">bool existDir(const std::string &amp;name)</div><div class="ttdoc">Check whether a directory exists in the file system. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01071">Util.h:1071</a></div></div>
<div class="ttc" id="namespacesouffle_html_af944f0c474df29e5c8e45e4b7df60be5"><div class="ttname"><a href="namespacesouffle.html#af944f0c474df29e5c8e45e4b7df60be5">souffle::findTool</a></div><div class="ttdeci">std::string findTool(const std::string &amp;tool, const std::string &amp;base, const std::string &amp;path)</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01165">Util.h:1165</a></div></div>
<div class="ttc" id="namespacesouffle_html_a6e9757564e85959db8b14a9be7d544e1"><div class="ttname"><a href="namespacesouffle.html#a6e9757564e85959db8b14a9be7d544e1">souffle::which</a></div><div class="ttdeci">std::string which(const std::string &amp;name)</div><div class="ttdoc">Simple implementation of a which tool. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01091">Util.h:1091</a></div></div>
<div class="ttc" id="namespacesouffle_html_a1752bf432062837ed19ae6ac73ab177c"><div class="ttname"><a href="namespacesouffle.html#a1752bf432062837ed19ae6ac73ab177c">souffle::executeBinary</a></div><div class="ttdeci">void executeBinary(const std::string &amp;binaryFilename)</div><div class="ttdoc">Executes a binary file. </div><div class="ttdef"><b>Definition:</b> <a href="main_8cpp_source.html#l00063">main.cpp:63</a></div></div>
<div class="ttc" id="_ram_types_8h_html_a3d9f4f1ce25590d42211c679017d2ac5"><div class="ttname"><a href="_ram_types_8h.html#a3d9f4f1ce25590d42211c679017d2ac5">RAM_DOMAIN_SIZE</a></div><div class="ttdeci">#define RAM_DOMAIN_SIZE</div><div class="ttdoc">Types of elements in a tuple. </div><div class="ttdef"><b>Definition:</b> <a href="_ram_types_8h_source.html#l00082">RamTypes.h:82</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab5c20b82d0becb6b4e3b780c2c87cc62"><div class="ttname"><a href="namespacesouffle.html#ab5c20b82d0becb6b4e3b780c2c87cc62">souffle::explain</a></div><div class="ttdeci">void explain(SouffleProgram &amp;prog, bool ncurses, bool useSubtreelevels)</div><div class="ttdef"><b>Definition:</b> <a href="_explain_8h_source.html#l00621">Explain.h:621</a></div></div>
<div class="ttc" id="namespacesouffle_html_a673608e9453179d30f6607384f54463a"><div class="ttname"><a href="namespacesouffle.html#a673608e9453179d30f6607384f54463a">souffle::splitString</a></div><div class="ttdeci">std::vector&lt; std::string &gt; splitString(const std::string &amp;str, char delimiter)</div><div class="ttdoc">Splits a string given a delimiter. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00908">Util.h:908</a></div></div>
<div class="ttc" id="namespacesouffle_html_a69107e934a60222580ee8ba6882dc3d3"><div class="ttname"><a href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">souffle::existFile</a></div><div class="ttdeci">bool existFile(const std::string &amp;name)</div><div class="ttdoc">Check whether a file exists in the file system. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01058">Util.h:1058</a></div></div>
<div class="ttc" id="namespacesouffle_html_a9fbc2262a6164b62766f6fcb67f12ae4"><div class="ttname"><a href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4">souffle::baseName</a></div><div class="ttdeci">std::string baseName(const std::string &amp;filename)</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01182">Util.h:1182</a></div></div>
<div class="ttc" id="namespacesouffle_html_a2122cfa5acdee4846ecda0855f0beee4"><div class="ttname"><a href="namespacesouffle.html#a2122cfa5acdee4846ecda0855f0beee4">souffle::tempFile</a></div><div class="ttdeci">std::string tempFile()</div><div class="ttdoc">Generate temporary file. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01240">Util.h:1240</a></div></div>
<div class="ttc" id="namespacesouffle_html_a56909036ae0514924e306d0a1a180837"><div class="ttname"><a href="namespacesouffle.html#a56909036ae0514924e306d0a1a180837">souffle::isNumber</a></div><div class="ttdeci">bool isNumber(const char *str)</div><div class="ttdoc">Check whether a string is a sequence of digits. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00275">Util.h:275</a></div></div>
<div class="ttc" id="namespacesouffle_html_a97d640155c037c468924198354aae2ea"><div class="ttname"><a href="namespacesouffle.html#a97d640155c037c468924198354aae2ea">souffle::compileToBinary</a></div><div class="ttdeci">void compileToBinary(std::string compileCmd, const std::string &amp;sourceFilename)</div><div class="ttdoc">Compiles the given source file to a binary file. </div><div class="ttdef"><b>Definition:</b> <a href="main_8cpp_source.html#l00098">main.cpp:98</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a052d35be8e032f425317fd1b6d7e487a_cgraph.png" border="0" usemap="#namespacesouffle_a052d35be8e032f425317fd1b6d7e487a_cgraph" alt=""/></div>
<map name="namespacesouffle_a052d35be8e032f425317fd1b6d7e487a_cgraph" id="namespacesouffle_a052d35be8e032f425317fd1b6d7e487a_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_debug_report.html#a4e6fe0a6d9854ce570d008772daa9aba" title="souffle::DebugReport\l::addSection" alt="" coords="415,49,573,91"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4" title="souffle::baseName" alt="" coords="179,865,323,891"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a97d640155c037c468924198354aae2ea" title="Compiles the given source file to a binary file. " alt="" coords="160,545,343,571"/>
<area shape="rect" id="node5" href="classsouffle_1_1_global.html#a2dcb257b0f98d0b882862427cc965640" title="souffle::Global::config" alt="" coords="665,490,827,517"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a673608e9453179d30f6607384f54463a" title="Splits a string given a delimiter. " alt="" coords="424,595,564,622"/>
<area shape="rect" id="node7" href="classsouffle_1_1_debug_report.html#a7e549c285244587078499c95b590d9a1" title="souffle::DebugReport\l::endSection" alt="" coords="172,916,331,957"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a1752bf432062837ed19ae6ac73ab177c" title="Executes a binary file. " alt="" coords="167,646,335,673"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14" title="Check whether a given file exists and it is an executable. " alt="" coords="415,697,573,723"/>
<area shape="rect" id="node11" href="namespacesouffle.html#a79fa4170c4094bc943de6fa5acb5796e" title="Check whether a directory exists in the file system. " alt="" coords="189,982,314,1009"/>
<area shape="rect" id="node12" href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3" title="Check whether a file exists in the file system. " alt="" coords="187,1033,315,1059"/>
<area shape="rect" id="node13" href="namespacesouffle.html#ab5c20b82d0becb6b4e3b780c2c87cc62" title="souffle::explain" alt="" coords="190,1083,313,1110"/>
<area shape="rect" id="node14" href="namespacesouffle.html#af944f0c474df29e5c8e45e4b7df60be5" title="souffle::findTool" alt="" coords="189,1134,313,1161"/>
<area shape="rect" id="node15" href="classsouffle_1_1_main_config.html#a3e73f11c84c66253792d46ee203adf53" title="souffle::MainConfig\l::help" alt="" coords="421,748,567,789"/>
<area shape="rect" id="node16" href="namespacesouffle.html#ad0e8debde5608979e041dd30e044612a" title="Valid C++ identifier, note that this does not ensure the uniqueness of identifiers returned..." alt="" coords="185,1185,317,1211"/>
<area shape="rect" id="node17" href="namespacesouffle.html#a56909036ae0514924e306d0a1a180837" title="Check whether a string is a sequence of digits. " alt="" coords="183,1235,320,1262"/>
<area shape="rect" id="node18" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb" title="Creates an object to be forwarded to some output stream for printing sequences of elements interspers..." alt="" coords="202,1286,301,1313"/>
<area shape="rect" id="node19" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0" title="souffle::now" alt="" coords="443,494,545,521"/>
<area shape="rect" id="node20" href="classsouffle_1_1_parser_driver.html#a94c34d6b6b903a13789b5b8b5d89f0c2" title="souffle::ParserDriver\l::parseTranslationUnit" alt="" coords="169,1337,333,1379"/>
<area shape="rect" id="node25" href="classsouffle_1_1_main_config.html#a9a638fe8cffbbc1020fc482b4ddbde71" title="souffle::MainConfig\l::processArgs" alt="" coords="178,799,325,840"/>
<area shape="rect" id="node28" href="classsouffle_1_1profile_1_1_tui.html#ad1e94241f9c749315f718f18a3b74b00" title="souffle::profile::Tui\l::runProf" alt="" coords="181,1403,322,1444"/>
<area shape="rect" id="node41" href="namespacesouffle.html#ab31e06999eb72da2f6d9a85bdd3dda59" title="File name, with extension removed. " alt="" coords="173,1469,330,1495"/>
<area shape="rect" id="node42" href="classsouffle_1_1_debug_report.html#a5e9ee78bb3c716e38cb79b485e28eb39" title="souffle::DebugReport\l::startSection" alt="" coords="172,1520,331,1561"/>
<area shape="rect" id="node43" href="namespacesouffle.html#a2122cfa5acdee4846ecda0855f0beee4" title="Generate temporary file. " alt="" coords="186,1586,317,1613"/>
<area shape="rect" id="node44" href="classsouffle_1_1_ast_translator.html#aa34985564ed3ec62c72b4e7c82f3b590" title="translates AST to translation unit " alt="" coords="172,297,331,339"/>
<area shape="rect" id="node50" href="namespacesouffle.html#a6e9757564e85959db8b14a9be7d544e1" title="Simple implementation of a which tool. " alt="" coords="195,1637,307,1663"/>
<area shape="rect" id="node8" href="classsouffle_1_1_debug_report_section.html#ab3581dd7a55581f8f71e73a247356cd0" title="souffle::DebugReportSection\l::DebugReportSection" alt="" coords="391,1012,597,1053"/>
<area shape="rect" id="node21" href="classsouffle_1_1_parser_driver.html#a90b18824c68360730447eba5cc196edb" title="souffle::ParserDriver\l::parse" alt="" coords="417,1184,571,1225"/>
<area shape="rect" id="node22" href="_parser_driver_8cpp.html#a45c0eb07993a6eca6aab8fce3ffecea4" title="yylex_init_extra" alt="" coords="683,1170,809,1197"/>
<area shape="rect" id="node23" href="_parser_driver_8cpp.html#a105b0061f1fb49827305f5d1bad07b91" title="yyset_in" alt="" coords="707,1221,785,1247"/>
<area shape="rect" id="node24" href="_parser_driver_8cpp.html#a27fd9b6b0c9a907d6781e30d529e39d9" title="yylex_destroy" alt="" coords="689,1119,803,1146"/>
<area shape="rect" id="node26" href="classsouffle_1_1profile_1_1_tui.html#a1368eefa24d481064004e319f8d22d50" title="souffle::profile::Tui\l::size" alt="" coords="423,865,565,907"/>
<area shape="rect" id="node27" href="classsouffle_1_1_base_table.html#a33d27c840f9dc359f80f35916b8427a7" title="souffle::BaseTable\l\&lt; std::string, std::\lstring \&gt;::has" alt="" coords="424,931,564,987"/>
<area shape="rect" id="node29" href="classsouffle_1_1profile_1_1_input_reader.html#af42a37387d1666bca44bf42e62332506" title="souffle::profile::InputReader\l::setPrompt" alt="" coords="393,1337,595,1379"/>
<area shape="rect" id="node30" href="classsouffle_1_1profile_1_1_input_reader.html#a52add3f27ef26681e310ef5741860f40" title="souffle::profile::InputReader\l::getInput" alt="" coords="393,1403,595,1444"/>
<area shape="rect" id="node36" href="namespacesouffle_1_1profile_1_1_tools.html#af94b32d00e251be9167bf74c5a50d968" title="souffle::profile::Tools\l::trimWhitespace" alt="" coords="416,1468,572,1509"/>
<area shape="rect" id="node37" href="classsouffle_1_1profile_1_1_input_reader.html#a0058a208c97ed608a02a5226ed7e061a" title="souffle::profile::InputReader\l::addHistory" alt="" coords="393,1533,595,1575"/>
<area shape="rect" id="node38" href="namespacesouffle_1_1profile_1_1_tools.html#a2a26cf00df092cbd565298fcd045a0d2" title="split on the delimiter " alt="" coords="416,1599,572,1640"/>
<area shape="rect" id="node39" href="classsouffle_1_1profile_1_1_tui.html#a335580eed52ebba63a027efc5d579b67" title="souffle::profile::Tui\l::runCommand" alt="" coords="423,1272,565,1313"/>
<area shape="rect" id="node31" href="classsouffle_1_1profile_1_1_input_reader.html#ac74597f9639943f8554013f09e92aa39" title="souffle::profile::InputReader\l::readchar" alt="" coords="645,1585,847,1627"/>
<area shape="rect" id="node32" href="classsouffle_1_1profile_1_1_input_reader.html#afbe82264bff4493fe2859b93d8493a17" title="souffle::profile::InputReader\l::moveCursor" alt="" coords="645,1337,847,1379"/>
<area shape="rect" id="node33" href="classsouffle_1_1profile_1_1_input_reader.html#afacd909a6d021400f57961951b8bcd27" title="souffle::profile::InputReader\l::tabComplete" alt="" coords="645,1403,847,1444"/>
<area shape="rect" id="node34" href="classsouffle_1_1profile_1_1_input_reader.html#a5e322b63728d04b784ac53907806e4ad" title="souffle::profile::InputReader\l::backspace" alt="" coords="645,1520,847,1561"/>
<area shape="rect" id="node35" href="classsouffle_1_1profile_1_1_input_reader.html#a37e5eb98efab4a607969ee49c7b1b4c7" title="souffle::profile::InputReader\l::showFullText" alt="" coords="895,1491,1096,1532"/>
<area shape="rect" id="node40" href="classsouffle_1_1profile_1_1_input_reader.html#a4c496c68f943db0022338e4a46111551" title="souffle::profile::InputReader\l::hasReceivedInput" alt="" coords="645,1272,847,1313"/>
<area shape="rect" id="node45" href="classsouffle_1_1_ast_translation_unit.html#a85862a5fcfecdf63c7367926cdedde23" title="get the AST program " alt="" coords="397,232,591,273"/>
<area shape="rect" id="node46" href="classsouffle_1_1_ast_translator.html#aa7edc409dc3863ec59ccc4cfffe58b5d" title="translate AST to RAM Program " alt="" coords="415,428,573,469"/>
<area shape="rect" id="node47" href="classsouffle_1_1_ast_translator.html#a9103e21dada3e104351eb493732fa7f7" title="Return a symbol table. " alt="" coords="415,297,573,339"/>
<area shape="rect" id="node48" href="classsouffle_1_1_ast_translation_unit.html#aec4a1cc2e03286db878a5d2f0377f894" title="get error report " alt="" coords="397,363,591,404"/>
<area shape="rect" id="node49" href="classsouffle_1_1_ast_translation_unit.html#a2c05c0d93e34800167034b1aa423c4a0" title="get debug report " alt="" coords="397,115,591,156"/>
</map>
</div>

</div>
</div>
<a id="acea8a37cc1681f657054f3b30af55003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea8a37cc1681f657054f3b30af55003">&#9670;&nbsp;</a></span>make_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1range.html">range</a>&lt;Iter&gt; souffle::make_range </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function enabling the construction of ranges without explicitly specifying the iterator type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>.. the iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>.. the lower boundary </td></tr>
    <tr><td class="paramname">b</td><td>.. the upper boundary </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00456">456</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00382">souffle::range&lt; Iter &gt;::a</a>, and <a class="el" href="_util_8h_source.html#l00382">souffle::range&lt; Iter &gt;::b</a>.</p>

<p class="reference">Referenced by <a class="el" href="_equivalence_relation_8h_source.html#l00484">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::getBoundaries()</a>, <a class="el" href="_brie_8h_source.html#l02580">souffle::Trie&lt; Arity &gt;::getBoundaries()</a>, <a class="el" href="_brie_8h_source.html#l03077">souffle::Trie&lt; 1u &gt;::getBoundaries()</a>, <a class="el" href="_equivalence_relation_8h_source.html#l00627">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::partition()</a>, <a class="el" href="_brie_8h_source.html#l02686">souffle::Trie&lt; Arity &gt;::partition()</a>, and <a class="el" href="_brie_8h_source.html#l03028">souffle::Trie&lt; 1u &gt;::partition()</a>.</p>
<div class="fragment"><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;                                                     {</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    <span class="keywordflow">return</span> range&lt;Iter&gt;(a, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>);</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a97c74d6a5819e15d68eded0c4e9ff9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c74d6a5819e15d68eded0c4e9ff9d5">&#9670;&nbsp;</a></span>makeInfoRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a>&gt; souffle::makeInfoRelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> &amp;&#160;</td>
          <td class="paramname"><em>originalClause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>originalClauseNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_translation_unit.html">AstTranslationUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>translationUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_provenance_transformer_8cpp_source.html#l00065">65</a> of file <a class="el" href="_provenance_transformer_8cpp_source.html">ProvenanceTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_program_8h_source.html#l00105">souffle::AstProgram::addClause()</a>, <a class="el" href="_ast_literal_8h_source.html#l00078">souffle::AstAtom::getArguments()</a>, <a class="el" href="_ast_clause_8h_source.html#l00171">souffle::AstClause::getBodyLiterals()</a>, <a class="el" href="_ast_clause_8h_source.html#l00166">souffle::AstClause::getHead()</a>, <a class="el" href="_ast_translation_unit_8h_source.html#l00069">souffle::AstTranslationUnit::getProgram()</a>, <a class="el" href="_ast_literal_8h_source.html#l00058">souffle::AstAtom::getQualifiedName()</a>, <a class="el" href="json11_8h_source.html#l00651">i</a>, <a class="el" href="_provenance_transformer_8cpp_source.html#l00048">identifierToString()</a>, <a class="el" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9ea551b723eafd6a31d444fcb2f5920fbd3">INFO</a>, <a class="el" href="_util_8h_source.html#l00701">join()</a>, <a class="el" href="_provenance_transformer_8cpp_source.html#l00054">makeRelationName()</a>, <a class="el" href="_ast_clause_8h_source.html#l00156">souffle::AstClause::setHead()</a>, <a class="el" href="_tui_8h_source.html#l00319">souffle::profile::ss</a>, and <a class="el" href="_binary_constraint_ops_8h_source.html#l00212">toBinaryConstraintSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_provenance_transformer_8cpp_source.html#l00387">souffle::ProvenanceTransformer::transformMaxHeight()</a>, and <a class="el" href="_provenance_transformer_8cpp_source.html#l00249">souffle::ProvenanceTransformer::transformSubtreeHeights()</a>.</p>
<div class="fragment"><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                                                                                                  {</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    AstQualifiedName name =</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;            <a class="code" href="namespacesouffle.html#ac74ef3c3ffaad63c158bcd0ff2feecb2">makeRelationName</a>(originalClause.getHead()-&gt;getQualifiedName(), <span class="stringliteral">&quot;@info&quot;</span>, originalClauseNum);</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="comment">// initialise info relation</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <span class="keyword">auto</span> infoRelation = <span class="keyword">new</span> AstRelation();</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    infoRelation-&gt;setQualifiedName(name);</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="comment">// set qualifier to INFO_RELATION</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    infoRelation-&gt;setRepresentation(RelationRepresentation::INFO);</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <span class="comment">// create new clause containing a single fact</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="keyword">auto</span> infoClause = <span class="keyword">new</span> AstClause();</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keyword">auto</span> infoClauseHead = <span class="keyword">new</span> AstAtom();</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    infoClauseHead-&gt;setQualifiedName(name);</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="comment">// (darth_tytus): Can this be unsigned?</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    infoRelation-&gt;addAttribute(std::make_unique&lt;AstAttribute&gt;(<span class="stringliteral">&quot;clause_num&quot;</span>, AstQualifiedName(<span class="stringliteral">&quot;number&quot;</span>)));</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    infoClauseHead-&gt;addArgument(std::make_unique&lt;AstNumericConstant&gt;(originalClauseNum));</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="comment">// add head relation as meta info</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    std::vector&lt;std::string&gt; headVariables;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="comment">// a method to stringify an AstArgument, translating functors and aggregates</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="comment">// keep a global counter of functor and aggregate numbers, which increment for each unique</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="comment">// functor/aggregate</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="keywordtype">int</span> functorNumber = 0;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <span class="keywordtype">int</span> aggregateNumber = 0;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keyword">auto</span> getArgInfo = [&amp;](AstArgument* arg) -&gt; std::string {</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">auto</span>* var = dynamic_cast&lt;AstVariable*&gt;(arg)) {</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;            std::stringstream varName;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            varName &lt;&lt; *var;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;            <span class="keywordflow">return</span> varName.str();</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span>* constant = dynamic_cast&lt;AstConstant*&gt;(arg)) {</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            std::stringstream constName;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            constName &lt;&lt; *constant;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;            <span class="keywordflow">return</span> constName.str();</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">nullptr</span> != dynamic_cast&lt;AstUnnamedVariable*&gt;(arg)) {</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;_&quot;</span>;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">nullptr</span> != dynamic_cast&lt;AstFunctor*&gt;(arg)) {</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;            <span class="keyword">auto</span> functorName = <span class="stringliteral">&quot;functor_&quot;</span> + std::to_string(functorNumber);</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;            functorNumber++;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;            <span class="keywordflow">return</span> functorName;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">nullptr</span> != dynamic_cast&lt;AstAggregator*&gt;(arg)) {</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;            <span class="keyword">auto</span> aggregateName = <span class="stringliteral">&quot;agg_&quot;</span> + std::to_string(aggregateNumber);</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            aggregateNumber++;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;            <span class="keywordflow">return</span> aggregateName;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        }</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unhandled argument type&quot;</span>);</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    };</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    <span class="comment">// add head arguments</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; arg : originalClause.getHead()-&gt;getArguments()) {</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        headVariables.push_back(getArgInfo(arg));</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    }</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="comment">// join variables in the head with commas</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    std::stringstream headVariableString;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    headVariableString &lt;&lt; <a class="code" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">join</a>(headVariables, <span class="stringliteral">&quot;,&quot;</span>);</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="comment">// add an attribute to infoRelation for the head of clause</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    infoRelation-&gt;addAttribute(</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;            std::make_unique&lt;AstAttribute&gt;(std::string(<span class="stringliteral">&quot;head_vars&quot;</span>), AstQualifiedName(<span class="stringliteral">&quot;symbol&quot;</span>)));</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    infoClauseHead-&gt;addArgument(std::make_unique&lt;AstStringConstant&gt;(headVariableString.str()));</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    <span class="comment">// visit all body literals and add to info clause head</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; originalClause.getBodyLiterals().size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        <span class="keyword">auto</span> lit = originalClause.getBodyLiterals()[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        <span class="keyword">const</span> AstAtom* atom = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        <span class="keywordflow">if</span> (dynamic_cast&lt;AstAtom*&gt;(lit) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;            atom = <span class="keyword">static_cast&lt;</span>AstAtom*<span class="keyword">&gt;</span>(lit);</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;AstNegation*&gt;(lit) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;            atom = <span class="keyword">static_cast&lt;</span>AstNegation*<span class="keyword">&gt;</span>(lit)-&gt;getAtom();</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;AstProvenanceNegation*&gt;(lit) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;            atom = <span class="keyword">static_cast&lt;</span>AstProvenanceNegation*<span class="keyword">&gt;</span>(lit)-&gt;getAtom();</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        }</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        <span class="comment">// add an attribute for atoms and binary constraints</span></div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        <span class="keywordflow">if</span> (atom != <span class="keyword">nullptr</span> || dynamic_cast&lt;AstBinaryConstraint*&gt;(lit) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;            infoRelation-&gt;addAttribute(std::make_unique&lt;AstAttribute&gt;(</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;                    std::string(<span class="stringliteral">&quot;rel_&quot;</span>) + std::to_string(<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>), AstQualifiedName(<span class="stringliteral">&quot;symbol&quot;</span>)));</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        }</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        <span class="keywordflow">if</span> (atom != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            std::string relName = <a class="code" href="namespacesouffle.html#a3c6cb3ac93eb86027865121aff551fde">identifierToString</a>(atom-&gt;getQualifiedName());</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;            <span class="comment">// for an atom, add its name and variables (converting aggregates to variables)</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            <span class="keywordflow">if</span> (dynamic_cast&lt;AstAtom*&gt;(lit) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                std::string atomDescription = relName;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; arg : atom-&gt;getArguments()) {</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;                    atomDescription.append(<span class="stringliteral">&quot;,&quot;</span> + getArgInfo(arg));</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                }</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                infoClauseHead-&gt;addArgument(std::make_unique&lt;AstStringConstant&gt;(atomDescription));</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                <span class="comment">// for a negation, add a marker with the relation name</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;AstNegation*&gt;(lit) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                infoClauseHead-&gt;addArgument(std::make_unique&lt;AstStringConstant&gt;(<span class="stringliteral">&quot;!&quot;</span> + relName));</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            }</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            <span class="comment">// for a constraint, add the constraint symbol and LHS and RHS</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span> con = dynamic_cast&lt;AstBinaryConstraint*&gt;(lit)) {</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            std::string constraintDescription = <a class="code" href="namespacesouffle.html#aa91ed26d703343c35171d6803a9c5d0b">toBinaryConstraintSymbol</a>(con-&gt;getOperator());</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;            constraintDescription.append(<span class="stringliteral">&quot;,&quot;</span> + getArgInfo(con-&gt;getLHS()));</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            constraintDescription.append(<span class="stringliteral">&quot;,&quot;</span> + getArgInfo(con-&gt;getRHS()));</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            infoClauseHead-&gt;addArgument(std::make_unique&lt;AstStringConstant&gt;(constraintDescription));</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        }</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    }</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    <span class="comment">// generate and add clause representation</span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    std::stringstream <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a>;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    ss &lt;&lt; originalClause;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    infoRelation-&gt;addAttribute(std::make_unique&lt;AstAttribute&gt;(<span class="stringliteral">&quot;clause_repr&quot;</span>, AstQualifiedName(<span class="stringliteral">&quot;symbol&quot;</span>)));</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    infoClauseHead-&gt;addArgument(std::make_unique&lt;AstStringConstant&gt;(ss.str()));</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    <span class="comment">// set clause head and add clause to info relation</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    infoClause-&gt;setHead(std::unique_ptr&lt;AstAtom&gt;(infoClauseHead));</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    translationUnit.getProgram()-&gt;addClause(std::unique_ptr&lt;AstClause&gt;(infoClause));</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    <span class="keywordflow">return</span> std::unique_ptr&lt;AstRelation&gt;(infoRelation);</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;}</div><div class="ttc" id="namespacesouffle_1_1profile_html_a6b765acdf677f188e059ac9860c5046d"><div class="ttname"><a href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">souffle::profile::ss</a></div><div class="ttdeci">class souffle::profile::Tui ss</div><div class="ttdef"><b>Definition:</b> <a href="_tui_8h_source.html#l00319">Tui.h:319</a></div></div>
<div class="ttc" id="namespacesouffle_html_a3c6cb3ac93eb86027865121aff551fde"><div class="ttname"><a href="namespacesouffle.html#a3c6cb3ac93eb86027865121aff551fde">souffle::identifierToString</a></div><div class="ttdeci">const std::string identifierToString(const AstQualifiedName &amp;name)</div><div class="ttdoc">Helper functions. </div><div class="ttdef"><b>Definition:</b> <a href="_provenance_transformer_8cpp_source.html#l00048">ProvenanceTransformer.cpp:48</a></div></div>
<div class="ttc" id="namespacesouffle_html_ac74ef3c3ffaad63c158bcd0ff2feecb2"><div class="ttname"><a href="namespacesouffle.html#ac74ef3c3ffaad63c158bcd0ff2feecb2">souffle::makeRelationName</a></div><div class="ttdeci">AstQualifiedName makeRelationName(const AstQualifiedName &amp;orig, const std::string &amp;type, int num=-1)</div><div class="ttdef"><b>Definition:</b> <a href="_provenance_transformer_8cpp_source.html#l00054">ProvenanceTransformer.cpp:54</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="namespacesouffle_html_abe4e3f19879707216a2758b03f4e2deb"><div class="ttname"><a href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">souffle::join</a></div><div class="ttdeci">detail::joined_sequence&lt; Iter, Printer &gt; join(const Iter &amp;a, const Iter &amp;b, const std::string &amp;sep, const Printer &amp;p)</div><div class="ttdoc">Creates an object to be forwarded to some output stream for printing sequences of elements interspers...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00701">Util.h:701</a></div></div>
<div class="ttc" id="namespacesouffle_html_aa91ed26d703343c35171d6803a9c5d0b"><div class="ttname"><a href="namespacesouffle.html#aa91ed26d703343c35171d6803a9c5d0b">souffle::toBinaryConstraintSymbol</a></div><div class="ttdeci">std::string toBinaryConstraintSymbol(const BinaryConstraintOp op)</div><div class="ttdoc">Converts operator to its symbolic representation. </div><div class="ttdef"><b>Definition:</b> <a href="_binary_constraint_ops_8h_source.html#l00212">BinaryConstraintOps.h:212</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a97c74d6a5819e15d68eded0c4e9ff9d5_cgraph.png" border="0" usemap="#namespacesouffle_a97c74d6a5819e15d68eded0c4e9ff9d5_cgraph" alt=""/></div>
<map name="namespacesouffle_a97c74d6a5819e15d68eded0c4e9ff9d5_cgraph" id="namespacesouffle_a97c74d6a5819e15d68eded0c4e9ff9d5_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_program.html#a776167026cb9e348e75a9e9caa02ef74" title="add a clause " alt="" coords="295,5,446,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="255,71,486,98"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="301,123,440,164"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="301,188,440,229"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_translation_unit.html#a85862a5fcfecdf63c7367926cdedde23" title="get the AST program " alt="" coords="274,253,467,295"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="243,319,499,346"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a3c6cb3ac93eb86027865121aff551fde" title="Helper functions. " alt="" coords="551,391,735,418"/>
<area shape="rect" id="node10" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb" title="Creates an object to be forwarded to some output stream for printing sequences of elements interspers..." alt="" coords="321,421,420,447"/>
<area shape="rect" id="node11" href="namespacesouffle.html#ac74ef3c3ffaad63c158bcd0ff2feecb2" title="souffle::makeRelationName" alt="" coords="269,471,472,498"/>
<area shape="rect" id="node13" href="classsouffle_1_1_ast_clause.html#a07290e1b7b9e4ce73c3a5f0482ce88d3" title="Set the head of clause to h. " alt="" coords="301,523,440,564"/>
<area shape="rect" id="node14" href="namespacesouffle.html#aa91ed26d703343c35171d6803a9c5d0b" title="Converts operator to its symbolic representation. " alt="" coords="273,588,469,629"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="569,101,716,127"/>
<area shape="rect" id="node12" href="classsouffle_1_1_ast_qualified_name.html#a6341a67891b6d0174b92264eb4dc5d43" title="append qualifiers " alt="" coords="547,464,739,505"/>
</map>
</div>

</div>
</div>
<a id="a67fd524841b8a60b1bb50b18dc868c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fd524841b8a60b1bb50b18dc868c7c">&#9670;&nbsp;</a></span>makeLambdaAstMapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1detail_1_1_lambda_node_mapper.html">detail::LambdaNodeMapper</a>&lt;Lambda&gt; souffle::makeLambdaAstMapper </td>
          <td>(</td>
          <td class="paramtype">const Lambda &amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a node mapper based on a corresponding lambda expression. </p>

<p class="definition">Definition at line <a class="el" href="_ast_node_8h_source.html#l00155">155</a> of file <a class="el" href="_ast_node_8h_source.html">AstNode.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_transforms_8cpp_source.html#l00224">souffle::MaterializeAggregationQueriesTransformer::materializeAggregationQueries()</a>, and <a class="el" href="_provenance_transformer_8cpp_source.html#l00249">souffle::ProvenanceTransformer::transformSubtreeHeights()</a>.</p>
<div class="fragment"><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                                                                         {</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="keywordflow">return</span> detail::LambdaNodeMapper&lt;Lambda&gt;(lambda);</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a7fba43e03f480ca372449b103dfc9a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fba43e03f480ca372449b103dfc9a2f">&#9670;&nbsp;</a></span>makeLambdaRamMapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_lambda_ram_node_mapper.html">LambdaRamNodeMapper</a>&lt;Lambda&gt; souffle::makeLambdaRamMapper </td>
          <td>(</td>
          <td class="paramtype">const Lambda &amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a node mapper based on a corresponding lambda expression. </p>

<p class="definition">Definition at line <a class="el" href="_ram_node_8h_source.html#l00087">87</a> of file <a class="el" href="_ram_node_8h_source.html">RamNode.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ram_program_8h_source.html#l00095">souffle::RamProgram::clone()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00105">souffle::CollapseFiltersTransformer::collapseFilters()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00493">souffle::IfConversionTransformer::convertIndexScans()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00587">souffle::ChoiceConversionTransformer::convertScans()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00141">souffle::EliminateDuplicatesTransformer::eliminateDuplicates()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00037">souffle::ExpandFilterTransformer::expandFilters()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00647">souffle::HoistAggregateTransformer::hoistAggregate()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00173">souffle::HoistConditionsTransformer::hoistConditions()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00399">souffle::MakeIndexTransformer::makeIndex()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00730">souffle::ParallelTransformer::parallelizeOperations()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00070">souffle::ReorderConditionsTransformer::reorderConditions()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00430">souffle::ReorderFilterBreak::reorderFilterBreak()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00613">souffle::TupleIdTransformer::reorderOperations()</a>, and <a class="el" href="_ram_node_8h_source.html#l00129">souffle::RamNode::rewrite()</a>.</p>
<div class="fragment"><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                                                                      {</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keywordflow">return</span> LambdaRamNodeMapper&lt;Lambda&gt;(lambda);</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ac74ef3c3ffaad63c158bcd0ff2feecb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74ef3c3ffaad63c158bcd0ff2feecb2">&#9670;&nbsp;</a></span>makeRelationName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> souffle::makeRelationName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_provenance_transformer_8cpp_source.html#l00054">54</a> of file <a class="el" href="_provenance_transformer_8cpp_source.html">ProvenanceTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_qualified_name_8h_source.html#l00046">souffle::AstQualifiedName::append()</a>, and <a class="el" href="_provenance_transformer_8cpp_source.html#l00048">identifierToString()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_provenance_transformer_8cpp_source.html#l00065">makeInfoRelation()</a>.</p>
<div class="fragment"><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                                                                           {</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    AstQualifiedName newName(<a class="code" href="namespacesouffle.html#a3c6cb3ac93eb86027865121aff551fde">identifierToString</a>(orig));</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    newName.append(type);</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="keywordflow">if</span> (num != -1) {</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        newName.append((<span class="keyword">const</span> std::string&amp;)std::to_string(num));</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    }</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <span class="keywordflow">return</span> newName;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a3c6cb3ac93eb86027865121aff551fde"><div class="ttname"><a href="namespacesouffle.html#a3c6cb3ac93eb86027865121aff551fde">souffle::identifierToString</a></div><div class="ttdeci">const std::string identifierToString(const AstQualifiedName &amp;name)</div><div class="ttdoc">Helper functions. </div><div class="ttdef"><b>Definition:</b> <a href="_provenance_transformer_8cpp_source.html#l00048">ProvenanceTransformer.cpp:48</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ac74ef3c3ffaad63c158bcd0ff2feecb2_cgraph.png" border="0" usemap="#namespacesouffle_ac74ef3c3ffaad63c158bcd0ff2feecb2_cgraph" alt=""/></div>
<map name="namespacesouffle_ac74ef3c3ffaad63c158bcd0ff2feecb2_cgraph" id="namespacesouffle_ac74ef3c3ffaad63c158bcd0ff2feecb2_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_qualified_name.html#a6341a67891b6d0174b92264eb4dc5d43" title="append qualifiers " alt="" coords="256,5,448,47"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a3c6cb3ac93eb86027865121aff551fde" title="Helper functions. " alt="" coords="260,71,444,98"/>
</map>
</div>

</div>
</div>
<a id="acbb53246ca22f17f324a309dc63f2e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb53246ca22f17f324a309dc63f2e73">&#9670;&nbsp;</a></span>nameInlinedUnderscores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::nameInlinedUnderscores </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all underscores in all atoms of inlined relations. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00124">124</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_program_8h_source.html#l00164">souffle::AstProgram::apply()</a>, <a class="el" href="_ast_program_8h_source.html#l00057">souffle::AstProgram::getRelations()</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">INLINE</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01017">replaceUnderscores()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l01006">souffle::InlineRelationsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                                                 {</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="keyword">struct </span>M : <span class="keyword">public</span> AstNodeMapper {</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="keyword">const</span> std::set&lt;AstQualifiedName&gt; inlinedRelations;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        <span class="keywordtype">bool</span> <a class="code" href="namespacesouffle.html#a877abda5aeabc4122f3bce8d74247919">replaceUnderscores</a>;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        M(std::set&lt;AstQualifiedName&gt; inlinedRelations, <span class="keywordtype">bool</span> replaceUnderscores)</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                : inlinedRelations(<a class="code" href="namespacestd.html">std</a>::move(inlinedRelations)), replaceUnderscores(replaceUnderscores) {}</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        std::unique_ptr&lt;AstNode&gt; operator()(std::unique_ptr&lt;AstNode&gt; node)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">int</span> underscoreCount = 0;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;            <span class="keywordflow">if</span> (!replaceUnderscores) {</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                <span class="comment">// Check if we should start replacing underscores for this node&#39;s subnodes</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                <span class="keywordflow">if</span> (<span class="keyword">auto</span>* atom = dynamic_cast&lt;AstAtom*&gt;(node.get())) {</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                    <span class="keywordflow">if</span> (inlinedRelations.find(atom-&gt;getQualifiedName()) != inlinedRelations.end()) {</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                        <span class="comment">// Atom associated with an inlined relation, so replace the underscores</span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;                        <span class="comment">// in all of its subnodes with named variables.</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                        M replace(inlinedRelations, <span class="keyword">true</span>);</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;                        node-&gt;apply(replace);</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                        <span class="keywordflow">return</span> node;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;                    }</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                }</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dynamic_cast&lt;AstUnnamedVariable*&gt;(node.get()) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                <span class="comment">// Give a unique name to the underscored variable</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                <span class="comment">// TODO (azreika): need a more consistent way of handling internally generated variables in</span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;                <span class="comment">// general</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;                std::stringstream newVarName;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                newVarName &lt;&lt; <span class="stringliteral">&quot;&lt;underscore_&quot;</span> &lt;&lt; underscoreCount++ &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span>;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;                <span class="keywordflow">return</span> std::make_unique&lt;AstVariable&gt;(newVarName.str());</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            }</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;            <span class="keywordflow">return</span> node;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        }</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    };</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    <span class="comment">// Store the names of all relations to be inlined</span></div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    std::set&lt;AstQualifiedName&gt; inlinedRelations;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <span class="keywordflow">for</span> (AstRelation* rel : program.getRelations()) {</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        <span class="keywordflow">if</span> (rel-&gt;hasQualifier(RelationQualifier::INLINE)) {</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            inlinedRelations.insert(rel-&gt;getQualifiedName());</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        }</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    }</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <span class="comment">// Apply the renaming procedure to the entire program</span></div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    M update(inlinedRelations, <span class="keyword">false</span>);</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    program.apply(update);</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;}</div><div class="ttc" id="namespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition:</b> <a href="_compiled_tuple_8h_source.html#l00169">CompiledTuple.h:169</a></div></div>
<div class="ttc" id="namespacesouffle_html_a877abda5aeabc4122f3bce8d74247919"><div class="ttname"><a href="namespacesouffle.html#a877abda5aeabc4122f3bce8d74247919">souffle::replaceUnderscores</a></div><div class="ttdeci">void replaceUnderscores(AstProgram *program)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l01017">MagicSet.cpp:1017</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_acbb53246ca22f17f324a309dc63f2e73_cgraph.png" border="0" usemap="#namespacesouffle_acbb53246ca22f17f324a309dc63f2e73_cgraph" alt=""/></div>
<map name="namespacesouffle_acbb53246ca22f17f324a309dc63f2e73_cgraph" id="namespacesouffle_acbb53246ca22f17f324a309dc63f2e73_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_program.html#a0a658e411394dfc93da0ab36e06d0101" title="Apply the mapper to all child nodes. " alt="" coords="315,5,466,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="540,61,691,103"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a877abda5aeabc4122f3bce8d74247919" title="souffle::replaceUnderscores" alt="" coords="289,123,492,150"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="937,123,1084,150"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198" title="souffle::hasPrefix" alt="" coords="548,127,683,154"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="542,178,689,205"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="739,145,889,187"/>
</map>
</div>

</div>
</div>
<a id="a4a2b4fc7558b8bce98ff88f8e10b516e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2b4fc7558b8bce98ff88f8e10b516e">&#9670;&nbsp;</a></span>negateConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::negateConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_constraint.html">AstConstraint</a> *&#160;</td>
          <td class="paramname"><em>constraint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negate an ast constraint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraint</td><td>constraint that will be negated </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00222">222</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_binary_constraint_ops_8h_source.html#l00149">negatedConstraintOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00345">negateLiteral()</a>, and <a class="el" href="_ast_parser_utils_8cpp_source.html#l00079">souffle::RuleBody::toClauseBodies()</a>.</p>
<div class="fragment"><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                                                 {</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    assert(<span class="keyword">nullptr</span> != dynamic_cast&lt;AstConstraint*&gt;(constraint) &amp;&amp; <span class="stringliteral">&quot;not a constraint object&quot;</span>);</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span>* bcstr = dynamic_cast&lt;AstBooleanConstraint*&gt;(constraint)) {</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        bcstr-&gt;set(!bcstr-&gt;isTrue());</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span>* cstr = dynamic_cast&lt;AstBinaryConstraint*&gt;(constraint)) {</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        cstr-&gt;setOperator(<a class="code" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478">souffle::negatedConstraintOp</a>(cstr-&gt;getOperator()));</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unknown ast-constraint type&quot;</span>);</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    }</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a269a51553c86cbb637013907c879f478"><div class="ttname"><a href="namespacesouffle.html#a269a51553c86cbb637013907c879f478">souffle::negatedConstraintOp</a></div><div class="ttdeci">BinaryConstraintOp negatedConstraintOp(const BinaryConstraintOp op)</div><div class="ttdoc">Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa...</div><div class="ttdef"><b>Definition:</b> <a href="_binary_constraint_ops_8h_source.html#l00149">BinaryConstraintOps.h:149</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a4a2b4fc7558b8bce98ff88f8e10b516e_cgraph.png" border="0" usemap="#namespacesouffle_a4a2b4fc7558b8bce98ff88f8e10b516e_cgraph" alt=""/></div>
<map name="namespacesouffle_a4a2b4fc7558b8bce98ff88f8e10b516e_cgraph" id="namespacesouffle_a4a2b4fc7558b8bce98ff88f8e10b516e_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="240,5,452,32"/>
</map>
</div>

</div>
</div>
<a id="a269a51553c86cbb637013907c879f478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269a51553c86cbb637013907c879f478">&#9670;&nbsp;</a></span>negatedConstraintOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> souffle::negatedConstraintOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a>&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negated <a class="el" href="classsouffle_1_1_constraint.html" title="A generic base class for constraints on variables. ">Constraint</a> Operator Each operator requires a negated operator which is necessary for the expansion of complex rule bodies with disjunction and negation. </p>

<p class="definition">Definition at line <a class="el" href="_binary_constraint_ops_8h_source.html#l00149">149</a> of file <a class="el" href="_binary_constraint_ops_8h_source.html">BinaryConstraintOps.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b">CONTAINS</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa123e958001611b441dab45ff11ba98a">FEQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa1d7888b08b54d43aeadc58136fa0907">FGE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa302b6b103aca34c46209564002a8252">FGT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a56267eaefed8c4c5255779a597a72363">FLE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a1cc288bb3360b602513d8ffe37a874f9">FLT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a90dc357130ab3c37ef770e959ab49b9c">FNE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">GE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">GT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">LE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">LT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a">MATCH</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">NE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0">NOT_CONTAINS</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01">NOT_MATCH</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49add25db0709d4c7c05b057f311208f753">SGE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a53acb49d0534e8912fec8569e845400f">SGT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a0a1d07df9a43688c7128eefbe3d41b08">SLE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac71563c4ae48cc1bbd2e7913366cdf7e">SLT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ada0d6078de3703b5680eb9361f2d68fd">UGE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7efc25ec6c881b13261c1a6d88762483">UGT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ae29e365fd3b5e59c86218486a0c1c7c1">ULE</a>, and <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2b4652512a6c88f5a39c3288081b6e13">ULT</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_transforms_8cpp_source.html#l01417">souffle::FoldAnonymousRecords::isValidRecordConstraint()</a>, and <a class="el" href="_ast_utils_8cpp_source.html#l00222">negateConstraint()</a>.</p>
<div class="fragment"><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;                                                                           {</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="keywordflow">switch</span> (op) {</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::EQ:</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::NE;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FEQ:</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::FNE;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NE:</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::EQ;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FNE:</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::FEQ;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::LT:</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::GE;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::ULT:</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::UGE;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FLT:</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::FGE;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::SLT:</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::SGE;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::LE:</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::GT;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::ULE:</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::UGT;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FLE:</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::FGT;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::SLE:</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::SGT;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::GE:</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::LT;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::UGE:</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::ULT;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FGE:</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::FLT;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::SGE:</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::SLT;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::GT:</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::LE;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::UGT:</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::ULE;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FGT:</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::FLE;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::SGT:</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::SLE;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::MATCH:</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::NOT_MATCH;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NOT_MATCH:</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::MATCH;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::CONTAINS:</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::NOT_CONTAINS;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NOT_CONTAINS:</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;            <span class="keywordflow">return</span> BinaryConstraintOp::CONTAINS;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    }</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported Operator!&quot;</span>);</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    exit(EXIT_FAILURE);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a72ca390c0235d50be215fdc25bb24e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ca390c0235d50be215fdc25bb24e4d">&#9670;&nbsp;</a></span>negateLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a>* souffle::negateLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *&#160;</td>
          <td class="paramname"><em>lit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the negated version of a given literal. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00345">345</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="classsouffle_1_1_ast_constraint.html#a4bc070302396ff2bee073f62c00b5e21">souffle::AstConstraint::clone()</a>, <a class="el" href="_ast_literal_8h_source.html#l00082">souffle::AstAtom::clone()</a>, and <a class="el" href="_ast_utils_8cpp_source.html#l00222">negateConstraint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00366">combineNegatedLiterals()</a>.</p>
<div class="fragment"><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                                           {</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span>* atom = dynamic_cast&lt;AstAtom*&gt;(lit)) {</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        <span class="keyword">auto</span>* neg = <span class="keyword">new</span> AstNegation(std::unique_ptr&lt;AstAtom&gt;(atom-&gt;clone()));</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        <span class="keywordflow">return</span> neg;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span>* neg = dynamic_cast&lt;AstNegation*&gt;(lit)) {</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        AstAtom* atom = neg-&gt;getAtom()-&gt;clone();</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        <span class="keywordflow">return</span> atom;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span>* cons = dynamic_cast&lt;AstConstraint*&gt;(lit)) {</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;        AstConstraint* newCons = cons-&gt;clone();</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        <a class="code" href="namespacesouffle.html#a4a2b4fc7558b8bce98ff88f8e10b516e">negateConstraint</a>(newCons);</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;        <span class="keywordflow">return</span> newCons;</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;        assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported literal type!&quot;</span>);</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    }</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a4a2b4fc7558b8bce98ff88f8e10b516e"><div class="ttname"><a href="namespacesouffle.html#a4a2b4fc7558b8bce98ff88f8e10b516e">souffle::negateConstraint</a></div><div class="ttdeci">void negateConstraint(AstConstraint *constraint)</div><div class="ttdoc">Negate an ast constraint. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00222">AstUtils.cpp:222</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a72ca390c0235d50be215fdc25bb24e4d_cgraph.png" border="0" usemap="#namespacesouffle_a72ca390c0235d50be215fdc25bb24e4d_cgraph" alt=""/></div>
<map name="namespacesouffle_a72ca390c0235d50be215fdc25bb24e4d_cgraph" id="namespacesouffle_a72ca390c0235d50be215fdc25bb24e4d_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_constraint.html#a4bc070302396ff2bee073f62c00b5e21" title="Create a clone (i.e. " alt="" coords="225,5,388,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Create a clone (i.e. " alt="" coords="220,71,393,98"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a4a2b4fc7558b8bce98ff88f8e10b516e" title="Negate an ast constraint. " alt="" coords="213,122,400,149"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_atom.html#acef18129b13ce45477044717ded051d2" title="souffle::AstAtom::AstAtom" alt="" coords="457,21,651,47"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="454,71,654,98"/>
<area shape="rect" id="node7" href="namespacesouffle.html#a269a51553c86cbb637013907c879f478" title="Negated Constraint Operator Each operator requires a negated operator which is necessary for the expa..." alt="" coords="448,122,660,149"/>
</map>
</div>

</div>
</div>
<a id="a70f903ef77f947a3123c891794322534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f903ef77f947a3123c891794322534">&#9670;&nbsp;</a></span>nextSrcLoc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_src_location.html">SrcLocation</a> souffle::nextSrcLoc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_src_location.html">SrcLocation</a>&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00176">176</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_src_location_8h_source.html#l00034">souffle::SrcLocation::Point::column</a>, <a class="el" href="_src_location_8h_source.html#l00063">souffle::SrcLocation::end</a>, <a class="el" href="_src_location_8h_source.html#l00057">souffle::SrcLocation::filenames</a>, <a class="el" href="_src_location_8h_source.html#l00031">souffle::SrcLocation::Point::line</a>, and <a class="el" href="_src_location_8h_source.html#l00060">souffle::SrcLocation::start</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00211">createNewRelation()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00899">separateDBs()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                                         {</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">int</span> pos = 0;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    pos += 1;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    SrcLocation newLoc;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    newLoc.filenames = orig.filenames;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <span class="keywordflow">if</span> (orig.filenames.empty()) {</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        newLoc.filenames.emplace_back(<span class="stringliteral">&quot;[MAGIC_FILE]&quot;</span>);</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        newLoc.filenames.back() = orig.filenames.back() + <span class="stringliteral">&quot;[MAGIC_FILE]&quot;</span>;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    }</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    newLoc.start.line = pos;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    newLoc.end.line = pos;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    newLoc.start.column = 0;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    newLoc.end.column = 1;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    <span class="keywordflow">return</span> newLoc;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="af4ec690ba482fd3a9692b5e31f6ad347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ec690ba482fd3a9692b5e31f6ad347">&#9670;&nbsp;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::none_of </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic test checking whether all elements within a container satisfy a certain predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container </td></tr>
    <tr><td class="paramname">p</td><td>the predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if for all elements x in c the predicate p(x) is true, false otherwise; for empty containers the result is always true </dd></dl>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01024">1024</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;                                                   {</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#af4ec690ba482fd3a9692b5e31f6ad347">std::none_of</a>(c.begin(), c.end(), <a class="code" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>);</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_a0e2839cf85d4f50ed7cdcc6c1b3adf83"><div class="ttname"><a href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a></div><div class="ttdeci">a horizontalBars(j=m=void 0===a.axisX.type?new c.AutoScaleAxis(c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})):a.axisX.type.call(c, c.Axis.units.x, b.normalized.series, o, c.extend({}, a.axisX,{highLow:d, referenceValue:0})), l=n=void 0===a.axisY.type?new c.StepAxis(c.Axis.units.y, b.normalized.series, o,{ticks:k}):a.axisY.type.call(c, c.Axis.units.y, b.normalized.series, o, a.axisY)) var p</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_af4ec690ba482fd3a9692b5e31f6ad347"><div class="ttname"><a href="namespacesouffle.html#af4ec690ba482fd3a9692b5e31f6ad347">souffle::none_of</a></div><div class="ttdeci">bool none_of(const Container &amp;c, UnaryPredicate p)</div><div class="ttdoc">A generic test checking whether all elements within a container satisfy a certain predicate...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01024">Util.h:1024</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abc8556c87eabd8a087d1e0fb9f8b89b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8556c87eabd8a087d1e0fb9f8b89b6">&#9670;&nbsp;</a></span>normaliseInlinedHeads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::normaliseInlinedHeads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace constants in the head of inlined clauses with (constrained) variables. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00068">68</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_program_8h_source.html#l00105">souffle::AstProgram::addClause()</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa123e958001611b441dab45ff11ba98a">FEQ</a>, <a class="el" href="classsouffle_1_1_ast_numeric_constant.html#a894651635f1b73b977664ca876ae0752a22ae0e2b89e5e3d477f988cc36d3272b">souffle::AstNumericConstant::Float</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00042">getClauses()</a>, <a class="el" href="_ast_program_8h_source.html#l00057">souffle::AstProgram::getRelations()</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">INLINE</a>, and <a class="el" href="_ast_program_8h_source.html#l00112">souffle::AstProgram::removeClause()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l01006">souffle::InlineRelationsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;                                                {</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">int</span> newVarCount = 0;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <span class="comment">// Go through the clauses of all inlined relations</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="keywordflow">for</span> (AstRelation* rel : program.getRelations()) {</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        <span class="keywordflow">if</span> (!rel-&gt;hasQualifier(RelationQualifier::INLINE)) {</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        }</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        <span class="keywordflow">for</span> (AstClause* clause : <a class="code" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">getClauses</a>(program, *rel)) {</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            <span class="comment">// Set up the new clause with an empty body and no arguments in the head</span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;            <span class="keyword">auto</span> newClause = std::make_unique&lt;AstClause&gt;();</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            newClause-&gt;setSrcLoc(clause-&gt;getSrcLoc());</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;            <span class="keyword">auto</span> clauseHead = std::make_unique&lt;AstAtom&gt;(clause-&gt;getHead()-&gt;getQualifiedName());</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;            <span class="comment">// Add in everything in the original body</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            <span class="keywordflow">for</span> (AstLiteral* lit : clause-&gt;getBodyLiterals()) {</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                newClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(lit-&gt;clone()));</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;            }</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            <span class="comment">// Set up the head arguments in the new clause</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;            <span class="keywordflow">for</span> (AstArgument* arg : clause-&gt;getHead()-&gt;getArguments()) {</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;                <span class="keywordflow">if</span> (<span class="keyword">auto</span>* constant = dynamic_cast&lt;AstConstant*&gt;(arg)) {</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;                    <span class="comment">// Found a constant in the head, so replace it with a variable</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;                    std::stringstream newVar;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;                    newVar &lt;&lt; <span class="stringliteral">&quot;&lt;new_var_&quot;</span> &lt;&lt; newVarCount++ &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span>;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                    clauseHead-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(newVar.str()));</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                    <span class="keyword">auto</span>* <span class="keyword">const</span> c_num = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>AstNumericConstant*<span class="keyword">&gt;</span>(constant);</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;                    assert((!c_num || c_num-&gt;getType()) &amp;&amp; <span class="stringliteral">&quot;numeric constant wasn&#39;t bound to a type&quot;</span>);</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                    <span class="keyword">auto</span> opEq = c_num &amp;&amp; *c_num-&gt;getType() == AstNumericConstant::Type::Float</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;                                        ? BinaryConstraintOp::FEQ</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                                        : BinaryConstraintOp::EQ;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                    <span class="comment">// Add a body constraint to set the variable&#39;s value to be the original constant</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;                    newClause-&gt;addToBody(std::make_unique&lt;AstBinaryConstraint&gt;(opEq,</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;                            std::make_unique&lt;AstVariable&gt;(newVar.str()),</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;                            std::unique_ptr&lt;AstArgument&gt;(constant-&gt;clone())));</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;                } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                    <span class="comment">// Already a variable</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;                    clauseHead-&gt;addArgument(std::unique_ptr&lt;AstArgument&gt;(arg-&gt;clone()));</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                }</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            }</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;            newClause-&gt;setHead(std::move(clauseHead));</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;            <span class="comment">// Replace the old clause with this one</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;            program.addClause(std::move(newClause));</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;            program.removeClause(clause);</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        }</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    }</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a4d9e53888640a9abfd7ea7c43715152a"><div class="ttname"><a href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">souffle::getClauses</a></div><div class="ttdeci">std::vector&lt; AstClause * &gt; getClauses(const AstProgram &amp;program, const AstQualifiedName &amp;relationName)</div><div class="ttdoc">Returns a vector of clauses in the program describing the relation with the given name...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00042">AstUtils.cpp:42</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_abc8556c87eabd8a087d1e0fb9f8b89b6_cgraph.png" border="0" usemap="#namespacesouffle_abc8556c87eabd8a087d1e0fb9f8b89b6_cgraph" alt=""/></div>
<map name="namespacesouffle_abc8556c87eabd8a087d1e0fb9f8b89b6_cgraph" id="namespacesouffle_abc8556c87eabd8a087d1e0fb9f8b89b6_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_program.html#a776167026cb9e348e75a9e9caa02ef74" title="add a clause " alt="" coords="236,5,387,47"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="238,71,385,98"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="435,121,585,163"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_program.html#a0bde67af569811987d8e21929163d132" title="remove a clause " alt="" coords="236,173,387,215"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="435,56,585,97"/>
<area shape="rect" id="node5" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="633,97,780,123"/>
</map>
</div>

</div>
</div>
<a id="a1c65551944c7ecf6f44ec851b49bdbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c65551944c7ecf6f44ec851b49bdbb0">&#9670;&nbsp;</a></span>now()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#a9eb29a1677ffbe44fe8663f881213f0e">time_point</a> souffle::now </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01037">1037</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ram_transformer_8cpp_source.html#l00029">souffle::RamTransformer::apply()</a>, <a class="el" href="_ast_transformer_8cpp_source.html#l00045">souffle::MetaTransformer::applySubtransformer()</a>, <a class="el" href="main_8cpp_source.html#l00124">main()</a>, <a class="el" href="_profile_event_8h_source.html#l00069">souffle::ProfileEventSingleton::makeTimeEvent()</a>, <a class="el" href="_profile_event_8h_source.html#l00089">souffle::ProfileEventSingleton::makeUtilisationEvent()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00512">souffle::ExplainProvenanceImpl::measureRelation()</a>, <a class="el" href="_reader_8h_source.html#l00299">souffle::profile::Reader::processFile()</a>, <a class="el" href="_debug_reporter_8cpp_source.html#l00031">souffle::DebugReporter::transform()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l01731">souffle::AstTranslator::translateUnit()</a>, <a class="el" href="_tui_8h_source.html#l00082">souffle::profile::Tui::Tui()</a>, and <a class="el" href="_logger_8h_source.html#l00051">souffle::Logger::~Logger()</a>.</p>
<div class="fragment"><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;                        {</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">std::chrono::high_resolution_clock::now</a>();</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a1c65551944c7ecf6f44ec851b49bdbb0"><div class="ttname"><a href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">souffle::now</a></div><div class="ttdeci">time_point now()</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01037">Util.h:1037</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a84b8ff6e096476fd6097c05b4eb12386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b8ff6e096476fd6097c05b4eb12386">&#9670;&nbsp;</a></span>numBoundArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int souffle::numBoundArguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&#160;</td>
          <td class="paramname"><em>atom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundVariables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of bound arguments in a given atom. </p>

<p class="definition">Definition at line <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00049">49</a> of file <a class="el" href="_reorder_literals_transformer_8cpp_source.html">ReorderLiteralsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_literal_8h_source.html#l00078">souffle::AstAtom::getArguments()</a>, <a class="el" href="_ast_argument_8h_source.html#l00052">souffle::AstVariable::getName()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00079">getSipsFunction()</a>, and <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00355">souffle::ReorderLiteralsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;                                                                                             {</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keywordtype">int</span> count = 0;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> AstArgument* arg : atom-&gt;getArguments()) {</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        <span class="comment">// argument is bound iff all contained variables are bound</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        <span class="keywordtype">bool</span> isBound = <span class="keyword">true</span>;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(*arg, [&amp;](<span class="keyword">const</span> AstVariable&amp; var) {</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            <span class="keywordflow">if</span> (boundVariables.find(var.getName()) == boundVariables.end()) {</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                <span class="comment">// found an unbound variable, so argument is unbound</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                isBound = <span class="keyword">false</span>;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            }</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        });</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        <span class="keywordflow">if</span> (isBound) {</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;            count++;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        }</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    }</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="keywordflow">return</span> count;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a84b8ff6e096476fd6097c05b4eb12386_cgraph.png" border="0" usemap="#namespacesouffle_a84b8ff6e096476fd6097c05b4eb12386_cgraph" alt=""/></div>
<map name="namespacesouffle_a84b8ff6e096476fd6097c05b4eb12386_cgraph" id="namespacesouffle_a84b8ff6e096476fd6097c05b4eb12386_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="268,5,499,32"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_variable.html#a2b73a95c7b59624d956dee0ed4e13884" title="souffle::AstVariable\l::getName" alt="" coords="309,57,457,98"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="299,123,467,149"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="557,5,704,32"/>
<area shape="rect" id="node6" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="547,115,715,157"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="763,115,953,157"/>
</map>
</div>

</div>
</div>
<a id="ad202244da4a83adaa43b98ffa52c371e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad202244da4a83adaa43b98ffa52c371e">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> souffle::operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ast_qualified_name_8h_source.html#l00100">100</a> of file <a class="el" href="_ast_qualified_name_8h_source.html">AstQualifiedName.h</a>.</p>

<p class="reference">References <a class="el" href="_ast_qualified_name_8h_source.html#l00051">souffle::AstQualifiedName::prepend()</a>.</p>
<div class="fragment"><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                                                                                     {</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    AstQualifiedName res = id;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    res.prepend(name);</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="keywordflow">return</span> res;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ad202244da4a83adaa43b98ffa52c371e_cgraph.png" border="0" usemap="#namespacesouffle_ad202244da4a83adaa43b98ffa52c371e_cgraph" alt=""/></div>
<map name="namespacesouffle_ad202244da4a83adaa43b98ffa52c371e_cgraph" id="namespacesouffle_ad202244da4a83adaa43b98ffa52c371e_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_qualified_name.html#ade216b98779871251bb6272e0033bd48" title="prepend qualifiers " alt="" coords="193,5,385,47"/>
</map>
</div>

</div>
</div>
<a id="aa174f8f3342ee5a31f6fecee73a29aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa174f8f3342ee5a31f6fecee73a29aee">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; souffle::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_tuple_ref.html">TupleRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interpreter_index_8cpp_source.html#l00026">26</a> of file <a class="el" href="_interpreter_index_8cpp_source.html">InterpreterIndex.cpp</a>.</p>

<p class="reference">References <a class="el" href="json11_8h_source.html#l00651">i</a>, and <a class="el" href="_interpreter_index_8h_source.html#l00094">souffle::TupleRef::size()</a>.</p>
<div class="fragment"><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;                                                      {</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    out &lt;&lt; <span class="stringliteral">&quot;[&quot;</span>;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <span class="keywordflow">for</span> (std::size_t <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; ref.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &gt; 0) {</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;            out &lt;&lt; <span class="charliteral">&#39;,&#39;</span>;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;        }</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        out &lt;&lt; ref[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    }</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="keywordflow">return</span> out &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aa174f8f3342ee5a31f6fecee73a29aee_cgraph.png" border="0" usemap="#namespacesouffle_aa174f8f3342ee5a31f6fecee73a29aee_cgraph" alt=""/></div>
<map name="namespacesouffle_aa174f8f3342ee5a31f6fecee73a29aee_cgraph" id="namespacesouffle_aa174f8f3342ee5a31f6fecee73a29aee_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_tuple_ref.html#a5d6eba97b1fdc8ac0cc01ea5d1da4525" title="Obtains the arity of the referenced tuple. " alt="" coords="204,5,367,32"/>
</map>
</div>

</div>
</div>
<a id="ae54cfa5513383a790af97fb4e4e5a26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54cfa5513383a790af97fb4e4e5a26a">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; souffle::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0">TypeAttribute</a>&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ram_types_8h_source.html#l00038">38</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a22ae0e2b89e5e3d477f988cc36d3272b">Float</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a6a0d9eaee314c567fd72fb97ee707a36">Record</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a71fed0c3428bf1a2e19af257c4bac379">Signed</a>, <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0a02c86eb2792f3262c21d030a87e19793">Symbol</a>, and <a class="el" href="namespacesouffle.html#af5361aa1e84030b37d7c8df1bf45e1c0aa1a914735b205424ba6c40b85528d78a">Unsigned</a>.</p>
<div class="fragment"><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;                                                               {</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <span class="keywordflow">switch</span> (T) {</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        <span class="keywordflow">case</span> TypeAttribute::Symbol:</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;TypeAttribute::Symbol&quot;</span>;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        <span class="keywordflow">case</span> TypeAttribute::Signed:</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;TypeAttribute::Signed&quot;</span>;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        <span class="keywordflow">case</span> TypeAttribute::Float:</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;TypeAttribute::Float&quot;</span>;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        <span class="keywordflow">case</span> TypeAttribute::Unsigned:</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;TypeAttribute::Unsigned&quot;</span>;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        <span class="keywordflow">case</span> TypeAttribute::Record:</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;TypeAttribute::Record&quot;</span>;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    }</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="keywordflow">return</span> os;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a674f99959c31838604c3778e4ef1f919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674f99959c31838604c3778e4ef1f919">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; souffle::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_order.html">Order</a> &amp;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_interpreter_index_8cpp_source.html#l00080">80</a> of file <a class="el" href="_interpreter_index_8cpp_source.html">InterpreterIndex.cpp</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00701">join()</a>, and <a class="el" href="_interpreter_index_8h_source.html#l00133">souffle::Order::order</a>.</p>
<div class="fragment"><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                                                            {</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keywordflow">return</span> out &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <a class="code" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">join</a>(order.order) &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_abe4e3f19879707216a2758b03f4e2deb"><div class="ttname"><a href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">souffle::join</a></div><div class="ttdeci">detail::joined_sequence&lt; Iter, Printer &gt; join(const Iter &amp;a, const Iter &amp;b, const std::string &amp;sep, const Printer &amp;p)</div><div class="ttdoc">Creates an object to be forwarded to some output stream for printing sequences of elements interspers...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00701">Util.h:701</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a674f99959c31838604c3778e4ef1f919_cgraph.png" border="0" usemap="#namespacesouffle_a674f99959c31838604c3778e4ef1f919_cgraph" alt=""/></div>
<map name="namespacesouffle_a674f99959c31838604c3778e4ef1f919_cgraph" id="namespacesouffle_a674f99959c31838604c3778e4ef1f919_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb" title="Creates an object to be forwarded to some output stream for printing sequences of elements interspers..." alt="" coords="204,5,303,32"/>
</map>
</div>

</div>
</div>
<a id="aa2d1fa53d5b327689cd083732bf10665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d1fa53d5b327689cd083732bf10665">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; souffle::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle.html#a4d1111156440d898474b3cd9cd43a276">RelationQualifier</a>&#160;</td>
          <td class="paramname"><em>qualifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_relation_tag_8h_source.html#l00122">122</a> of file <a class="el" href="_relation_tag_8h_source.html">RelationTag.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529facfbac07c6ae3e73f0e10ca60ad916bef">INLINE</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529faa84cc046d48610b05c21fd3670d0c829">INPUT</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa50a87f0d71f7221582dad4bf507a0f34">OUTPUT</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fac9572efed22489a0eb4ab9dcd8132d4b">OVERRIDABLE</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa412e14f57c2f0eeb02d2475ca63bf38c">PRINTSIZE</a>, and <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa749f7196d531a918508ddc75af68469d">SUPPRESSED</a>.</p>
<div class="fragment"><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                                                                           {</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="keywordflow">switch</span> (qualifier) {</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        <span class="keywordflow">case</span> RelationQualifier::INPUT:</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;input&quot;</span>;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        <span class="keywordflow">case</span> RelationQualifier::OUTPUT:</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;output&quot;</span>;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        <span class="keywordflow">case</span> RelationQualifier::PRINTSIZE:</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;printsize&quot;</span>;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        <span class="keywordflow">case</span> RelationQualifier::OVERRIDABLE:</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;overridable&quot;</span>;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        <span class="keywordflow">case</span> RelationQualifier::INLINE:</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;inline&quot;</span>;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        <span class="keywordflow">case</span> RelationQualifier::SUPPRESSED:</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;suppressed&quot;</span>;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;            assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;unhandled relation qualifier&quot;</span>);</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    }</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="keywordflow">return</span> os;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ad8cf2396e4d4fb479990191006785299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8cf2396e4d4fb479990191006785299">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; souffle::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_rule_body.html">RuleBody</a> &amp;&#160;</td>
          <td class="paramname"><em>body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ast_parser_utils_8cpp_source.html#l00137">137</a> of file <a class="el" href="_ast_parser_utils_8cpp_source.html">AstParserUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_parser_utils_8h_source.html#l00070">souffle::RuleBody::dnf</a>, and <a class="el" href="_util_8h_source.html#l00701">join()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_interpreter_index_8h_source.html#l00169">souffle::Order::getOrder()</a>, and <a class="el" href="_interpreter_index_8h_source.html#l00112">souffle::TupleRef::operator==()</a>.</p>
<div class="fragment"><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                                                              {</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="keywordflow">return</span> out &lt;&lt; <a class="code" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">join</a>(body.dnf, <span class="stringliteral">&quot;;&quot;</span>, [](std::ostream&amp; out, <span class="keyword">const</span> RuleBody::clause&amp; cur) {</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        out &lt;&lt; join(cur, <span class="stringliteral">&quot;,&quot;</span>, [](std::ostream&amp; out, const RuleBody::literal&amp; l) {</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;            if (l.negated) {</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                out &lt;&lt; <span class="stringliteral">&quot;!&quot;</span>;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;            }</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;            out &lt;&lt; *l.atom;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        });</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    });</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_abe4e3f19879707216a2758b03f4e2deb"><div class="ttname"><a href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">souffle::join</a></div><div class="ttdeci">detail::joined_sequence&lt; Iter, Printer &gt; join(const Iter &amp;a, const Iter &amp;b, const std::string &amp;sep, const Printer &amp;p)</div><div class="ttdoc">Creates an object to be forwarded to some output stream for printing sequences of elements interspers...</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00701">Util.h:701</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ad8cf2396e4d4fb479990191006785299_cgraph.png" border="0" usemap="#namespacesouffle_ad8cf2396e4d4fb479990191006785299_cgraph" alt=""/></div>
<map name="namespacesouffle_ad8cf2396e4d4fb479990191006785299_cgraph" id="namespacesouffle_ad8cf2396e4d4fb479990191006785299_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb" title="Creates an object to be forwarded to some output stream for printing sequences of elements interspers..." alt="" coords="204,5,303,32"/>
</map>
</div>

</div>
</div>
<a id="a45442942bd3d9825308c57c97bdb5c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45442942bd3d9825308c57c97bdb5c9e">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; souffle::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9e">RelationRepresentation</a>&#160;</td>
          <td class="paramname"><em>representation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_relation_tag_8h_source.html#l00149">149</a> of file <a class="el" href="_relation_tag_8h_source.html">RelationTag.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fade0f2c62e46b76fe07b1033a2af15a28">BRIE</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa26daa90bc6e4e7baf2b5781caef22940">BTREE</a>, <a class="el" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9ea5b39c8b553c821e7cddc6da64b5bd2ee">DEFAULT</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa06a35dca93aeafc1b0f548410517223a">EQREL</a>, and <a class="el" href="namespacesouffle.html#a6309f0948137356de74c7d16ffbf2d9ea551b723eafd6a31d444fcb2f5920fbd3">INFO</a>.</p>
<div class="fragment"><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;                                                                                     {</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="keywordflow">switch</span> (representation) {</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        <span class="keywordflow">case</span> RelationRepresentation::BTREE:</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;btree&quot;</span>;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        <span class="keywordflow">case</span> RelationRepresentation::BRIE:</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;brie&quot;</span>;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="keywordflow">case</span> RelationRepresentation::EQREL:</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;eqrel&quot;</span>;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        <span class="keywordflow">case</span> RelationRepresentation::INFO:</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;info&quot;</span>;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        <span class="keywordflow">case</span> RelationRepresentation::DEFAULT:</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    }</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <span class="keywordflow">return</span> os;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a9dfb7f5671f38232db9a50606d07fe04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfb7f5671f38232db9a50606d07fe04">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; souffle::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_l_r_u_cache.html">LRUCache</a>&lt; T, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01502">1502</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;                                                                        {</div><div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;    <span class="keywordtype">bool</span> first = <span class="keyword">true</span>;</div><div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;    cache.forEachInOrder([&amp;](<span class="keyword">const</span> T&amp; val) {</div><div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;        <span class="keywordflow">if</span> (!first) {</div><div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;            out &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;</div><div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;        }</div><div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;        first = <span class="keyword">false</span>;</div><div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;        out &lt;&lt; val;</div><div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;    });</div><div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;    <span class="keywordflow">return</span> out;</div><div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a109db698f6adb0de81299c0108b617f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109db698f6adb0de81299c0108b617f6">&#9670;&nbsp;</a></span>pack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Arity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#aa9d8dbe49d3251e572172b31023b1ce9">RamDomain</a> souffle::pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_record_table.html">RecordTable</a> &amp;&#160;</td>
          <td class="paramname"><em>recordTab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsouffle_1_1_tuple.html">Tuple</a>&lt; <a class="el" href="namespacesouffle.html#aa9d8dbe49d3251e572172b31023b1ce9">RamDomain</a>, Arity &gt;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper to convert tuple to record reference for the synthesiser </p>

<p class="definition">Definition at line <a class="el" href="_record_table_8h_source.html#l00143">143</a> of file <a class="el" href="_record_table_8h_source.html">RecordTable.h</a>.</p>

<p class="reference">References <a class="el" href="_compiled_tuple_8h_source.html#l00038">souffle::Tuple&lt; Domain, _arity &gt;::data</a>, and <a class="el" href="_record_table_8h_source.html#l00115">souffle::RecordTable::pack()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_synthesiser_8cpp_source.html#l00172">souffle::Synthesiser::emitCode()</a>, and <a class="el" href="_ram_level_analysis_8cpp_source.html#l00023">souffle::RamLevelAnalysis::getLevel()</a>.</p>
<div class="fragment"><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                                                                             {</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    <span class="keywordflow">return</span> recordTab.pack(static_cast&lt;RamDomain*&gt;(tuple.data), Arity);</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a109db698f6adb0de81299c0108b617f6_cgraph.png" border="0" usemap="#namespacesouffle_a109db698f6adb0de81299c0108b617f6_cgraph" alt=""/></div>
<map name="namespacesouffle_a109db698f6adb0de81299c0108b617f6_cgraph" id="namespacesouffle_a109db698f6adb0de81299c0108b617f6_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_record_table.html#a30764bb03ecccb41235514a2cfbbcb0d" title="convert record to record reference " alt="" coords="159,5,311,47"/>
</map>
</div>

</div>
</div>
<a id="a168e2fae5a34ddc5215c94d27893a7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168e2fae5a34ddc5215c94d27893a7ff">&#9670;&nbsp;</a></span>pathJoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::pathJoin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join two paths together; note that this does not resolve overlaps or relative paths. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01148">1148</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;                                                                           {</div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;    <span class="keywordtype">unsigned</span> firstPos = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(first.size()) - 1;</div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;    <span class="keywordflow">while</span> (first.at(firstPos) == <span class="charliteral">&#39;/&#39;</span>) {</div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;        firstPos--;</div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;    }</div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;    <span class="keywordtype">unsigned</span> secondPos = 0;</div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;    <span class="keywordflow">while</span> (second.at(secondPos) == <span class="charliteral">&#39;/&#39;</span>) {</div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;        secondPos++;</div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;    }</div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;    <span class="keywordflow">return</span> first.substr(0, firstPos + 1) + <span class="charliteral">&#39;/&#39;</span> + second.substr(secondPos);</div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aa3bd1d83dcab901258167a7892db39be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bd1d83dcab901258167a7892db39be">&#9670;&nbsp;</a></span>ramBitCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To  = RamDomain, typename From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">To souffle::ramBitCast </td>
          <td>(</td>
          <td class="paramtype">From&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In C++20 there will be a new way to cast between types by reinterpreting bits (std::bit_cast), but as of January 2020 it is not yet supported. </p>
<p>Cast a type by reinterpreting its bits. Domain is restricted to Ram Types only. Template takes two types (second type is never necessary because it can be deduced from the argument) The following always holds For type T and a : T ramBitCast&lt;T&gt;(ramBitCast&lt;RamDomain&gt;(a)) == a </p>

<p class="definition">Definition at line <a class="el" href="_ram_types_8h_source.html#l00123">123</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_explain_provenance_8h_source.html#l00188">souffle::ExplainProvenance::argsToNums()</a>, <a class="el" href="_interpreter_engine_8cpp_source.html#l00220">souffle::InterpreterEngine::execute()</a>, <a class="el" href="_interpreter_engine_8cpp_source.html#l01218">souffle::InterpreterEngine::executeAggregate()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00757">souffle::ExplainProvenanceImpl::findTuple()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00512">souffle::ExplainProvenanceImpl::measureRelation()</a>, <a class="el" href="_souffle_interface_8h_source.html#l00554">souffle::tuple::operator&lt;&lt;()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00613">souffle::ExplainProvenanceImpl::queryProcess()</a>, <a class="el" href="_read_stream_c_s_v_8h_source.html#l00059">souffle::ReadStreamCSV::readNextTuple()</a>, and <a class="el" href="_read_stream_8h_source.html#l00076">souffle::ReadStream::readRecord()</a>.</p>
<div class="fragment"><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                           {</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    static_assert(isRamType&lt;From&gt; &amp;&amp; isRamType&lt;To&gt;, <span class="stringliteral">&quot;Bit casting should only be used on Ram Types.&quot;</span>);</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    static_assert(<span class="keyword">sizeof</span>(To) == <span class="keyword">sizeof</span>(From), <span class="stringliteral">&quot;Can&#39;t bit cast types with different size.&quot;</span>);</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    To destination;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    memcpy(&amp;destination, &amp;source, <span class="keyword">sizeof</span>(destination));</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    <span class="keywordflow">return</span> destination;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a42f50e44c16d45c78e4a37b005ac94c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f50e44c16d45c78e4a37b005ac94c9">&#9670;&nbsp;</a></span>RamFloatFromString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#a71ed4e379ed3ad06b9d02a4fc8470646">RamFloat</a> souffle::RamFloatFromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>position</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a string to a RamFloat. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00163">163</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_explain_provenance_8h_source.html#l00188">souffle::ExplainProvenance::argsToNums()</a>, <a class="el" href="_util_8h_source.html#l00262">canBeParsedAsRamFloat()</a>, <a class="el" href="_ast_translator_8h_source.html#l00406">souffle::AstTranslator::getConstantRamRepresentation()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00613">souffle::ExplainProvenanceImpl::queryProcess()</a>, <a class="el" href="_read_stream_c_s_v_8h_source.html#l00059">souffle::ReadStreamCSV::readNextTuple()</a>, <a class="el" href="_read_stream_8h_source.html#l00076">souffle::ReadStream::readRecord()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l00285">souffle::AstTranslator::translateValue()</a>.</p>
<div class="fragment"><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                                                                                        {</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    <a class="code" href="namespacesouffle.html#a71ed4e379ed3ad06b9d02a4fc8470646">RamFloat</a> val;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="preprocessor">#if RAM_DOMAIN_SIZE == 64</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    val = std::stod(<a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, position);</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    val = std::stof(<a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, position);</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="namespacesouffle.html#a71ed4e379ed3ad06b9d02a4fc8470646">RamFloat</a><span class="keyword">&gt;</span>(val);</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a71ed4e379ed3ad06b9d02a4fc8470646"><div class="ttname"><a href="namespacesouffle.html#a71ed4e379ed3ad06b9d02a4fc8470646">souffle::RamFloat</a></div><div class="ttdeci">float RamFloat</div><div class="ttdef"><b>Definition:</b> <a href="_ram_types_8h_source.html#l00096">RamTypes.h:96</a></div></div>
<div class="ttc" id="json11_8h_html_a25fda444d34d64acade61be6f9d35367"><div class="ttname"><a href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a></div><div class="ttdeci">const std::string &amp; str</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00650">json11.h:650</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad354d1210c639429c093f92ba2966a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad354d1210c639429c093f92ba2966a75">&#9670;&nbsp;</a></span>RamSignedFromString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#a506d6a56200708498577b6e4d3a83ae3">RamSigned</a> souffle::RamSignedFromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>position</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a string to a RamSigned. </p>
<p>This procedure has similar behaviour to std::stoi/stoll.</p>
<p>The procedure accepts prefixes 0b (if base = 2) and 0x (if base = 16) If base = 0, the procedure will try to infer the base from the prefix, if present. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00121">121</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_reader_8h_source.html#l00060">base</a>, <a class="el" href="_util_8h_source.html#l00879">isPrefix()</a>, and <a class="el" href="json11_8h_source.html#l00650">str</a>.</p>

<p class="reference">Referenced by <a class="el" href="_explain_provenance_8h_source.html#l00188">souffle::ExplainProvenance::argsToNums()</a>, <a class="el" href="_util_8h_source.html#l00232">canBeParsedAsRamSigned()</a>, <a class="el" href="_interpreter_engine_8cpp_source.html#l00220">souffle::InterpreterEngine::execute()</a>, <a class="el" href="_ast_translator_8h_source.html#l00406">souffle::AstTranslator::getConstantRamRepresentation()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00613">souffle::ExplainProvenanceImpl::queryProcess()</a>, <a class="el" href="_read_stream_s_q_lite_8h_source.html#l00054">souffle::ReadStreamSQLite::readNextTuple()</a>, <a class="el" href="_read_stream_c_s_v_8h_source.html#l00059">souffle::ReadStreamCSV::readNextTuple()</a>, <a class="el" href="_read_stream_8h_source.html#l00076">souffle::ReadStream::readRecord()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l00285">souffle::AstTranslator::translateValue()</a>.</p>
<div class="fragment"><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                                                                                  {</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <a class="code" href="namespacesouffle.html#a506d6a56200708498577b6e4d3a83ae3">RamSigned</a> val;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a> == 0) {</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0">isPrefix</a>(<span class="stringliteral">&quot;-0b&quot;</span>, <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>) || <a class="code" href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0">isPrefix</a>(<span class="stringliteral">&quot;0b&quot;</span>, <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>)) {</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#ad354d1210c639429c093f92ba2966a75">RamSignedFromString</a>(<a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, position, 2);</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0">isPrefix</a>(<span class="stringliteral">&quot;-0x&quot;</span>, <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>) || <a class="code" href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0">isPrefix</a>(<span class="stringliteral">&quot;0x&quot;</span>, <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>)) {</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#ad354d1210c639429c093f92ba2966a75">RamSignedFromString</a>(<a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, position, 16);</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#ad354d1210c639429c093f92ba2966a75">RamSignedFromString</a>(<a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, position);</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        }</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    }</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    std::string binaryNumber;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    <span class="keywordtype">bool</span> parsingBinary = <a class="code" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a> == 2;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    <span class="comment">// stoi/stoll can&#39;t handle base 2 prefix by default.</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="keywordflow">if</span> (parsingBinary) {</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0">isPrefix</a>(<span class="stringliteral">&quot;-0b&quot;</span>, <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>)) {</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;            binaryNumber = <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>.substr(3);</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0">isPrefix</a>(<span class="stringliteral">&quot;0b&quot;</span>, <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>)) {</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;            binaryNumber = <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>.substr(2);</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        }</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    }</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="keyword">const</span> std::string&amp; tmp = parsingBinary ? binaryNumber : <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="preprocessor">#if RAM_DOMAIN_SIZE == 64</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    val = std::stoll(tmp, position, <a class="code" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a>);</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    val = std::stoi(tmp, position, <a class="code" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a>);</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    <span class="keywordflow">if</span> (parsingBinary &amp;&amp; position != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        *position += 2;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    }</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    <span class="keywordflow">return</span> val;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a506d6a56200708498577b6e4d3a83ae3"><div class="ttname"><a href="namespacesouffle.html#a506d6a56200708498577b6e4d3a83ae3">souffle::RamSigned</a></div><div class="ttdeci">RamDomain RamSigned</div><div class="ttdef"><b>Definition:</b> <a href="_ram_types_8h_source.html#l00093">RamTypes.h:93</a></div></div>
<div class="ttc" id="namespacesouffle_html_ab9fd86fe230c58e924db2cf47e1ba5e0"><div class="ttname"><a href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0">souffle::isPrefix</a></div><div class="ttdeci">bool isPrefix(const std::string &amp;prefix, const std::string &amp;element)</div><div class="ttdoc">Determine if one string is a prefix of another. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00879">Util.h:879</a></div></div>
<div class="ttc" id="_reader_8h_html_a4ce824b383e7379148b61ee135baac5a"><div class="ttname"><a href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a></div><div class="ttdeci">T &amp; base</div><div class="ttdef"><b>Definition:</b> <a href="_reader_8h_source.html#l00060">Reader.h:60</a></div></div>
<div class="ttc" id="json11_8h_html_a25fda444d34d64acade61be6f9d35367"><div class="ttname"><a href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a></div><div class="ttdeci">const std::string &amp; str</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00650">json11.h:650</a></div></div>
<div class="ttc" id="namespacesouffle_html_ad354d1210c639429c093f92ba2966a75"><div class="ttname"><a href="namespacesouffle.html#ad354d1210c639429c093f92ba2966a75">souffle::RamSignedFromString</a></div><div class="ttdeci">RamSigned RamSignedFromString(const std::string &amp;str, std::size_t *position=nullptr, const int base=10)</div><div class="ttdoc">Converts a string to a RamSigned. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00121">Util.h:121</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ad354d1210c639429c093f92ba2966a75_cgraph.png" border="0" usemap="#namespacesouffle_ad354d1210c639429c093f92ba2966a75_cgraph" alt=""/></div>
<map name="namespacesouffle_ad354d1210c639429c093f92ba2966a75_cgraph" id="namespacesouffle_ad354d1210c639429c093f92ba2966a75_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0" title="Determine if one string is a prefix of another. " alt="" coords="272,5,395,32"/>
</map>
</div>

</div>
</div>
<a id="a084bbb9535fee35e4682c948ce88bddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084bbb9535fee35e4682c948ce88bddb">&#9670;&nbsp;</a></span>RamUnsignedFromString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#afaab74f4511cf7a2da6afe0e001be9c6">RamUnsigned</a> souffle::RamUnsignedFromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>position</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a string to a RamUnsigned. </p>
<p>This procedure has similar behaviour to std::stoul/stoull.</p>
<p>The procedure accepts prefixes 0b (if base = 2) and 0x (if base = 16) If base = 0, the procedure will try to infer the base from the prefix, if present. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00180">180</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="_reader_8h_source.html#l00060">base</a>, <a class="el" href="_util_8h_source.html#l00879">isPrefix()</a>, and <a class="el" href="json11_8h_source.html#l00650">str</a>.</p>

<p class="reference">Referenced by <a class="el" href="_explain_provenance_8h_source.html#l00188">souffle::ExplainProvenance::argsToNums()</a>, <a class="el" href="_util_8h_source.html#l00249">canBeParsedAsRamUnsigned()</a>, <a class="el" href="_ast_translator_8h_source.html#l00406">souffle::AstTranslator::getConstantRamRepresentation()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00613">souffle::ExplainProvenanceImpl::queryProcess()</a>, <a class="el" href="_read_stream_c_s_v_8h_source.html#l00128">souffle::ReadStreamCSV::readRamUnsigned()</a>, <a class="el" href="_read_stream_8h_source.html#l00076">souffle::ReadStream::readRecord()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l00285">souffle::AstTranslator::translateValue()</a>.</p>
<div class="fragment"><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                                                                                  {</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <span class="comment">// Be default C++ (stoul) allows unsigned numbers starting with &quot;-&quot;.</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0">isPrefix</a>(<span class="stringliteral">&quot;-&quot;</span>, <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>)) {</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Unsigned number can&#39;t start with minus.&quot;</span>);</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    }</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a> == 0) {</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0">isPrefix</a>(<span class="stringliteral">&quot;0b&quot;</span>, <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>)) {</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a084bbb9535fee35e4682c948ce88bddb">RamUnsignedFromString</a>(<a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, position, 2);</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0">isPrefix</a>(<span class="stringliteral">&quot;0x&quot;</span>, <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>)) {</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a084bbb9535fee35e4682c948ce88bddb">RamUnsignedFromString</a>(<a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, position, 16);</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespacesouffle.html#a084bbb9535fee35e4682c948ce88bddb">RamUnsignedFromString</a>(<a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>, position);</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        }</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    }</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <span class="comment">// stoul/stoull can&#39;t handle binary prefix by default.</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    std::string binaryNumber;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="keywordtype">bool</span> parsingBinary = <span class="keyword">false</span>;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a> == 2 &amp;&amp; <a class="code" href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0">isPrefix</a>(<span class="stringliteral">&quot;0b&quot;</span>, <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>)) {</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        binaryNumber = <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>.substr(2);</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        parsingBinary = <span class="keyword">true</span>;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    }</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="keyword">const</span> std::string&amp; tmp = parsingBinary ? binaryNumber : <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    <a class="code" href="namespacesouffle.html#afaab74f4511cf7a2da6afe0e001be9c6">RamUnsigned</a> val;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="preprocessor">#if RAM_DOMAIN_SIZE == 64</span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    val = std::stoull(tmp, position, <a class="code" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a>);</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    val = std::stoul(tmp, position, <a class="code" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a>);</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="keywordflow">if</span> (parsingBinary &amp;&amp; position != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        *position += 2;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    }</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    <span class="comment">// check if it&#39;s safe to cast (stoul returns unsigned long)</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    <span class="keywordflow">if</span> (val &gt; std::numeric_limits&lt;RamUnsigned&gt;::max()) {</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Unsigned number of of bounds&quot;</span>);</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    }</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="namespacesouffle.html#afaab74f4511cf7a2da6afe0e001be9c6">RamUnsigned</a><span class="keyword">&gt;</span>(val);</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_ab9fd86fe230c58e924db2cf47e1ba5e0"><div class="ttname"><a href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0">souffle::isPrefix</a></div><div class="ttdeci">bool isPrefix(const std::string &amp;prefix, const std::string &amp;element)</div><div class="ttdoc">Determine if one string is a prefix of another. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00879">Util.h:879</a></div></div>
<div class="ttc" id="namespacesouffle_html_afaab74f4511cf7a2da6afe0e001be9c6"><div class="ttname"><a href="namespacesouffle.html#afaab74f4511cf7a2da6afe0e001be9c6">souffle::RamUnsigned</a></div><div class="ttdeci">uint32_t RamUnsigned</div><div class="ttdef"><b>Definition:</b> <a href="_ram_types_8h_source.html#l00094">RamTypes.h:94</a></div></div>
<div class="ttc" id="_reader_8h_html_a4ce824b383e7379148b61ee135baac5a"><div class="ttname"><a href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a></div><div class="ttdeci">T &amp; base</div><div class="ttdef"><b>Definition:</b> <a href="_reader_8h_source.html#l00060">Reader.h:60</a></div></div>
<div class="ttc" id="json11_8h_html_a25fda444d34d64acade61be6f9d35367"><div class="ttname"><a href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a></div><div class="ttdeci">const std::string &amp; str</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00650">json11.h:650</a></div></div>
<div class="ttc" id="namespacesouffle_html_a084bbb9535fee35e4682c948ce88bddb"><div class="ttname"><a href="namespacesouffle.html#a084bbb9535fee35e4682c948ce88bddb">souffle::RamUnsignedFromString</a></div><div class="ttdeci">RamUnsigned RamUnsignedFromString(const std::string &amp;str, std::size_t *position=nullptr, const int base=10)</div><div class="ttdoc">Converts a string to a RamUnsigned. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00180">Util.h:180</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a084bbb9535fee35e4682c948ce88bddb_cgraph.png" border="0" usemap="#namespacesouffle_a084bbb9535fee35e4682c948ce88bddb_cgraph" alt=""/></div>
<map name="namespacesouffle_a084bbb9535fee35e4682c948ce88bddb_cgraph" id="namespacesouffle_a084bbb9535fee35e4682c948ce88bddb_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#ab9fd86fe230c58e924db2cf47e1ba5e0" title="Determine if one string is a prefix of another. " alt="" coords="251,13,373,39"/>
</map>
</div>

</div>
</div>
<a id="a34b5ec91eb9db76098b8088964808456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b5ec91eb9db76098b8088964808456">&#9670;&nbsp;</a></span>reduceLocallyEquivalentClauses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::reduceLocallyEquivalentClauses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_translation_unit.html">AstTranslationUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>translationUnit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces locally-redundant clauses. </p>
<p>A clause is locally-redundant if there is another clause within the same relation that computes the same set of tuples. </p><dl class="section return"><dt>Returns</dt><dd>true iff the program was changed </dd></dl>

<p class="definition">Definition at line <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00324">324</a> of file <a class="el" href="_minimise_program_transformer_8cpp_source.html">MinimiseProgramTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00249">areBijectivelyEquivalent()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00042">getClauses()</a>, <a class="el" href="_ast_translation_unit_8h_source.html#l00069">souffle::AstTranslationUnit::getProgram()</a>, <a class="el" href="_ast_program_8h_source.html#l00057">souffle::AstProgram::getRelations()</a>, and <a class="el" href="_ast_program_8h_source.html#l00112">souffle::AstProgram::removeClause()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00453">souffle::MinimiseProgramTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                                                                         {</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    AstProgram&amp; program = *translationUnit.getProgram();</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    std::vector&lt;AstClause*&gt; clausesToDelete;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    <span class="comment">// split up each relation&#39;s rules into equivalence classes</span></div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    <span class="comment">// TODO (azreika): consider turning this into an ast analysis instead</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    <span class="keywordflow">for</span> (AstRelation* rel : program.getRelations()) {</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;        std::vector&lt;std::vector&lt;AstClause*&gt;&gt; equivalenceClasses;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;        <span class="keywordflow">for</span> (AstClause* clause : <a class="code" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">getClauses</a>(program, *rel)) {</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;            <span class="keywordtype">bool</span> added = <span class="keyword">false</span>;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;            <span class="keywordflow">for</span> (std::vector&lt;AstClause*&gt;&amp; eqClass : equivalenceClasses) {</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                AstClause* rep = eqClass[0];</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a979f111a08bcb653771f92ec4c8c3e16">areBijectivelyEquivalent</a>(rep, clause)) {</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                    <span class="comment">// clause belongs to an existing equivalence class, so delete it</span></div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                    eqClass.push_back(clause);</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                    clausesToDelete.push_back(clause);</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                    added = <span class="keyword">true</span>;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                }</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;            }</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;            <span class="keywordflow">if</span> (!added) {</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;                <span class="comment">// clause does not belong to any existing equivalence class, so keep it</span></div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                std::vector&lt;AstClause*&gt; clauseToAdd = {clause};</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                equivalenceClasses.push_back(clauseToAdd);</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;            }</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        }</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    }</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    <span class="comment">// remove non-representative clauses</span></div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> clause : clausesToDelete) {</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;        program.removeClause(clause);</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    }</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    <span class="comment">// changed iff any clauses were deleted</span></div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    <span class="keywordflow">return</span> !clausesToDelete.empty();</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a979f111a08bcb653771f92ec4c8c3e16"><div class="ttname"><a href="namespacesouffle.html#a979f111a08bcb653771f92ec4c8c3e16">souffle::areBijectivelyEquivalent</a></div><div class="ttdeci">bool areBijectivelyEquivalent(const AstClause *left, const AstClause *right)</div><div class="ttdoc">Check whether two clauses are bijectively equivalent. </div><div class="ttdef"><b>Definition:</b> <a href="_minimise_program_transformer_8cpp_source.html#l00249">MinimiseProgramTransformer.cpp:249</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4d9e53888640a9abfd7ea7c43715152a"><div class="ttname"><a href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">souffle::getClauses</a></div><div class="ttdeci">std::vector&lt; AstClause * &gt; getClauses(const AstProgram &amp;program, const AstQualifiedName &amp;relationName)</div><div class="ttdoc">Returns a vector of clauses in the program describing the relation with the given name...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00042">AstUtils.cpp:42</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a34b5ec91eb9db76098b8088964808456_cgraph.png" border="0" usemap="#namespacesouffle_a34b5ec91eb9db76098b8088964808456_cgraph" alt=""/></div>
<map name="namespacesouffle_a34b5ec91eb9db76098b8088964808456_cgraph" id="namespacesouffle_a34b5ec91eb9db76098b8088964808456_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a979f111a08bcb653771f92ec4c8c3e16" title="Check whether two clauses are bijectively equivalent. " alt="" coords="287,480,520,506"/>
<area shape="rect" id="node26" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="330,716,477,742"/>
<area shape="rect" id="node28" href="classsouffle_1_1_ast_translation_unit.html#a85862a5fcfecdf63c7367926cdedde23" title="get the AST program " alt="" coords="307,767,500,808"/>
<area shape="rect" id="node29" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="596,658,747,699"/>
<area shape="rect" id="node30" href="classsouffle_1_1_ast_program.html#a0bde67af569811987d8e21929163d132" title="remove a clause " alt="" coords="328,832,479,874"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a63b103a79e1c9886c80cff614ba6ef93" title="Extract valid permutations from a given permutation matrix of valid moves. " alt="" coords="568,404,775,430"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_atom.html#a6728012e15c7e2be0b626c477c5018fd" title="get arity of the atom " alt="" coords="576,454,767,481"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="1097,502,1236,543"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="1369,346,1507,387"/>
<area shape="rect" id="node8" href="namespacesouffle.html#a90ecff533a6bf91c15209f6fbb56235f" title="Check if the atom at leftIdx in the left clause can potentially be matched up with the atom at rightI..." alt="" coords="831,606,983,633"/>
<area shape="rect" id="node10" href="namespacesouffle.html#aa3867b63ae91058fdbcbff1475240b16" title="Check whether a valid variable mapping exists for the given permutation. " alt="" coords="573,284,770,310"/>
<area shape="rect" id="node23" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="823,444,991,470"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1365,669,1511,696"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="1039,618,1295,645"/>
<area shape="rect" id="node11" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Create a clone (i.e. " alt="" coords="1097,35,1236,76"/>
<area shape="rect" id="node14" href="classsouffle_1_1_ast_variable.html#a2b73a95c7b59624d956dee0ed4e13884" title="souffle::AstVariable\l::getName" alt="" coords="833,116,981,158"/>
<area shape="rect" id="node15" href="namespacesouffle.html#ae77f3374134c13b638bf7644fcebb5ef" title="Reorders the atoms of a clause to be in the given order. " alt="" coords="825,233,988,260"/>
<area shape="rect" id="node12" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="1581,189,1781,216"/>
<area shape="rect" id="node13" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="1383,42,1493,69"/>
<area shape="rect" id="node16" href="namespacesouffle.html#a6aa6d61f4a71ddbb2458d23ce24dbced" title="Returns a clause which contains head of the given clause. " alt="" coords="1095,130,1238,157"/>
<area shape="rect" id="node21" href="classsouffle_1_1_ast_clause.html#ac5e3416082d23734d1277daa5c9dee81" title="Add a Literal to the body of the clause. " alt="" coords="1097,182,1236,223"/>
<area shape="rect" id="node22" href="classsouffle_1_1_ast_literal.html#a8e7b7424c40acb87df022913c5928fd8" title="Create a clone (i.e. " alt="" coords="1099,247,1235,288"/>
<area shape="rect" id="node17" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Create a clone (i.e. " alt="" coords="1351,277,1525,304"/>
<area shape="rect" id="node19" href="classsouffle_1_1_ast_execution_plan.html#ac657ffa016ae777656585a56fc9a899c" title="Create a clone (i.e. " alt="" coords="1345,211,1531,252"/>
<area shape="rect" id="node20" href="classsouffle_1_1_ast_clause.html#aa943423c45971e70c837da5b88c8fc04" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="1367,94,1509,135"/>
<area shape="rect" id="node18" href="classsouffle_1_1_ast_atom.html#acef18129b13ce45477044717ded051d2" title="souffle::AstAtom::AstAtom" alt="" coords="1584,277,1779,304"/>
<area shape="rect" id="node24" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="1083,436,1251,478"/>
<area shape="rect" id="node25" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="1343,436,1533,478"/>
<area shape="rect" id="node27" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="596,723,747,764"/>
</map>
</div>

</div>
</div>
<a id="ab2a8f568c6ad4616e8ab6225b0e023ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a8f568c6ad4616e8ab6225b0e023ce">&#9670;&nbsp;</a></span>reduceSingletonRelations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::reduceSingletonRelations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_translation_unit.html">AstTranslationUnit</a> &amp;&#160;</td>
          <td class="paramname"><em>translationUnit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes redundant singleton relations. </p>
<p>Singleton relations are relations with a single clause. A singleton relation is redundant if there exists another singleton relation that computes the same set of tuples. </p><dl class="section return"><dt>Returns</dt><dd>true iff the program was changed </dd></dl>

<p class="definition">Definition at line <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00372">372</a> of file <a class="el" href="_minimise_program_transformer_8cpp_source.html">MinimiseProgramTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_program_8h_source.html#l00164">souffle::AstProgram::apply()</a>, <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00249">areBijectivelyEquivalent()</a>, <a class="el" href="_ast_translation_unit_8h_source.html#l00045">souffle::AstTranslationUnit::getAnalysis()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00042">getClauses()</a>, <a class="el" href="_ast_clause_8h_source.html#l00166">souffle::AstClause::getHead()</a>, <a class="el" href="_ast_translation_unit_8h_source.html#l00069">souffle::AstTranslationUnit::getProgram()</a>, <a class="el" href="_ast_literal_8h_source.html#l00058">souffle::AstAtom::getQualifiedName()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00056">getRelation()</a>, <a class="el" href="_ast_program_8h_source.html#l00057">souffle::AstProgram::getRelations()</a>, <a class="el" href="json11_8h_source.html#l00651">i</a>, <a class="el" href="html_js_chartist_min_8h_source.html#l00015">j</a>, <a class="el" href="_ast_program_8h_source.html#l00112">souffle::AstProgram::removeClause()</a>, and <a class="el" href="_ast_program_8h_source.html#l00088">souffle::AstProgram::removeRelation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00453">souffle::MinimiseProgramTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;                                                                   {</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    <span class="comment">// Note: This reduction is particularly useful in conjunction with the</span></div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    <span class="comment">// body-partitioning transformation</span></div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    AstProgram&amp; program = *translationUnit.getProgram();</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    <span class="keyword">auto</span>* ioTypes = translationUnit.getAnalysis&lt;IOType&gt;();</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    <span class="comment">// Find all singleton relations to consider</span></div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    std::vector&lt;AstClause*&gt; singletonRelationClauses;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <span class="keywordflow">for</span> (AstRelation* rel : program.getRelations()) {</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        <span class="keywordflow">if</span> (!ioTypes-&gt;isIO(rel) &amp;&amp; <a class="code" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">getClauses</a>(program, *rel).size() == 1) {</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;            AstClause* clause = <a class="code" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">getClauses</a>(program, *rel)[0];</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;            singletonRelationClauses.push_back(clause);</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        }</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    }</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    <span class="comment">// Keep track of clauses found to be redundant</span></div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    std::set&lt;AstClause*&gt; redundantClauses;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    <span class="comment">// Keep track of canonical relation name for each redundant clause</span></div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    std::map&lt;AstQualifiedName, AstQualifiedName&gt; canonicalName;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    <span class="comment">// Check pairwise equivalence of each singleton relation</span></div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; singletonRelationClauses.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;        AstClause* first = singletonRelationClauses[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;        <span class="keywordflow">if</span> (redundantClauses.find(first) != redundantClauses.end()) {</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;            <span class="comment">// Already found to be redundant, no need to check</span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;        }</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> = <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> + 1; <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> &lt; singletonRelationClauses.size(); <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>++) {</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;            AstClause* second = singletonRelationClauses[<a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>];</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;            <span class="comment">// Note: Bijective-equivalence check does not care about the head relation name</span></div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a979f111a08bcb653771f92ec4c8c3e16">areBijectivelyEquivalent</a>(first, second)) {</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;                AstQualifiedName firstName = first-&gt;getHead()-&gt;getQualifiedName();</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;                AstQualifiedName secondName = second-&gt;getHead()-&gt;getQualifiedName();</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;                redundantClauses.insert(second);</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;                canonicalName.insert(std::pair(secondName, firstName));</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;            }</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        }</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    }</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    <span class="comment">// Remove redundant relation definitions</span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    <span class="keywordflow">for</span> (AstClause* clause : redundantClauses) {</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        <span class="keyword">auto</span> relName = clause-&gt;getHead()-&gt;getQualifiedName();</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        AstRelation* rel = <a class="code" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">getRelation</a>(program, relName);</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        assert(rel != <span class="keyword">nullptr</span> &amp;&amp; <span class="stringliteral">&quot;relation does not exist in program&quot;</span>);</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        program.removeClause(clause);</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        program.removeRelation(relName);</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    }</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    <span class="comment">// Replace each redundant relation appearance with its canonical name</span></div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    <span class="keyword">struct </span>replaceRedundantRelations : <span class="keyword">public</span> AstNodeMapper {</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;        <span class="keyword">const</span> std::map&lt;AstQualifiedName, AstQualifiedName&gt;&amp; canonicalName;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;        replaceRedundantRelations(<span class="keyword">const</span> std::map&lt;AstQualifiedName, AstQualifiedName&gt;&amp; canonicalName)</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;                : canonicalName(canonicalName) {}</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;        std::unique_ptr&lt;AstNode&gt; operator()(std::unique_ptr&lt;AstNode&gt; node)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;            <span class="comment">// Remove appearances from children nodes</span></div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">auto</span>* atom = dynamic_cast&lt;AstAtom*&gt;(node.get())) {</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;                <span class="keyword">auto</span> pos = canonicalName.find(atom-&gt;getQualifiedName());</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;                <span class="keywordflow">if</span> (pos != canonicalName.end()) {</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;                    <span class="keyword">auto</span> newAtom = std::unique_ptr&lt;AstAtom&gt;(atom-&gt;clone());</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;                    newAtom-&gt;setQualifiedName(pos-&gt;second);</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                    <span class="keywordflow">return</span> newAtom;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;                }</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            }</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;            <span class="keywordflow">return</span> node;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;        }</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    };</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    replaceRedundantRelations update(canonicalName);</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    program.apply(update);</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    <span class="comment">// Program was changed iff a relation was replaced</span></div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    <span class="keywordflow">return</span> !canonicalName.empty();</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a979f111a08bcb653771f92ec4c8c3e16"><div class="ttname"><a href="namespacesouffle.html#a979f111a08bcb653771f92ec4c8c3e16">souffle::areBijectivelyEquivalent</a></div><div class="ttdeci">bool areBijectivelyEquivalent(const AstClause *left, const AstClause *right)</div><div class="ttdoc">Check whether two clauses are bijectively equivalent. </div><div class="ttdef"><b>Definition:</b> <a href="_minimise_program_transformer_8cpp_source.html#l00249">MinimiseProgramTransformer.cpp:249</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="namespacesouffle_html_ada252aa15afbf7d703a11b000dfd4048"><div class="ttname"><a href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048">souffle::getRelation</a></div><div class="ttdeci">AstRelation * getRelation(const AstProgram &amp;program, const AstQualifiedName &amp;name)</div><div class="ttdoc">Returns the relation with the given name in the program. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00056">AstUtils.cpp:56</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_aab858032a95af802114b255fac6f45f2"><div class="ttname"><a href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a></div><div class="ttdeci">var j</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4d9e53888640a9abfd7ea7c43715152a"><div class="ttname"><a href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">souffle::getClauses</a></div><div class="ttdeci">std::vector&lt; AstClause * &gt; getClauses(const AstProgram &amp;program, const AstQualifiedName &amp;relationName)</div><div class="ttdoc">Returns a vector of clauses in the program describing the relation with the given name...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00042">AstUtils.cpp:42</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ab2a8f568c6ad4616e8ab6225b0e023ce_cgraph.png" border="0" usemap="#namespacesouffle_ab2a8f568c6ad4616e8ab6225b0e023ce_cgraph" alt=""/></div>
<map name="namespacesouffle_ab2a8f568c6ad4616e8ab6225b0e023ce_cgraph" id="namespacesouffle_ab2a8f568c6ad4616e8ab6225b0e023ce_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_program.html#a0a658e411394dfc93da0ab36e06d0101" title="Apply the mapper to all child nodes. " alt="" coords="273,5,424,47"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a979f111a08bcb653771f92ec4c8c3e16" title="Check whether two clauses are bijectively equivalent. " alt="" coords="232,303,465,330"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="1335,232,1474,273"/>
<area shape="rect" id="node10" href="classsouffle_1_1_ast_atom.html#a2fcd569fa7d8ed8c0c2dfd0d1c362e50" title="get qualified name " alt="" coords="789,663,1045,690"/>
<area shape="rect" id="node27" href="classsouffle_1_1_ast_translation_unit.html#af396e44c83e5ad410c9ec3e2f6b91758" title="get analysis: analysis is generated on the fly if not present " alt="" coords="252,977,445,1019"/>
<area shape="rect" id="node30" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="844,726,991,753"/>
<area shape="rect" id="node32" href="classsouffle_1_1_ast_translation_unit.html#a85862a5fcfecdf63c7367926cdedde23" title="get the AST program " alt="" coords="252,1043,445,1084"/>
<area shape="rect" id="node33" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="275,875,423,902"/>
<area shape="rect" id="node35" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="552,919,703,960"/>
<area shape="rect" id="node36" href="classsouffle_1_1_ast_program.html#a0bde67af569811987d8e21929163d132" title="remove a clause " alt="" coords="842,803,993,844"/>
<area shape="rect" id="node37" href="classsouffle_1_1_ast_program.html#a8bd39fbf78f6e4b5347bab4c90486bfd" title="remove relation " alt="" coords="273,759,424,800"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a63b103a79e1c9886c80cff614ba6ef93" title="Extract valid permutations from a given permutation matrix of valid moves. " alt="" coords="524,177,731,203"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#a6728012e15c7e2be0b626c477c5018fd" title="get arity of the atom " alt="" coords="532,227,723,254"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="1108,589,1247,631"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a90ecff533a6bf91c15209f6fbb56235f" title="Check if the atom at leftIdx in the left clause can potentially be matched up with the atom at rightI..." alt="" coords="551,482,703,509"/>
<area shape="rect" id="node11" href="namespacesouffle.html#aa3867b63ae91058fdbcbff1475240b16" title="Check whether a valid variable mapping exists for the given permutation. " alt="" coords="529,329,726,355"/>
<area shape="rect" id="node24" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="833,130,1001,157"/>
<area shape="rect" id="node7" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="1331,726,1478,753"/>
<area shape="rect" id="node12" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Create a clone (i.e. " alt="" coords="1108,524,1247,565"/>
<area shape="rect" id="node15" href="classsouffle_1_1_ast_variable.html#a2b73a95c7b59624d956dee0ed4e13884" title="souffle::AstVariable\l::getName" alt="" coords="843,293,991,335"/>
<area shape="rect" id="node16" href="namespacesouffle.html#ae77f3374134c13b638bf7644fcebb5ef" title="Reorders the atoms of a clause to be in the given order. " alt="" coords="836,359,999,386"/>
<area shape="rect" id="node13" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="1548,394,1748,421"/>
<area shape="rect" id="node14" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="1350,531,1459,558"/>
<area shape="rect" id="node17" href="namespacesouffle.html#a6aa6d61f4a71ddbb2458d23ce24dbced" title="Returns a clause which contains head of the given clause. " alt="" coords="1106,473,1249,499"/>
<area shape="rect" id="node22" href="classsouffle_1_1_ast_clause.html#ac5e3416082d23734d1277daa5c9dee81" title="Add a Literal to the body of the clause. " alt="" coords="1108,291,1247,332"/>
<area shape="rect" id="node23" href="classsouffle_1_1_ast_literal.html#a8e7b7424c40acb87df022913c5928fd8" title="Create a clone (i.e. " alt="" coords="1109,356,1245,397"/>
<area shape="rect" id="node18" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Create a clone (i.e. " alt="" coords="1318,481,1491,507"/>
<area shape="rect" id="node20" href="classsouffle_1_1_ast_execution_plan.html#ac657ffa016ae777656585a56fc9a899c" title="Create a clone (i.e. " alt="" coords="1311,349,1498,391"/>
<area shape="rect" id="node21" href="classsouffle_1_1_ast_clause.html#aa943423c45971e70c837da5b88c8fc04" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="1333,415,1476,456"/>
<area shape="rect" id="node19" href="classsouffle_1_1_ast_atom.html#acef18129b13ce45477044717ded051d2" title="souffle::AstAtom::AstAtom" alt="" coords="1551,481,1745,507"/>
<area shape="rect" id="node25" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="1093,123,1261,164"/>
<area shape="rect" id="node26" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="1309,123,1500,164"/>
<area shape="rect" id="node28" href="classsouffle_1_1_global.html#a2dcb257b0f98d0b882862427cc965640" title="souffle::Global::config" alt="" coords="546,985,709,1011"/>
<area shape="rect" id="node29" href="classsouffle_1_1_debug_report.html#a4e6fe0a6d9854ce570d008772daa9aba" title="souffle::DebugReport\l::addSection" alt="" coords="548,1036,707,1077"/>
<area shape="rect" id="node31" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="1102,719,1253,760"/>
<area shape="rect" id="node34" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="575,867,679,894"/>
<area shape="rect" id="node38" href="namespacesouffle.html#a503032b9def6267059072aea913780bc" title="Removes the set of clauses with the given relation name. " alt="" coords="513,766,741,793"/>
</map>
</div>

</div>
</div>
<a id="a659ae2c89cfab47908f27a660f82c147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659ae2c89cfab47908f27a660f82c147">&#9670;&nbsp;</a></span>reduceSubstitution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool souffle::reduceSubstitution </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *, <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces a vector of substitutions. </p>
<p>Returns false only if matched argument pairs are found to be incompatible. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00193">193</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="json11_8h_source.html#l00651">i</a>, <a class="el" href="_resolve_aliases_transformer_8cpp_source.html#l00160">lhs</a>, <a class="el" href="_resolve_aliases_transformer_8cpp_source.html#l00161">rhs</a>, and <a class="el" href="_constraints_8h_source.html#l00221">sub()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00255">unifyAtoms()</a>.</p>
<div class="fragment"><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                                                                             {</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    <span class="comment">// Type-Checking functions</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="keyword">auto</span> isConstant = [&amp;](AstArgument* arg) { <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span>AstConstant*<span class="keyword">&gt;</span>(arg) != <span class="keyword">nullptr</span>; };</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    <span class="keyword">auto</span> isRecord = [&amp;](AstArgument* arg) { <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span>AstRecordInit*<span class="keyword">&gt;</span>(arg) != <span class="keyword">nullptr</span>; };</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="comment">// Keep trying to reduce the substitutions until we reach a fixed point.</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="comment">// Note that at this point no underscores (&#39;_&#39;) or counters (&#39;$&#39;) should appear.</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    <span class="keywordflow">while</span> (!done) {</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        done = <span class="keyword">true</span>;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        <span class="comment">// Try reducing each pair by one step</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; <a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;            <span class="keyword">auto</span> currPair = <a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;            AstArgument* <a class="code" href="_resolve_aliases_transformer_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a> = currPair.first;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;            AstArgument* <a class="code" href="_resolve_aliases_transformer_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a> = currPair.second;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            <span class="comment">// Start trying to reduce the substitution</span></div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;            <span class="comment">// Note: Can probably go further with this substitution reduction</span></div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;            <span class="keywordflow">if</span> (*lhs == *rhs) {</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                <span class="comment">// Get rid of redundant `x = x`</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                <a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>.erase(<a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>.begin() + <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>);</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                done = <span class="keyword">false</span>;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isConstant(lhs) &amp;&amp; isConstant(rhs)) {</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                <span class="comment">// Both are constants but not equal (prev case =&gt; !=)</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                <span class="comment">// Failed to unify!</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isRecord(lhs) &amp;&amp; isRecord(rhs)) {</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                <span class="comment">// Note: we will not deal with the case where only one side is</span></div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                <span class="comment">// a record and the other is a variable, as variables can be records</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                <span class="comment">// on a deeper level.</span></div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                std::vector&lt;AstArgument*&gt; lhsArgs = <span class="keyword">static_cast&lt;</span>AstRecordInit*<span class="keyword">&gt;</span>(<a class="code" href="_resolve_aliases_transformer_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a>)-&gt;getArguments();</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                std::vector&lt;AstArgument*&gt; rhsArgs = <span class="keyword">static_cast&lt;</span>AstRecordInit*<span class="keyword">&gt;</span>(<a class="code" href="_resolve_aliases_transformer_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a>)-&gt;getArguments();</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                <span class="keywordflow">if</span> (lhsArgs.size() != rhsArgs.size()) {</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                    <span class="comment">// Records of unequal size can&#39;t be equated</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                }</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;                <span class="comment">// Equate all corresponding arguments</span></div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; lhsArgs.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;                    <a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>.push_back(std::make_pair(lhsArgs[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>], rhsArgs[i]));</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                }</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                <span class="comment">// Get rid of the record equality</span></div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                <a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>.erase(<a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>.begin() + <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>);</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                done = <span class="keyword">false</span>;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((isRecord(lhs) &amp;&amp; isConstant(rhs)) || (isConstant(lhs) &amp;&amp; isRecord(rhs))) {</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                <span class="comment">// A record =/= a constant</span></div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;            }</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        }</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    }</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a7f93cdf21f1a24b593da6691dc892828"><div class="ttname"><a href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">souffle::sub</a></div><div class="ttdeci">std::shared_ptr&lt; Constraint&lt; Var &gt; &gt; sub(const Var &amp;a, const Var &amp;b, const std::string &amp;symbol=&quot;⊑&quot;)</div><div class="ttdoc">A generic factory for constraints of the form. </div><div class="ttdef"><b>Definition:</b> <a href="_constraints_8h_source.html#l00221">Constraints.h:221</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="_resolve_aliases_transformer_8cpp_html_a99d7476d0087a8405f52a79852efa6eb"><div class="ttname"><a href="_resolve_aliases_transformer_8cpp.html#a99d7476d0087a8405f52a79852efa6eb">rhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; rhs</div><div class="ttdef"><b>Definition:</b> <a href="_resolve_aliases_transformer_8cpp_source.html#l00161">ResolveAliasesTransformer.cpp:161</a></div></div>
<div class="ttc" id="_resolve_aliases_transformer_8cpp_html_aae193eebe112e754a082b152fb272018"><div class="ttname"><a href="_resolve_aliases_transformer_8cpp.html#aae193eebe112e754a082b152fb272018">lhs</a></div><div class="ttdeci">std::unique_ptr&lt; AstArgument &gt; lhs</div><div class="ttdef"><b>Definition:</b> <a href="_resolve_aliases_transformer_8cpp_source.html#l00160">ResolveAliasesTransformer.cpp:160</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a659ae2c89cfab47908f27a660f82c147_cgraph.png" border="0" usemap="#namespacesouffle_a659ae2c89cfab47908f27a660f82c147_cgraph" alt=""/></div>
<map name="namespacesouffle_a659ae2c89cfab47908f27a660f82c147_cgraph" id="namespacesouffle_a659ae2c89cfab47908f27a660f82c147_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828" title="A generic factory for constraints of the form. " alt="" coords="249,5,347,32"/>
</map>
</div>

</div>
</div>
<a id="a503032b9def6267059072aea913780bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503032b9def6267059072aea913780bc">&#9670;&nbsp;</a></span>removeRelationClauses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::removeRelationClauses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_qualified_name.html">AstQualifiedName</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the set of clauses with the given relation name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>the program </td></tr>
    <tr><td class="paramname">name</td><td>the name of the relation to search for </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00069">69</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_utils_8cpp_source.html#l00042">getClauses()</a>, and <a class="el" href="_ast_program_8h_source.html#l00112">souffle::AstProgram::removeClause()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>, and <a class="el" href="_ast_program_8h_source.html#l00088">souffle::AstProgram::removeRelation()</a>.</p>
<div class="fragment"><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                                                                              {</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* clause : <a class="code" href="namespacesouffle.html#a4ca5420316b1f3e64bc8f87a26a0c05c">getClauses</a>(program, name)) {</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        program.removeClause(clause);</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    }</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a4ca5420316b1f3e64bc8f87a26a0c05c"><div class="ttname"><a href="namespacesouffle.html#a4ca5420316b1f3e64bc8f87a26a0c05c">souffle::getClauses</a></div><div class="ttdeci">std::vector&lt; AstClause * &gt; getClauses(const AstProgram &amp;program, const AstRelation &amp;rel)</div><div class="ttdoc">Returns a vector of clauses in the program describing the given relation. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00052">AstUtils.cpp:52</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a503032b9def6267059072aea913780bc_cgraph.png" border="0" usemap="#namespacesouffle_a503032b9def6267059072aea913780bc_cgraph" alt=""/></div>
<map name="namespacesouffle_a503032b9def6267059072aea913780bc_cgraph" id="namespacesouffle_a503032b9def6267059072aea913780bc_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="283,13,430,39"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_program.html#a0bde67af569811987d8e21929163d132" title="remove a clause " alt="" coords="281,64,432,105"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="480,5,631,47"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="679,13,825,39"/>
</map>
</div>

</div>
</div>
<a id="af790a6a39a388c256d64af7140f3a961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af790a6a39a388c256d64af7140f3a961">&#9670;&nbsp;</a></span>renameVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::renameVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renames all variables in a given argument uniquely. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00477">477</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_node_8h_source.html#l00078">souffle::AstNode::apply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00504">combineAggregators()</a>.</p>
<div class="fragment"><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;                                       {</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">int</span> varCount = 0;</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    varCount++;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    <span class="keyword">struct </span>M : <span class="keyword">public</span> AstNodeMapper {</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        <span class="keywordtype">int</span> varnum;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;        M(<span class="keywordtype">int</span> varnum) : varnum(varnum) {}</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;        std::unique_ptr&lt;AstNode&gt; operator()(std::unique_ptr&lt;AstNode&gt; node)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">auto</span>* var = dynamic_cast&lt;AstVariable*&gt;(node.get())) {</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;                <span class="keyword">auto</span> newVar = std::unique_ptr&lt;AstVariable&gt;(var-&gt;clone());</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;                std::stringstream newName;</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;                newName &lt;&lt; var-&gt;getName() &lt;&lt; <span class="stringliteral">&quot;-v&quot;</span> &lt;&lt; varnum;</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;                newVar-&gt;setName(newName.str());</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;                <span class="keywordflow">return</span> newVar;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;            }</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;            <span class="keywordflow">return</span> node;</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;        }</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;    };</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;    M update(varCount);</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    arg-&gt;apply(update);</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_af790a6a39a388c256d64af7140f3a961_cgraph.png" border="0" usemap="#namespacesouffle_af790a6a39a388c256d64af7140f3a961_cgraph" alt=""/></div>
<map name="namespacesouffle_af790a6a39a388c256d64af7140f3a961_cgraph" id="namespacesouffle_af790a6a39a388c256d64af7140f3a961_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_node.html#ad7c4f8ce0322749e72ed60f543c6fd93" title="Apply the mapper to all child nodes. " alt="" coords="237,5,411,32"/>
</map>
</div>

</div>
</div>
<a id="a6903b947a2473735a22a16f70664b91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6903b947a2473735a22a16f70664b91b">&#9670;&nbsp;</a></span>reorderAdornment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; souffle::reorderAdornment </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>adornment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00431">431</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="json11_8h_source.html#l00651">i</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;                                                                       {</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    <span class="comment">// order[i] denotes where labels[i] should move</span></div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    <span class="comment">// [a, b, c] with order [1, 2, 0] -&gt; [c, a, b]</span></div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    std::vector&lt;std::string&gt; result(adornment.size());</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; adornment.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;        result[order[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>]] = adornment[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    }</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    <span class="keywordflow">return</span> result;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae77f3374134c13b638bf7644fcebb5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77f3374134c13b638bf7644fcebb5ef">&#9670;&nbsp;</a></span>reorderAtoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> * souffle::reorderAtoms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td>
          <td class="paramname"><em>clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>newOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders the atoms of a clause to be in the given order. </p>
<p>Remaining body literals remain in the same order.</p>
<p>E.g. if atoms are [a,b,c] and given order is [1,2,0], then the final atom order will be [b,c,a].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clause</td><td>clause to reorder atoms in </td></tr>
    <tr><td class="paramname">newOrder</td><td>new order of atoms; atoms[i] = atoms[newOrder[i]] </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ast_utils_8cpp_source.html#l00189">189</a> of file <a class="el" href="_ast_utils_8cpp_source.html">AstUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_clause_8h_source.html#l00151">souffle::AstClause::addToBody()</a>, <a class="el" href="classsouffle_1_1_ast_literal.html#a8e7b7424c40acb87df022913c5928fd8">souffle::AstLiteral::clone()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00179">cloneHead()</a>, <a class="el" href="_ast_clause_8h_source.html#l00171">souffle::AstClause::getBodyLiterals()</a>, and <a class="el" href="json11_8h_source.html#l00651">i</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_utils_8h_source.html#l00068">getBodyLiterals()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00453">souffle::AstTranslator::ClauseTranslator::getReorderedClause()</a>, <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00161">isValidPermutation()</a>, <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00334">reorderClauseWithSips()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                                                                                          {</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    <span class="comment">// Find all atom positions</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    std::vector&lt;unsigned int&gt; atomPositions;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    std::vector&lt;AstLiteral*&gt; bodyLiterals = clause-&gt;getBodyLiterals();</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; bodyLiterals.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        <span class="keywordflow">if</span> (dynamic_cast&lt;AstAtom*&gt;(bodyLiterals[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>]) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;            atomPositions.push_back(i);</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        }</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    }</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="comment">// Validate given order</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    assert(newOrder.size() == atomPositions.size());</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    std::vector&lt;unsigned int&gt; nopOrder;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; atomPositions.size(); i++) {</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        nopOrder.push_back(i);</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    }</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    assert(std::is_permutation(nopOrder.begin(), nopOrder.end(), newOrder.begin()));</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="comment">// Create a new clause with the given atom order, leaving the rest unchanged</span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    AstClause* newClause = <a class="code" href="namespacesouffle.html#a6aa6d61f4a71ddbb2458d23ce24dbced">cloneHead</a>(clause);</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> currentAtom = 0;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> currentLiteral = 0; currentLiteral &lt; bodyLiterals.size(); currentLiteral++) {</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        AstLiteral* literalToAdd = bodyLiterals[currentLiteral];</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        <span class="keywordflow">if</span> (dynamic_cast&lt;AstAtom*&gt;(literalToAdd) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;            <span class="comment">// Atoms should be reordered</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;            literalToAdd = bodyLiterals[atomPositions[newOrder[currentAtom++]]];</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        }</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        newClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(literalToAdd-&gt;clone()));</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    }</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <span class="keywordflow">return</span> newClause;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="namespacesouffle_html_a6aa6d61f4a71ddbb2458d23ce24dbced"><div class="ttname"><a href="namespacesouffle.html#a6aa6d61f4a71ddbb2458d23ce24dbced">souffle::cloneHead</a></div><div class="ttdeci">AstClause * cloneHead(const AstClause *clause)</div><div class="ttdoc">Returns a clause which contains head of the given clause. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00179">AstUtils.cpp:179</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ae77f3374134c13b638bf7644fcebb5ef_cgraph.png" border="0" usemap="#namespacesouffle_ae77f3374134c13b638bf7644fcebb5ef_cgraph" alt=""/></div>
<map name="namespacesouffle_ae77f3374134c13b638bf7644fcebb5ef_cgraph" id="namespacesouffle_ae77f3374134c13b638bf7644fcebb5ef_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_clause.html#ac5e3416082d23734d1277daa5c9dee81" title="Add a Literal to the body of the clause. " alt="" coords="218,42,357,83"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_literal.html#a8e7b7424c40acb87df022913c5928fd8" title="Create a clone (i.e. " alt="" coords="219,107,355,149"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a6aa6d61f4a71ddbb2458d23ce24dbced" title="Returns a clause which contains head of the given clause. " alt="" coords="216,173,359,200"/>
<area shape="rect" id="node12" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="218,286,357,327"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Create a clone (i.e. " alt="" coords="413,5,587,32"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="641,56,841,83"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_execution_plan.html#ac657ffa016ae777656585a56fc9a899c" title="Create a clone (i.e. " alt="" coords="407,107,593,149"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="445,173,555,200"/>
<area shape="rect" id="node10" href="classsouffle_1_1_ast_clause.html#aa943423c45971e70c837da5b88c8fc04" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="429,225,571,266"/>
<area shape="rect" id="node11" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="431,290,569,331"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_atom.html#acef18129b13ce45477044717ded051d2" title="souffle::AstAtom::AstAtom" alt="" coords="644,5,839,32"/>
<area shape="rect" id="node13" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="427,356,573,383"/>
</map>
</div>

</div>
</div>
<a id="afa2cecfcadc16887cd76ccff96466d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2cecfcadc16887cd76ccff96466d19">&#9670;&nbsp;</a></span>reorderClauseWithSips()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a>* souffle::reorderClauseWithSips </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesouffle.html#ad0dcec7b78fdde7450cb55df1fece164">sips_t</a>&#160;</td>
          <td class="paramname"><em>sipsFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_clause.html">AstClause</a> *&#160;</td>
          <td class="paramname"><em>clause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00334">334</a> of file <a class="el" href="_reorder_literals_transformer_8cpp_source.html">ReorderLiteralsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00308">applySips()</a>, <a class="el" href="_ast_clause_8h_source.html#l00176">souffle::AstClause::getExecutionPlan()</a>, <a class="el" href="json11_8h_source.html#l00651">i</a>, and <a class="el" href="_ast_utils_8cpp_source.html#l00189">reorderAtoms()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00355">souffle::ReorderLiteralsTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                                                                         {</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="comment">// ignore clauses with fixed execution plans</span></div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    <span class="keywordflow">if</span> (clause-&gt;getExecutionPlan() != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    }</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="comment">// get the ordering corresponding to the SIPS</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    std::vector&lt;unsigned int&gt; newOrdering = <a class="code" href="namespacesouffle.html#a0654c08409f66fdca60d0cc668de83a5">applySips</a>(sipsFunction, getBodyLiterals&lt;AstAtom&gt;(*clause));</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="comment">// check if we need a change</span></div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <span class="keywordtype">bool</span> changeNeeded = <span class="keyword">false</span>;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; newOrdering.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        <span class="keywordflow">if</span> (newOrdering[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>] != <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>) {</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;            changeNeeded = <span class="keyword">true</span>;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        }</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    }</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    <span class="comment">// reorder if needed</span></div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    <span class="keywordflow">return</span> changeNeeded ? <a class="code" href="namespacesouffle.html#ae77f3374134c13b638bf7644fcebb5ef">reorderAtoms</a>(clause, newOrdering) : nullptr;</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="namespacesouffle_html_a0654c08409f66fdca60d0cc668de83a5"><div class="ttname"><a href="namespacesouffle.html#a0654c08409f66fdca60d0cc668de83a5">souffle::applySips</a></div><div class="ttdeci">std::vector&lt; unsigned int &gt; applySips(sips_t sipsFunction, std::vector&lt; AstAtom *&gt; atoms)</div><div class="ttdoc">Finds the new ordering of a vector of atoms after the given SIPS is applied. </div><div class="ttdef"><b>Definition:</b> <a href="_reorder_literals_transformer_8cpp_source.html#l00308">ReorderLiteralsTransformer.cpp:308</a></div></div>
<div class="ttc" id="namespacesouffle_html_ae77f3374134c13b638bf7644fcebb5ef"><div class="ttname"><a href="namespacesouffle.html#ae77f3374134c13b638bf7644fcebb5ef">souffle::reorderAtoms</a></div><div class="ttdeci">AstClause * reorderAtoms(const AstClause *clause, const std::vector&lt; unsigned int &gt; &amp;newOrder)</div><div class="ttdoc">Reorders the atoms of a clause to be in the given order. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00189">AstUtils.cpp:189</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_afa2cecfcadc16887cd76ccff96466d19_cgraph.png" border="0" usemap="#namespacesouffle_afa2cecfcadc16887cd76ccff96466d19_cgraph" alt=""/></div>
<map name="namespacesouffle_afa2cecfcadc16887cd76ccff96466d19_cgraph" id="namespacesouffle_afa2cecfcadc16887cd76ccff96466d19_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a0654c08409f66fdca60d0cc668de83a5" title="Finds the new ordering of a vector of atoms after the given SIPS is applied. " alt="" coords="289,43,426,69"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_clause.html#aa943423c45971e70c837da5b88c8fc04" title="Obtains the execution plan associated to this clause or null if there is none. " alt="" coords="787,341,930,382"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ae77f3374134c13b638bf7644fcebb5ef" title="Reorders the atoms of a clause to be in the given order. " alt="" coords="276,159,439,185"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="487,5,717,32"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="785,5,932,32"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_clause.html#ac5e3416082d23734d1277daa5c9dee81" title="Add a Literal to the body of the clause. " alt="" coords="533,239,671,281"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_literal.html#a8e7b7424c40acb87df022913c5928fd8" title="Create a clone (i.e. " alt="" coords="534,57,670,98"/>
<area shape="rect" id="node9" href="namespacesouffle.html#a6aa6d61f4a71ddbb2458d23ce24dbced" title="Returns a clause which contains head of the given clause. " alt="" coords="531,188,673,215"/>
<area shape="rect" id="node16" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="533,122,671,163"/>
<area shape="rect" id="node10" href="classsouffle_1_1_ast_atom.html#a274d22e3c57da222d244c26f5937dd8a" title="Create a clone (i.e. " alt="" coords="772,173,945,200"/>
<area shape="rect" id="node12" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="1000,224,1200,251"/>
<area shape="rect" id="node13" href="classsouffle_1_1_ast_execution_plan.html#ac657ffa016ae777656585a56fc9a899c" title="Create a clone (i.e. " alt="" coords="765,275,952,317"/>
<area shape="rect" id="node14" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="804,56,913,83"/>
<area shape="rect" id="node15" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="789,107,928,149"/>
<area shape="rect" id="node11" href="classsouffle_1_1_ast_atom.html#acef18129b13ce45477044717ded051d2" title="souffle::AstAtom::AstAtom" alt="" coords="1003,173,1197,200"/>
</map>
</div>

</div>
</div>
<a id="a6e8e6aa7bd85198221efb412ec7b898c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8e6aa7bd85198221efb412ec7b898c">&#9670;&nbsp;</a></span>reorderOrdering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned int&gt; souffle::reorderOrdering </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00410">410</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="json11_8h_source.html#l00651">i</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;                                                                       {</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    <span class="comment">// when the adornment is computed, the atoms are numbered based on</span></div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    <span class="comment">// which was chosen by the SIPS first - this is the &#39;order&#39; vector.</span></div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    <span class="comment">// want to reorder clause atoms so that the atom labelled 0 is first, and so on.</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    <span class="comment">// i.e. order[i] denotes where labels[i] should move</span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    <span class="comment">// e.g.: [a, b, c] with label [1, 2, 0] should become [c, a, b]</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    <span class="comment">// the atom reordering function for clauses, however, moves it as follows:</span></div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    <span class="comment">// [a, b, c] with label [1, 2, 0] becomes [b, c, a]</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    <span class="comment">// i.e. labels[i] goes to the position of i in the order vector</span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    <span class="comment">// this function reorders the ordering scheme to match the second type</span></div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    std::vector&lt;unsigned int&gt; neworder(order.size());</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; order.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;        <span class="comment">// this took embarrassingly long to figure out</span></div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;        neworder[order[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>]] = <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    }</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="keywordflow">return</span> neworder;</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a877abda5aeabc4122f3bce8d74247919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877abda5aeabc4122f3bce8d74247919">&#9670;&nbsp;</a></span>replaceUnderscores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::replaceUnderscores </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l01017">1017</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_utils_8cpp_source.html#l00042">getClauses()</a>, <a class="el" href="_ast_program_8h_source.html#l00057">souffle::AstProgram::getRelations()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l00057">hasPrefix()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00124">nameInlinedUnderscores()</a>, and <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;                                             {</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;    <span class="keyword">struct </span>M : <span class="keyword">public</span> AstNodeMapper {</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;        std::unique_ptr&lt;AstNode&gt; operator()(std::unique_ptr&lt;AstNode&gt; node)<span class="keyword"> const override </span>{</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">auto</span>* var = dynamic_cast&lt;AstVariable*&gt;(node.get())) {</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198">hasPrefix</a>(var-&gt;getName(), <span class="stringliteral">&quot;+underscore&quot;</span>)) {</div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;                    <span class="keywordflow">return</span> std::make_unique&lt;AstUnnamedVariable&gt;();</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;                }</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;            }</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;            <span class="keywordflow">return</span> node;</div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;        }</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;    };</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;    M update;</div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;    <span class="keywordflow">for</span> (AstRelation* rel : program-&gt;getRelations()) {</div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;        <span class="keywordflow">for</span> (AstClause* clause : <a class="code" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">getClauses</a>(*program, *rel)) {</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;            clause-&gt;apply(update);</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;        }</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;    }</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a4d9e53888640a9abfd7ea7c43715152a"><div class="ttname"><a href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">souffle::getClauses</a></div><div class="ttdeci">std::vector&lt; AstClause * &gt; getClauses(const AstProgram &amp;program, const AstQualifiedName &amp;relationName)</div><div class="ttdoc">Returns a vector of clauses in the program describing the relation with the given name...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00042">AstUtils.cpp:42</a></div></div>
<div class="ttc" id="namespacesouffle_html_ae0c80a38e0b1c4617f373aba8d2c7198"><div class="ttname"><a href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198">souffle::hasPrefix</a></div><div class="ttdeci">bool hasPrefix(const std::string &amp;str, const std::string &amp;prefix)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00057">MagicSet.cpp:57</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a877abda5aeabc4122f3bce8d74247919_cgraph.png" border="0" usemap="#namespacesouffle_a877abda5aeabc4122f3bce8d74247919_cgraph" alt=""/></div>
<map name="namespacesouffle_a877abda5aeabc4122f3bce8d74247919_cgraph" id="namespacesouffle_a877abda5aeabc4122f3bce8d74247919_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="256,19,403,46"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="451,71,601,112"/>
<area shape="rect" id="node6" href="namespacesouffle.html#ae0c80a38e0b1c4617f373aba8d2c7198" title="souffle::hasPrefix" alt="" coords="262,125,397,151"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="451,5,601,47"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="649,46,796,73"/>
</map>
</div>

</div>
</div>
<a id="a0f9046441f0187dc187df0765a55b175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9046441f0187dc187df0765a55b175">&#9670;&nbsp;</a></span>separateDBs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::separateDBs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> *&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_magic_set_8cpp_source.html#l00899">899</a> of file <a class="el" href="_magic_set_8cpp_source.html">MagicSet.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_program_8h_source.html#l00105">souffle::AstProgram::addClause()</a>, <a class="el" href="_ast_program_8h_source.html#l00082">souffle::AstProgram::addRelation()</a>, <a class="el" href="_ast_clause_8h_source.html#l00190">souffle::AstClause::clone()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00211">createNewRelation()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00042">getClauses()</a>, <a class="el" href="_ast_clause_8h_source.html#l00166">souffle::AstClause::getHead()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00196">getNextEdbName()</a>, <a class="el" href="_ast_program_8h_source.html#l00057">souffle::AstProgram::getRelations()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00159">isFact()</a>, <a class="el" href="html_js_chartist_min_8h_source.html#l00015">j</a>, <a class="el" href="_magic_set_8cpp_source.html#l00176">nextSrcLoc()</a>, <a class="el" href="_reader_8h_source.html#l00130">relation</a>, and <a class="el" href="_ast_literal_8h_source.html#l00068">souffle::AstAtom::setQualifiedName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>.</p>
<div class="fragment"><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;                                      {</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;    <span class="keywordflow">for</span> (AstRelation* <a class="code" href="_reader_8h.html#abd6f77243e31b9c48f104efeed27c546">relation</a> : program-&gt;getRelations()) {</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;        AstQualifiedName relName = <a class="code" href="_reader_8h.html#abd6f77243e31b9c48f104efeed27c546">relation</a>-&gt;getQualifiedName();</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;        <span class="comment">// determine whether the relation fits into the EDB, IDB, or both</span></div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;        <span class="keywordtype">bool</span> is_edb = <span class="keyword">false</span>;</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;        <span class="keywordtype">bool</span> is_idb = <span class="keyword">false</span>;</div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;        <span class="keywordflow">for</span> (AstClause* clause : <a class="code" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">getClauses</a>(*program, *<a class="code" href="_reader_8h.html#abd6f77243e31b9c48f104efeed27c546">relation</a>)) {</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#ae4b6e248ec714e64f38ce032caf5f477">isFact</a>(*clause)) {</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;                is_edb = <span class="keyword">true</span>;</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;                is_idb = <span class="keyword">true</span>;</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;            }</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;            <span class="keywordflow">if</span> (is_edb &amp;&amp; is_idb) {</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;            }</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;        }</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;        <span class="keywordflow">if</span> (is_edb &amp;&amp; is_idb) {</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;            <span class="comment">// relation is part of EDB and IDB</span></div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;            <span class="comment">// move all the relation&#39;s facts to a new relation with a unique name</span></div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;            std::string newEdbName = <a class="code" href="namespacesouffle.html#aeb526d569fc848583a59613102f660d3">getNextEdbName</a>(program);</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;            AstRelation* newEdbRel = <a class="code" href="namespacesouffle.html#ac9327b98da5d4ad231903d0bb9205bbc">createNewRelation</a>(<a class="code" href="_reader_8h.html#abd6f77243e31b9c48f104efeed27c546">relation</a>, newEdbName);</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;            program-&gt;addRelation(std::unique_ptr&lt;AstRelation&gt;(newEdbRel));</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;            <span class="comment">// find all facts for the relation</span></div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;            <span class="keywordflow">for</span> (AstClause* clause : <a class="code" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">getClauses</a>(*program, *<a class="code" href="_reader_8h.html#abd6f77243e31b9c48f104efeed27c546">relation</a>)) {</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#ae4b6e248ec714e64f38ce032caf5f477">isFact</a>(*clause)) {</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;                    <span class="comment">// clause is fact - add it to the new EDB relation</span></div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;                    AstClause* newEdbClause = clause-&gt;clone();</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;                    newEdbClause-&gt;getHead()-&gt;setQualifiedName(newEdbName);</div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;                    program-&gt;addClause(std::unique_ptr&lt;AstClause&gt;(newEdbClause));</div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;                }</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;            }</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;</div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;            <span class="comment">// add a rule to the old relation that relates it to the new relation</span></div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;            <span class="keyword">auto</span>* newIdbClause = <span class="keyword">new</span> AstClause();</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;            newIdbClause-&gt;setSrcLoc(<a class="code" href="namespacesouffle.html#a70f903ef77f947a3123c891794322534">nextSrcLoc</a>(<a class="code" href="_reader_8h.html#abd6f77243e31b9c48f104efeed27c546">relation</a>-&gt;getSrcLoc()));</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;            <span class="comment">// oldname(arg1...argn) :- newname(arg1...argn)</span></div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;            <span class="keyword">auto</span>* headAtom = <span class="keyword">new</span> AstAtom(relName);</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;            <span class="keyword">auto</span>* bodyAtom = <span class="keyword">new</span> AstAtom(newEdbName);</div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;</div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;            <span class="keywordtype">size_t</span> numargs = <a class="code" href="_reader_8h.html#abd6f77243e31b9c48f104efeed27c546">relation</a>-&gt;getArity();</div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> = 0; <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a> &lt; numargs; <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>++) {</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;                std::stringstream argName;</div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;                argName.str(<span class="stringliteral">&quot;&quot;</span>);</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;                argName &lt;&lt; <span class="stringliteral">&quot;arg&quot;</span> &lt;&lt; <a class="code" href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a>;</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;                headAtom-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(argName.str()));</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;                bodyAtom-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(argName.str()));</div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;            }</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;</div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;            newIdbClause-&gt;setHead(std::unique_ptr&lt;AstAtom&gt;(headAtom));</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;            newIdbClause-&gt;addToBody(std::unique_ptr&lt;AstAtom&gt;(bodyAtom));</div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;</div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;            program-&gt;addClause(std::unique_ptr&lt;AstClause&gt;(newIdbClause));</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;        }</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;    }</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_ac9327b98da5d4ad231903d0bb9205bbc"><div class="ttname"><a href="namespacesouffle.html#ac9327b98da5d4ad231903d0bb9205bbc">souffle::createNewRelation</a></div><div class="ttdeci">AstRelation * createNewRelation(AstRelation *original, const AstQualifiedName &amp;newName)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00211">MagicSet.cpp:211</a></div></div>
<div class="ttc" id="namespacesouffle_html_ae4b6e248ec714e64f38ce032caf5f477"><div class="ttname"><a href="namespacesouffle.html#ae4b6e248ec714e64f38ce032caf5f477">souffle::isFact</a></div><div class="ttdeci">bool isFact(const AstClause &amp;clause)</div><div class="ttdoc">Returns whether the given clause is a fact. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00159">AstUtils.cpp:159</a></div></div>
<div class="ttc" id="namespacesouffle_html_aeb526d569fc848583a59613102f660d3"><div class="ttname"><a href="namespacesouffle.html#aeb526d569fc848583a59613102f660d3">souffle::getNextEdbName</a></div><div class="ttdeci">std::string getNextEdbName(AstProgram *program)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00196">MagicSet.cpp:196</a></div></div>
<div class="ttc" id="_reader_8h_html_abd6f77243e31b9c48f104efeed27c546"><div class="ttname"><a href="_reader_8h.html#abd6f77243e31b9c48f104efeed27c546">relation</a></div><div class="ttdeci">Relation &amp; relation</div><div class="ttdef"><b>Definition:</b> <a href="_reader_8h_source.html#l00130">Reader.h:130</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_aab858032a95af802114b255fac6f45f2"><div class="ttname"><a href="html_js_chartist_min_8h.html#aab858032a95af802114b255fac6f45f2">j</a></div><div class="ttdeci">var j</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
<div class="ttc" id="namespacesouffle_html_a4d9e53888640a9abfd7ea7c43715152a"><div class="ttname"><a href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a">souffle::getClauses</a></div><div class="ttdeci">std::vector&lt; AstClause * &gt; getClauses(const AstProgram &amp;program, const AstQualifiedName &amp;relationName)</div><div class="ttdoc">Returns a vector of clauses in the program describing the relation with the given name...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_utils_8cpp_source.html#l00042">AstUtils.cpp:42</a></div></div>
<div class="ttc" id="namespacesouffle_html_a70f903ef77f947a3123c891794322534"><div class="ttname"><a href="namespacesouffle.html#a70f903ef77f947a3123c891794322534">souffle::nextSrcLoc</a></div><div class="ttdeci">SrcLocation nextSrcLoc(SrcLocation orig)</div><div class="ttdef"><b>Definition:</b> <a href="_magic_set_8cpp_source.html#l00176">MagicSet.cpp:176</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a0f9046441f0187dc187df0765a55b175_cgraph.png" border="0" usemap="#namespacesouffle_a0f9046441f0187dc187df0765a55b175_cgraph" alt=""/></div>
<map name="namespacesouffle_a0f9046441f0187dc187df0765a55b175_cgraph" id="namespacesouffle_a0f9046441f0187dc187df0765a55b175_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_program.html#a776167026cb9e348e75a9e9caa02ef74" title="add a clause " alt="" coords="263,5,413,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_program.html#ad31c2a7d5d1985b869aa59c41b773fa5" title="souffle::AstProgram\l::addRelation" alt="" coords="263,71,413,112"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_program.html#a71fb3c28c3a105637c22cbe6a9fb63ef" title="get relations " alt="" coords="770,163,921,204"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_clause.html#aef9cb574a067db73c83fd9c9f63d297f" title="Create a clone (i.e. " alt="" coords="269,260,407,301"/>
<area shape="rect" id="node11" href="namespacesouffle.html#ac9327b98da5d4ad231903d0bb9205bbc" title="souffle::createNewRelation" alt="" coords="239,327,437,354"/>
<area shape="rect" id="node14" href="namespacesouffle.html#a70f903ef77f947a3123c891794322534" title="souffle::nextSrcLoc" alt="" coords="541,435,686,462"/>
<area shape="rect" id="node15" href="namespacesouffle.html#a4d9e53888640a9abfd7ea7c43715152a" title="Returns a vector of clauses in the program describing the relation with the given name..." alt="" coords="265,434,411,461"/>
<area shape="rect" id="node17" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="544,537,683,579"/>
<area shape="rect" id="node18" href="namespacesouffle.html#aeb526d569fc848583a59613102f660d3" title="souffle::getNextEdbName" alt="" coords="243,137,433,163"/>
<area shape="rect" id="node19" href="namespacesouffle.html#ae4b6e248ec714e64f38ce032caf5f477" title="Returns whether the given clause is a fact. " alt="" coords="283,545,393,571"/>
<area shape="rect" id="node24" href="classsouffle_1_1_ast_atom.html#afbeb783ad7ad591a9eb7d8c10a64aba7" title="set qualified name " alt="" coords="211,595,465,622"/>
<area shape="rect" id="node4" href="namespacesouffle.html#ada252aa15afbf7d703a11b000dfd4048" title="Returns the relation with the given name in the program. " alt="" coords="539,113,687,139"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a62f80c157a6a365d78a43592732a8efa" title="Returns the first element in a container that satisfies a given predicate, nullptr otherwise..." alt="" coords="793,111,897,138"/>
<area shape="rect" id="node7" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="999,402,1146,429"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_node.html#ae84bf084ceca6ac36dc4be406f42870f" title="Return source location of the AstNode. " alt="" coords="513,267,713,294"/>
<area shape="rect" id="node10" href="namespacesouffle.html#a018886d19f141b1cb565199a517c598f" title="souffle::clone" alt="" coords="559,217,668,243"/>
<area shape="rect" id="node12" href="classsouffle_1_1_ast_relation.html#ae27800d5845e8ac6df95b20bfc51aecf" title="Get relation attributes. " alt="" coords="771,361,919,403"/>
<area shape="rect" id="node13" href="classsouffle_1_1_ast_relation.html#ad2025f014882934287fbf5bf05a9ced7" title="Get relation representation. " alt="" coords="539,369,688,411"/>
<area shape="rect" id="node16" href="classsouffle_1_1_ast_program.html#aa04b430e385f40c6fe2bf7ad2ca31bb3" title="get clauses " alt="" coords="770,453,921,495"/>
<area shape="rect" id="node20" href="classsouffle_1_1_ast_clause.html#a1b5199df425ba5839383a75c5bb8a254" title="Obtains a copy of the internally maintained body literals. " alt="" coords="776,537,915,579"/>
<area shape="rect" id="node21" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="529,654,697,681"/>
<area shape="rect" id="node22" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="761,647,929,688"/>
<area shape="rect" id="node23" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="977,647,1168,688"/>
</map>
</div>

</div>
</div>
<a id="ab31e06999eb72da2f6d9a85bdd3dda59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31e06999eb72da2f6d9a85bdd3dda59">&#9670;&nbsp;</a></span>simpleName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::simpleName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>File name, with extension removed. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01202">1202</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="main_8cpp_source.html#l00124">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;                                                   {</div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;    std::string name = <a class="code" href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4">baseName</a>(path);</div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> lastDot = name.find_last_of(<span class="charliteral">&#39;.&#39;</span>);</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;    <span class="comment">// file has no extension</span></div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;    <span class="keywordflow">if</span> (lastDot == std::string::npos) {</div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;        <span class="keywordflow">return</span> name;</div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;    }</div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> lastSlash = name.find_last_of(<span class="charliteral">&#39;/&#39;</span>);</div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;    <span class="comment">// last slash occurs after last dot, so no extension</span></div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;    <span class="keywordflow">if</span> (lastSlash != std::string::npos &amp;&amp; lastSlash &gt; lastDot) {</div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;        <span class="keywordflow">return</span> name;</div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;    }</div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;    <span class="comment">// last dot after last slash, or no slash</span></div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;    <span class="keywordflow">return</span> name.substr(0, lastDot);</div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a9fbc2262a6164b62766f6fcb67f12ae4"><div class="ttname"><a href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4">souffle::baseName</a></div><div class="ttdeci">std::string baseName(const std::string &amp;filename)</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01182">Util.h:1182</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2925d5d1ec64b003a6b111ed29a2392b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2925d5d1ec64b003a6b111ed29a2392b">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; souffle::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>times</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>utility function to split a string </p>

<p class="definition">Definition at line <a class="el" href="_explain_provenance_8h_source.html#l00130">130</a> of file <a class="el" href="_explain_provenance_8h_source.html">ExplainProvenance.h</a>.</p>

<p class="reference">References <a class="el" href="_tui_8h_source.html#l00319">souffle::profile::ss</a>, and <a class="el" href="_util_8h_source.html#l00868">times()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_b_tree_8h_source.html#l00531">souffle::detail::btree&lt; Key, Comparator, Allocator, blockSize, SearchStrategy, isSet, WeakComparator, Updater &gt;::node::getSplitPoint()</a>, <a class="el" href="_explain_8h_source.html#l00071">souffle::Explain::processCommand()</a>, <a class="el" href="_b_tree_8h_source.html#l00615">souffle::detail::btree&lt; Key, Comparator, Allocator, blockSize, SearchStrategy, isSet, WeakComparator, Updater &gt;::node::rebalance_or_split()</a>, and <a class="el" href="_event_processor_8h_source.html#l00159">souffle::profile::EventProcessorSingleton::splitSignature()</a>.</p>
<div class="fragment"><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                                                                                  {</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    std::vector&lt;std::string&gt; v;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    std::stringstream <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a>(s);</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    std::string item;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    <span class="keywordflow">while</span> ((<a class="code" href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f">times</a> &gt; 0 || <a class="code" href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f">times</a> &lt;= -1) &amp;&amp; std::getline(<a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a>, item, delim)) {</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        v.push_back(item);</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        <a class="code" href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f">times</a>--;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    }</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a>.peek() != EOF) {</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        std::string remainder;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        std::getline(<a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a>, remainder);</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        v.push_back(remainder);</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    }</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="keywordflow">return</span> v;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;}</div><div class="ttc" id="namespacesouffle_1_1profile_html_a6b765acdf677f188e059ac9860c5046d"><div class="ttname"><a href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">souffle::profile::ss</a></div><div class="ttdeci">class souffle::profile::Tui ss</div><div class="ttdef"><b>Definition:</b> <a href="_tui_8h_source.html#l00319">Tui.h:319</a></div></div>
<div class="ttc" id="namespacesouffle_html_a0fff2be077dd5d1105f3a6e718339f2f"><div class="ttname"><a href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f">souffle::times</a></div><div class="ttdeci">detail::multiplying_printer&lt; T &gt; times(const T &amp;value, unsigned num)</div><div class="ttdoc">A utility printing a given value multiple times. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l00868">Util.h:868</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a2925d5d1ec64b003a6b111ed29a2392b_cgraph.png" border="0" usemap="#namespacesouffle_a2925d5d1ec64b003a6b111ed29a2392b_cgraph" alt=""/></div>
<map name="namespacesouffle_a2925d5d1ec64b003a6b111ed29a2392b_cgraph" id="namespacesouffle_a2925d5d1ec64b003a6b111ed29a2392b_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f" title="A utility printing a given value multiple times. " alt="" coords="156,5,267,32"/>
</map>
</div>

</div>
</div>
<a id="a673608e9453179d30f6607384f54463a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673608e9453179d30f6607384f54463a">&#9670;&nbsp;</a></span>splitString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; souffle::splitString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a string given a delimiter. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00908">908</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00370">addIgnoredRelations()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="main_8cpp_source.html#l00098">compileToBinary()</a>, <a class="el" href="main_8cpp_source.html#l00063">executeBinary()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00074">souffle::ExplainProvenanceImpl::explain()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00327">souffle::ExplainProvenanceImpl::explainNegation()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00261">souffle::ExplainProvenanceImpl::explainNegationGetVariables()</a>, <a class="el" href="_interpreter_engine_8cpp_source.html#l00096">souffle::InterpreterEngine::loadDLL()</a>, and <a class="el" href="main_8cpp_source.html#l00124">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;                                                                              {</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;    std::vector&lt;std::string&gt; parts;</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;    std::stringstream strstr(<a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>);</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;    std::string token;</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;    <span class="keywordflow">while</span> (std::getline(strstr, token, delimiter)) {</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;        parts.push_back(token);</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;    }</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;    <span class="keywordflow">return</span> parts;</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;}</div><div class="ttc" id="json11_8h_html_a25fda444d34d64acade61be6f9d35367"><div class="ttname"><a href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a></div><div class="ttdeci">const std::string &amp; str</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00650">json11.h:650</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a06f428910159c119c1dcdcab76ab7dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f428910159c119c1dcdcab76ab7dfa">&#9670;&nbsp;</a></span>stringify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::stringify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stringify a string using escapes for newline, tab, double-quotes and semicolons. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01260">1260</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ram_statement_8h_source.html#l00650">souffle::RamLogRelationTimer::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00695">souffle::RamLogTimer::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00731">souffle::RamDebugInfo::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00757">souffle::RamLogSize::print()</a>, <a class="el" href="_explain_tree_8h_source.html#l00172">souffle::InnerNode::printJSON()</a>, <a class="el" href="_explain_tree_8h_source.html#l00218">souffle::LeafNode::printJSON()</a>, <a class="el" href="_explain_provenance_impl_8h_source.html#l00598">souffle::ExplainProvenanceImpl::printRulesJSON()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00704">souffle::AstTranslator::ClauseTranslator::translateClause()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00960">souffle::AstTranslator::translateNonRecursiveRelation()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l01061">souffle::AstTranslator::translateRecursiveRelation()</a>.</p>
<div class="fragment"><div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;                                                   {</div><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;    std::string <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>(input);</div><div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;</div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;    <span class="comment">// replace semicolons returns by escape sequence</span></div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;    <span class="keywordtype">size_t</span> start_pos = 0;</div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;    <span class="keywordflow">while</span> ((start_pos = <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>.find(<span class="charliteral">&#39;;&#39;</span>, start_pos)) != std::string::npos) {</div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;        <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>.replace(start_pos, 1, <span class="stringliteral">&quot;\\;&quot;</span>);</div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;        start_pos += 2;</div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;    }</div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;    <span class="comment">// replace double-quotes returns by escape sequence</span></div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;    start_pos = 0;</div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;    <span class="keywordflow">while</span> ((start_pos = <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>.find(<span class="charliteral">&#39;&quot;&#39;</span>, start_pos)) != std::string::npos) {</div><div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;        <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>.replace(start_pos, 1, <span class="stringliteral">&quot;\\\&quot;&quot;</span>);</div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;        start_pos += 2;</div><div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;    }</div><div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;    <span class="comment">// replace newline returns by escape sequence</span></div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;    start_pos = 0;</div><div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;    <span class="keywordflow">while</span> ((start_pos = <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>.find(<span class="charliteral">&#39;\n&#39;</span>, start_pos)) != std::string::npos) {</div><div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;        <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>.replace(start_pos, 1, <span class="stringliteral">&quot;\\n&quot;</span>);</div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;        start_pos += 2;</div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;    }</div><div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;    <span class="comment">// replace tab returns by escape sequence</span></div><div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;    start_pos = 0;</div><div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;    <span class="keywordflow">while</span> ((start_pos = <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>.find(<span class="charliteral">&#39;\t&#39;</span>, start_pos)) != std::string::npos) {</div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;        <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>.replace(start_pos, 1, <span class="stringliteral">&quot;\\t&quot;</span>);</div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;        start_pos += 2;</div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;    }</div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>;</div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;}</div><div class="ttc" id="json11_8h_html_a25fda444d34d64acade61be6f9d35367"><div class="ttname"><a href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a></div><div class="ttdeci">const std::string &amp; str</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00650">json11.h:650</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7f93cdf21f1a24b593da6691dc892828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f93cdf21f1a24b593da6691dc892828">&#9670;&nbsp;</a></span>sub() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Var &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classsouffle_1_1_constraint.html">Constraint</a>&lt;Var&gt; &gt; souffle::sub </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em> = <code>&quot;⊑&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic factory for constraints of the form. </p>
<p>a ⊑ b</p>
<p>where a and b are variables and ⊑ is the order relation induced by their associated property space. </p>

<p class="definition">Definition at line <a class="el" href="_constraints_8h_source.html#l00221">221</a> of file <a class="el" href="_constraints_8h_source.html">Constraints.h</a>.</p>

<p class="reference">References <a class="el" href="html_js_chartist_min_8h_source.html#l00015">b</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ram_program_8h_source.html#l00118">souffle::RamProgram::apply()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00769">souffle::AstSemanticChecker::checkUnionType()</a>, <a class="el" href="_ram_program_8h_source.html#l00095">souffle::RamProgram::clone()</a>, <a class="el" href="_synthesiser_8cpp_source.html#l01730">souffle::Synthesiser::generateCode()</a>, <a class="el" href="_ram_program_8h_source.html#l00059">souffle::RamProgram::getChildNodes()</a>, <a class="el" href="_ram_program_8h_source.html#l00082">souffle::RamProgram::getSubroutines()</a>, <a class="el" href="_brie_8h_source.html#l02155">souffle::detail::fix_lower_bound&lt; Pos, Dim &gt;::operator()()</a>, <a class="el" href="_brie_8h_source.html#l02218">souffle::detail::fix_upper_bound&lt; Pos, Dim &gt;::operator()()</a>, <a class="el" href="_ram_program_8h_source.html#l00129">souffle::RamProgram::print()</a>, <a class="el" href="_ram_program_8h_source.html#l00047">souffle::RamProgram::RamProgram()</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00193">reduceSubstitution()</a>.</p>
<div class="fragment"><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                                                                                                {</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="keyword">struct </span>Sub : <span class="keyword">public</span> Constraint&lt;Var&gt; {</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        Var a, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;        std::string symbol;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        Sub(Var a, Var b, std::string symbol) : a(<a class="code" href="namespacestd.html">std</a>::move(a)), b(<a class="code" href="namespacestd.html">std</a>::move(b)), symbol(<a class="code" href="namespacestd.html">std</a>::move(symbol)) {}</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        <span class="keywordtype">bool</span> update(Assignment&lt;Var&gt;&amp; ass)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;            <span class="keyword">typename</span> Var::property_space::meet_assign_op_type meet_assign;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;            <span class="keywordflow">return</span> meet_assign(ass[b], ass[a]);</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        }</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <span class="keywordtype">void</span> print(std::ostream&amp; out)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            out &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; symbol &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        }</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    };</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    <span class="keywordflow">return</span> std::make_shared&lt;Sub&gt;(a, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, symbol);</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;}</div><div class="ttc" id="namespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition:</b> <a href="_compiled_tuple_8h_source.html#l00169">CompiledTuple.h:169</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a688bb15c1b54c1fb493463f09857778b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688bb15c1b54c1fb493463f09857778b">&#9670;&nbsp;</a></span>sub() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Var , typename Val  = typename Var::property_space::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classsouffle_1_1_constraint.html">Constraint</a>&lt;Var&gt; &gt; souffle::sub </td>
          <td>(</td>
          <td class="paramtype">const Val &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em> = <code>&quot;⊑&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic factory for constraints of the form. </p>
<p>a ⊑ b</p>
<p>where b is a variables, a is a value of b's property space, and ⊑ is the order relation induced by b's property space. </p>

<p class="definition">Definition at line <a class="el" href="_constraints_8h_source.html#l00250">250</a> of file <a class="el" href="_constraints_8h_source.html">Constraints.h</a>.</p>

<p class="reference">References <a class="el" href="html_js_chartist_min_8h_source.html#l00015">b</a>.</p>
<div class="fragment"><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                                                                                                {</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    <span class="keyword">struct </span>Sub : <span class="keyword">public</span> Constraint&lt;Var&gt; {</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        Val a;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        Var <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        std::string symbol;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;        Sub(Val a, Var b, std::string symbol) : a(<a class="code" href="namespacestd.html">std</a>::move(a)), b(<a class="code" href="namespacestd.html">std</a>::move(b)), symbol(<a class="code" href="namespacestd.html">std</a>::move(symbol)) {}</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        <span class="keywordtype">bool</span> update(Assignment&lt;Var&gt;&amp; ass)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            <span class="keyword">typename</span> Var::property_space::meet_assign_op_type meet_assign;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            <span class="keywordflow">return</span> meet_assign(ass[b], a);</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        }</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        <span class="keywordtype">void</span> print(std::ostream&amp; out)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            out &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; symbol &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        }</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    };</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    <span class="keywordflow">return</span> std::make_shared&lt;Sub&gt;(a, <a class="code" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, symbol);</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;}</div><div class="ttc" id="namespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition:</b> <a href="_compiled_tuple_8h_source.html#l00169">CompiledTuple.h:169</a></div></div>
<div class="ttc" id="html_js_chartist_min_8h_html_a4cb409b8fe88d81ab7faab0d1bbb878d"><div class="ttname"><a href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter b</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2122cfa5acdee4846ecda0855f0beee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2122cfa5acdee4846ecda0855f0beee4">&#9670;&nbsp;</a></span>tempFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::tempFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate temporary file. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01240">1240</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="main_8cpp_source.html#l00124">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;                            {</div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;<span class="preprocessor">#ifdef _WIN32</span></div><div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;    std::string templ;</div><div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;    std::FILE* f = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;    <span class="keywordflow">while</span> (f == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;        templ = std::tmpnam(<span class="keyword">nullptr</span>);</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;        f = fopen(templ.c_str(), <span class="stringliteral">&quot;wx&quot;</span>);</div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;    }</div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;    fclose(f);</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;    <span class="keywordflow">return</span> templ;</div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;    <span class="keywordtype">char</span> templ[40] = <span class="stringliteral">&quot;./souffleXXXXXX&quot;</span>;</div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;    close(mkstemp(templ));</div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;    <span class="keywordflow">return</span> std::string(templ);</div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a0fff2be077dd5d1105f3a6e718339f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fff2be077dd5d1105f3a6e718339f2f">&#9670;&nbsp;</a></span>times()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsouffle_1_1detail_1_1multiplying__printer.html">detail::multiplying_printer</a>&lt;T&gt; souffle::times </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility printing a given value multiple times. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00868">868</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_brie_8h_source.html#l01202">souffle::SparseArray&lt; value_t, BITS, merge_op &gt;::dump()</a>, <a class="el" href="_ram_statement_8h_source.html#l00119">souffle::RamIO::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00158">souffle::RamClear::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00227">souffle::RamScan::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00252">souffle::RamExtend::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00259">souffle::RamParallelScan::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00281">souffle::RamSwap::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00326">souffle::RamQuery::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00367">souffle::RamIndexScan::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00408">souffle::RamParallelIndexScan::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00455">souffle::RamParallel::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00493">souffle::RamChoice::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00501">souffle::RamLoop::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00534">souffle::RamParallelChoice::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00552">souffle::RamExit::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00597">souffle::RamIndexChoice::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00646">souffle::RamParallelIndexChoice::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00650">souffle::RamLogRelationTimer::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00695">souffle::RamLogTimer::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00731">souffle::RamDebugInfo::print()</a>, <a class="el" href="_ram_statement_8h_source.html#l00757">souffle::RamLogSize::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00783">souffle::RamAggregate::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00839">souffle::RamIndexAggregate::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l00982">souffle::RamFilter::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l01014">souffle::RamBreak::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l01079">souffle::RamProject::print()</a>, <a class="el" href="_ram_operation_8h_source.html#l01144">souffle::RamSubroutineReturnValue::print()</a>, and <a class="el" href="_explain_provenance_8h_source.html#l00130">split()</a>.</p>
<div class="fragment"><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;                                                                 {</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;    <span class="keywordflow">return</span> detail::multiplying_printer&lt;T&gt;(value, num);</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a399105b8de1698758c5b18bc9efca9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399105b8de1698758c5b18bc9efca9fa">&#9670;&nbsp;</a></span>toBinaryConstraintOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a> souffle::toBinaryConstraintOp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts symbolic representation of an operator to the operator. </p>
<p>Note that this won't tell you which polymorphic overload is actually used. </p>

<p class="definition">Definition at line <a class="el" href="_binary_constraint_ops_8h_source.html#l00257">257</a> of file <a class="el" href="_binary_constraint_ops_8h_source.html">BinaryConstraintOps.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b">CONTAINS</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">GE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">GT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">LE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">LT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a">MATCH</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">NE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0">NOT_CONTAINS</a>, and <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01">NOT_MATCH</a>.</p>

<p class="reference">Referenced by <a class="el" href="_explain_provenance_impl_8h_source.html#l00074">souffle::ExplainProvenanceImpl::explain()</a>.</p>
<div class="fragment"><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                                                                        {</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;=&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::EQ;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;!=&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::NE;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;&lt;&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::LT;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;&lt;=&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::LE;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;&gt;=&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::GE;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;&gt;&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::GT;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;match&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::MATCH;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;contains&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::CONTAINS;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;not_match&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::NOT_MATCH;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    <span class="keywordflow">if</span> (symbol == <span class="stringliteral">&quot;not_contains&quot;</span>) <span class="keywordflow">return</span> BinaryConstraintOp::NOT_CONTAINS;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Unrecognised operator: &quot;</span> &lt;&lt; symbol &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported Operator!&quot;</span>);</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    exit(EXIT_FAILURE);</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aa91ed26d703343c35171d6803a9c5d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91ed26d703343c35171d6803a9c5d0b">&#9670;&nbsp;</a></span>toBinaryConstraintSymbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::toBinaryConstraintSymbol </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49">BinaryConstraintOp</a>&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts operator to its symbolic representation. </p>

<p class="definition">Definition at line <a class="el" href="_binary_constraint_ops_8h_source.html#l00212">212</a> of file <a class="el" href="_binary_constraint_ops_8h_source.html">BinaryConstraintOps.h</a>.</p>

<p class="reference">References <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7c8b81e077a45b6d2c9c03d3a22c0d5b">CONTAINS</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2dcbad7477fd40561e8b8198f173bd47">EQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa123e958001611b441dab45ff11ba98a">FEQ</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa1d7888b08b54d43aeadc58136fa0907">FGE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49aa302b6b103aca34c46209564002a8252">FGT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a56267eaefed8c4c5255779a597a72363">FLE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a1cc288bb3360b602513d8ffe37a874f9">FLT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a90dc357130ab3c37ef770e959ab49b9c">FNE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49af803729628adf4199f224c2a225038e9">GE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acd6a9bd2a175104eed40f0d33a8b4020">GT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49acfe6055d2e0503be378bb63449ec7ba6">LE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac562607189d77eb9dfb707464c1e7b0b">LT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a6ac3227c311790fb4c3ebbe16920f93a">MATCH</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49adc33066c3993e0d50896e533fd692ce0">NE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a4b7ded10a1737fedce4949a0c54b13a0">NOT_CONTAINS</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a3850ecd82d5cc81641ac02f11449ea01">NOT_MATCH</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49add25db0709d4c7c05b057f311208f753">SGE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a53acb49d0534e8912fec8569e845400f">SGT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a0a1d07df9a43688c7128eefbe3d41b08">SLE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ac71563c4ae48cc1bbd2e7913366cdf7e">SLT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ada0d6078de3703b5680eb9361f2d68fd">UGE</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a7efc25ec6c881b13261c1a6d88762483">UGT</a>, <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49ae29e365fd3b5e59c86218486a0c1c7c1">ULE</a>, and <a class="el" href="namespacesouffle.html#ac460f7c8b5ab0da53316d6bb32a19f49a2b4652512a6c88f5a39c3288081b6e13">ULT</a>.</p>

<p class="reference">Referenced by <a class="el" href="_provenance_transformer_8cpp_source.html#l00065">makeInfoRelation()</a>, <a class="el" href="_ram_condition_8h_source.html#l00240">souffle::RamConstraint::print()</a>, and <a class="el" href="_ast_literal_8h_source.html#l00275">souffle::AstBinaryConstraint::print()</a>.</p>
<div class="fragment"><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                                                                       {</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="keywordflow">switch</span> (op) {</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FEQ:</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::EQ:</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;=&quot;</span>;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FNE:</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NE:</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;!=&quot;</span>;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::SLT:</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::ULT:</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FLT:</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::LT:</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;&lt;&quot;</span>;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::SLE:</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::ULE:</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FLE:</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::LE:</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;&lt;=&quot;</span>;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::SGT:</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::UGT:</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FGT:</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::GT:</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;&gt;&quot;</span>;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::SGE:</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::UGE:</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::FGE:</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::GE:</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;&gt;=&quot;</span>;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::MATCH:</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;match&quot;</span>;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::CONTAINS:</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;contains&quot;</span>;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NOT_MATCH:</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;not_match&quot;</span>;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        <span class="keywordflow">case</span> BinaryConstraintOp::NOT_CONTAINS:</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;            <span class="keywordflow">return</span> <span class="stringliteral">&quot;not_contains&quot;</span>;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    }</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unsupported Operator!&quot;</span>);</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    exit(EXIT_FAILURE);</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a9b80cb84e709bb5d93968317ec2fdbe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b80cb84e709bb5d93968317ec2fdbe1">&#9670;&nbsp;</a></span>toCondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsouffle_1_1_ram_condition.html">RamCondition</a>&gt; souffle::toCondition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ram_condition.html">RamCondition</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>conds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert list of conditions to a conjunction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>list of RAM conditions </td></tr>
    <tr><td class="paramname">A</td><td>RAM condition</td></tr>
  </table>
  </dd>
</dl>
<p>Convert a list {C1, C2, ..., Cn} to a condition of the format C1 /\ C2 /\ ... /\ Cn. </p>

<p class="definition">Definition at line <a class="el" href="_ram_utils_8h_source.html#l00071">71</a> of file <a class="el" href="_ram_utils_8h_source.html">RamUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ram_transforms_8cpp_source.html#l00105">souffle::CollapseFiltersTransformer::collapseFilters()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00141">souffle::EliminateDuplicatesTransformer::eliminateDuplicates()</a>, <a class="el" href="_synthesiser_8cpp_source.html#l00172">souffle::Synthesiser::emitCode()</a>, and <a class="el" href="_ram_transforms_8cpp_source.html#l00070">souffle::ReorderConditionsTransformer::reorderConditions()</a>.</p>
<div class="fragment"><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                                                                                                    {</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    std::unique_ptr&lt;RamCondition&gt; result;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; cur : conds) {</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        <span class="keywordflow">if</span> (result == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            result = std::unique_ptr&lt;RamCondition&gt;(cur-&gt;clone());</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            result = std::make_unique&lt;RamConjunction&gt;(</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                    std::move(result), std::unique_ptr&lt;RamCondition&gt;(cur-&gt;clone()));</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        }</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    }</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keywordflow">return</span> result;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aeea6de3eaf7c83bc19097c74d3fb6693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea6de3eaf7c83bc19097c74d3fb6693">&#9670;&nbsp;</a></span>toConjunctionList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unique_ptr&lt;<a class="el" href="classsouffle_1_1_ram_condition.html">RamCondition</a>&gt; &gt; souffle::toConjunctionList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ram_condition.html">RamCondition</a> *&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert terms of a conjunction to a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conds</td><td>A RAM condition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of RAM conditions</dd></dl>
<p>Convert a condition of the format C1 /\ C2 /\ ... /\ Cn to a list {C1, C2, ..., Cn}. </p>

<p class="definition">Definition at line <a class="el" href="_ram_utils_8h_source.html#l00044">44</a> of file <a class="el" href="_ram_utils_8h_source.html">RamUtils.h</a>.</p>

<p class="reference">References <a class="el" href="classsouffle_1_1_ram_condition.html#a54f67f8136251030e958232ae1aa051a">souffle::RamCondition::clone()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ram_transforms_8cpp_source.html#l00141">souffle::EliminateDuplicatesTransformer::eliminateDuplicates()</a>, <a class="el" href="_synthesiser_8cpp_source.html#l00172">souffle::Synthesiser::emitCode()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00037">souffle::ExpandFilterTransformer::expandFilters()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00070">souffle::ReorderConditionsTransformer::reorderConditions()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00316">souffle::MakeIndexTransformer::rewriteAggregate()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00355">souffle::MakeIndexTransformer::rewriteIndexScan()</a>, and <a class="el" href="_ram_transforms_8cpp_source.html#l00335">souffle::MakeIndexTransformer::rewriteScan()</a>.</p>
<div class="fragment"><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;                                                                                               {</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    std::vector&lt;std::unique_ptr&lt;RamCondition&gt;&gt; conditionList;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    std::queue&lt;const RamCondition*&gt; conditionsToProcess;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="keywordflow">if</span> (condition != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        conditionsToProcess.push(condition);</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        <span class="keywordflow">while</span> (!conditionsToProcess.empty()) {</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;            condition = conditionsToProcess.front();</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;            conditionsToProcess.pop();</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;            <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* ramConj = dynamic_cast&lt;const RamConjunction*&gt;(condition)) {</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                conditionsToProcess.push(&amp;ramConj-&gt;getLHS());</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;                conditionsToProcess.push(&amp;ramConj-&gt;getRHS());</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                conditionList.emplace_back(condition-&gt;clone());</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            }</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        }</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    }</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="keywordflow">return</span> conditionList;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aeea6de3eaf7c83bc19097c74d3fb6693_cgraph.png" border="0" usemap="#namespacesouffle_aeea6de3eaf7c83bc19097c74d3fb6693_cgraph" alt=""/></div>
<map name="namespacesouffle_aeea6de3eaf7c83bc19097c74d3fb6693_cgraph" id="namespacesouffle_aeea6de3eaf7c83bc19097c74d3fb6693_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ram_condition.html#a54f67f8136251030e958232ae1aa051a" title="Create a clone (i.e. " alt="" coords="240,5,407,47"/>
</map>
</div>

</div>
</div>
<a id="ad62d4e824a9d74c7462da546a21780fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62d4e824a9d74c7462da546a21780fe">&#9670;&nbsp;</a></span>toPtrVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T*&gt; souffle::toPtrVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function enabling the creation of a vector of pointers. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00363">363</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="html_js_chartist_min_8h_source.html#l00015">e</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ram_expression_8h_source.html#l00058">souffle::RamAbstractOperator::getArguments()</a>, <a class="el" href="_ast_literal_8h_source.html#l00078">souffle::AstAtom::getArguments()</a>, <a class="el" href="_ast_argument_8h_source.html#l00221">souffle::AstTerm::getArguments()</a>, <a class="el" href="_ram_expression_8h_source.html#l00400">souffle::RamPackRecord::getArguments()</a>, <a class="el" href="_ast_relation_8h_source.html#l00073">souffle::AstRelation::getAttributes()</a>, <a class="el" href="_ast_component_8h_source.html#l00168">souffle::AstComponent::getBaseComponents()</a>, <a class="el" href="_ast_clause_8h_source.html#l00171">souffle::AstClause::getBodyLiterals()</a>, <a class="el" href="_ast_argument_8h_source.html#l00505">souffle::AstAggregator::getBodyLiterals()</a>, <a class="el" href="_ast_program_8h_source.html#l00062">souffle::AstProgram::getClauses()</a>, <a class="el" href="_ast_component_8h_source.html#l00211">souffle::AstComponent::getClauses()</a>, <a class="el" href="_ast_program_8h_source.html#l00128">souffle::AstProgram::getComponentInstantiations()</a>, <a class="el" href="_ast_program_8h_source.html#l00123">souffle::AstProgram::getComponents()</a>, <a class="el" href="_ast_component_8h_source.html#l00231">souffle::AstComponent::getComponents()</a>, <a class="el" href="_ast_program_8h_source.html#l00067">souffle::AstProgram::getFunctorDeclarations()</a>, <a class="el" href="_ast_component_8h_source.html#l00241">souffle::AstComponent::getInstantiations()</a>, <a class="el" href="_ast_program_8h_source.html#l00072">souffle::AstProgram::getIOs()</a>, <a class="el" href="_ast_component_8h_source.html#l00221">souffle::AstComponent::getIOs()</a>, <a class="el" href="_ram_operation_8h_source.html#l00288">souffle::RamIndexOperation::getRangePattern()</a>, <a class="el" href="_ast_program_8h_source.html#l00057">souffle::AstProgram::getRelations()</a>, <a class="el" href="_ram_program_8h_source.html#l00077">souffle::RamProgram::getRelations()</a>, <a class="el" href="_ast_component_8h_source.html#l00201">souffle::AstComponent::getRelations()</a>, <a class="el" href="_ram_statement_8h_source.html#l00360">souffle::RamListStatement::getStatements()</a>, <a class="el" href="_ast_program_8h_source.html#l00052">souffle::AstProgram::getTypes()</a>, <a class="el" href="_ast_component_8h_source.html#l00183">souffle::AstComponent::getTypes()</a>, <a class="el" href="_ram_condition_8h_source.html#l00286">souffle::RamAbstractExistenceCheck::getValues()</a>, <a class="el" href="_ram_operation_8h_source.html#l01049">souffle::RamProject::getValues()</a>, and <a class="el" href="_ram_operation_8h_source.html#l01117">souffle::RamSubroutineReturnValue::getValues()</a>.</p>
<div class="fragment"><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;                                                                {</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;    std::vector&lt;T*&gt; res;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="html_js_chartist_min_8h.html#af6814cb38d86f56d30772f562eaee28e">e</a> : v) {</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;        res.push_back(<a class="code" href="html_js_chartist_min_8h.html#af6814cb38d86f56d30772f562eaee28e">e</a>.get());</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    }</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    <span class="keywordflow">return</span> res;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;}</div><div class="ttc" id="html_js_chartist_min_8h_html_af6814cb38d86f56d30772f562eaee28e"><div class="ttname"><a href="html_js_chartist_min_8h.html#af6814cb38d86f56d30772f562eaee28e">e</a></div><div class="ttdeci">l j a showGridBackground &amp;&amp;c b raw series this eventEmitter e</div><div class="ttdef"><b>Definition:</b> <a href="html_js_chartist_min_8h_source.html#l00015">htmlJsChartistMin.h:15</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aecc08c83ad9634fc515b7aa094702949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc08c83ad9634fc515b7aa094702949">&#9670;&nbsp;</a></span>toString() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; souffle::toString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A generic function converting strings into strings (trivial case). </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00793">793</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">References <a class="el" href="json11_8h_source.html#l00650">str</a>.</p>

<p class="reference">Referenced by <a class="el" href="_parser_driver_8cpp_source.html#l00098">souffle::ParserDriver::addFunctorDeclaration()</a>, <a class="el" href="_parser_driver_8cpp_source.html#l00122">souffle::ParserDriver::addIO()</a>, <a class="el" href="_parser_driver_8cpp_source.html#l00110">souffle::ParserDriver::addRelation()</a>, <a class="el" href="_parser_driver_8cpp_source.html#l00139">souffle::ParserDriver::addType()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00382">souffle::AstSemanticChecker::checkAtom()</a>, <a class="el" href="_ast_component_checker_8cpp_source.html#l00193">souffle::AstComponentChecker::checkComponentNamespaces()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l01219">souffle::AstSemanticChecker::checkInlining()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00972">souffle::AstSemanticChecker::checkIO()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l01425">souffle::AstSemanticChecker::checkNamespaces()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00789">souffle::AstSemanticChecker::checkRecordType()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00823">souffle::AstSemanticChecker::checkRecursiveUnionTypes()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00726">souffle::AstSemanticChecker::checkRelation()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00699">souffle::AstSemanticChecker::checkRelationDeclaration()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00769">souffle::AstSemanticChecker::checkUnionType()</a>, <a class="el" href="_synthesiser_8cpp_source.html#l00172">souffle::Synthesiser::emitCode()</a>, <a class="el" href="_tui_8h_source.html#l00532">genJsonAtoms()</a>, <a class="el" href="_tui_8h_source.html#l00252">souffle::profile::Tui::genJsonRelations()</a>, <a class="el" href="_tui_8h_source.html#l00322">genJsonRules()</a>, <a class="el" href="_component_lookup_analysis_8cpp_source.html#l00041">souffle::ComponentLookup::getComponent()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00182">souffle::AstTranslator::getOutputDirectives()</a>, <a class="el" href="_ast_translator_8h_source.html#l00297">souffle::AstTranslator::getRelationName()</a>, <a class="el" href="_type_system_8cpp_source.html#l00253">getTypeQualifier()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00224">souffle::MaterializeAggregationQueriesTransformer::materializeAggregationQueries()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l01031">souffle::AstTranslator::nameUnnamedVariables()</a>, <a class="el" href="_resolve_aliases_transformer_8cpp_source.html#l00360">souffle::ResolveAliasesTransformer::removeComplexTermsInAtoms()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00192">souffle::UniqueAggregationVariablesTransformer::transform()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00704">souffle::AstTranslator::ClauseTranslator::translateClause()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00960">souffle::AstTranslator::translateNonRecursiveRelation()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l01518">souffle::AstTranslator::translateProgram()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l01061">souffle::AstTranslator::translateRecursiveRelation()</a>.</p>
<div class="fragment"><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;                                                       {</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>;</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;}</div><div class="ttc" id="json11_8h_html_a25fda444d34d64acade61be6f9d35367"><div class="ttname"><a href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a></div><div class="ttdeci">const std::string &amp; str</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00650">json11.h:650</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aac0f01b6b803d03b90d7f33df9351ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0f01b6b803d03b90d7f33df9351ade">&#9670;&nbsp;</a></span>toString() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structsouffle_1_1detail_1_1is__printable.html">detail::is_printable</a>&lt;T&gt;::value, std::string&gt;::type souffle::toString </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic function converting arbitrary objects to strings by utilizing their print capability. </p>
<p>This function is mainly intended for implementing test cases and debugging operations. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00824">824</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;                                                                                          {</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;    <span class="comment">// write value into stream and return result</span></div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;    std::stringstream <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a>;</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;    ss &lt;&lt; value;</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;    <span class="keywordflow">return</span> ss.str();</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;}</div><div class="ttc" id="namespacesouffle_1_1profile_html_a6b765acdf677f188e059ac9860c5046d"><div class="ttname"><a href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">souffle::profile::ss</a></div><div class="ttdeci">class souffle::profile::Tui ss</div><div class="ttdef"><b>Definition:</b> <a href="_tui_8h_source.html#l00319">Tui.h:319</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afde2b7fb9746dae19cf74319c353aa52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde2b7fb9746dae19cf74319c353aa52">&#9670;&nbsp;</a></span>toString() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structsouffle_1_1detail_1_1is__printable.html">detail::is_printable</a>&lt;T&gt;::value, std::string&gt;::type souffle::toString </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A fallback for the to-string function in case an unprintable object is supposed to be printed. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00836">836</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;                                                                                     {</div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;    std::stringstream <a class="code" href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">ss</a>;</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;    ss &lt;&lt; <span class="stringliteral">&quot;(print for type &quot;</span>;</div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;    ss &lt;&lt; <span class="keyword">typeid</span>(T).name();</div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;    ss &lt;&lt; <span class="stringliteral">&quot; not supported)&quot;</span>;</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;    <span class="keywordflow">return</span> ss.str();</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;}</div><div class="ttc" id="namespacesouffle_1_1profile_html_a6b765acdf677f188e059ac9860c5046d"><div class="ttname"><a href="namespacesouffle_1_1profile.html#a6b765acdf677f188e059ac9860c5046d">souffle::profile::ss</a></div><div class="ttdeci">class souffle::profile::Tui ss</div><div class="ttdef"><b>Definition:</b> <a href="_tui_8h_source.html#l00319">Tui.h:319</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab2822ded4e7fd1466479b3fd6a1345a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2822ded4e7fd1466479b3fd6a1345a0">&#9670;&nbsp;</a></span>toVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; souffle::toVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function enabling the creation of a vector with a fixed set of elements within a single expression. </p>
<p>This is the base case covering empty vectors. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00345">345</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                        {</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    <span class="keywordflow">return</span> std::vector&lt;T&gt;();</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ae771492463067508eb07c2113550097e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae771492463067508eb07c2113550097e">&#9670;&nbsp;</a></span>toVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; souffle::toVector </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function enabling the creation of a vector with a fixed set of elements within a single expression. </p>
<p>This is the step case covering vectors of arbitrary length. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l00355">355</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                                                        {</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="keywordflow">return</span> {first, rest...};</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a2e1142a31f92b96107d9603e86b13bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1142a31f92b96107d9603e86b13bdb">&#9670;&nbsp;</a></span>transformEqrelRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void souffle::transformEqrelRelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_program.html">AstProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_relation.html">AstRelation</a> &amp;&#160;</td>
          <td class="paramname"><em>rel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform eqrel relations to explicitly define equivalence relations. </p>

<p class="definition">Definition at line <a class="el" href="_provenance_transformer_8cpp_source.html#l00191">191</a> of file <a class="el" href="_provenance_transformer_8cpp_source.html">ProvenanceTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_literal_8h_source.html#l00073">souffle::AstAtom::addArgument()</a>, <a class="el" href="_ast_program_8h_source.html#l00105">souffle::AstProgram::addClause()</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa26daa90bc6e4e7baf2b5781caef22940">BTREE</a>, <a class="el" href="namespacesouffle.html#a8d04bccb8804e1ace183494574e4529fa06a35dca93aeafc1b0f548410517223a">EQREL</a>, <a class="el" href="_ast_relation_8h_source.html#l00068">souffle::AstRelation::getArity()</a>, <a class="el" href="_ast_relation_8h_source.html#l00052">souffle::AstRelation::getQualifiedName()</a>, <a class="el" href="_ast_relation_8h_source.html#l00093">souffle::AstRelation::getRepresentation()</a>, and <a class="el" href="_ast_relation_8h_source.html#l00098">souffle::AstRelation::setRepresentation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_provenance_transformer_8cpp_source.html#l00387">souffle::ProvenanceTransformer::transformMaxHeight()</a>, and <a class="el" href="_provenance_transformer_8cpp_source.html#l00249">souffle::ProvenanceTransformer::transformSubtreeHeights()</a>.</p>
<div class="fragment"><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                                                                   {</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    assert(rel.getRepresentation() == RelationRepresentation::EQREL &amp;&amp;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            <span class="stringliteral">&quot;attempting to transform non-eqrel relation&quot;</span>);</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    assert(rel.getArity() == 2 &amp;&amp; <span class="stringliteral">&quot;eqrel relation not binary&quot;</span>);</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    rel.setRepresentation(RelationRepresentation::BTREE);</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="comment">// transitivity</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="comment">// transitive clause: A(x, z) :- A(x, y), A(y, z).</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="keyword">auto</span> transitiveClause = <span class="keyword">new</span> AstClause();</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    <span class="keyword">auto</span> transitiveClauseHead = <span class="keyword">new</span> AstAtom(rel.getQualifiedName());</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    transitiveClauseHead-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    transitiveClauseHead-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;z&quot;</span>));</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <span class="keyword">auto</span> transitiveClauseBody = <span class="keyword">new</span> AstAtom(rel.getQualifiedName());</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    transitiveClauseBody-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    transitiveClauseBody-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;y&quot;</span>));</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="keyword">auto</span> transitiveClauseBody2 = <span class="keyword">new</span> AstAtom(rel.getQualifiedName());</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    transitiveClauseBody2-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;y&quot;</span>));</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    transitiveClauseBody2-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;z&quot;</span>));</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    transitiveClause-&gt;setHead(std::unique_ptr&lt;AstAtom&gt;(transitiveClauseHead));</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    transitiveClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(transitiveClauseBody));</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    transitiveClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(transitiveClauseBody2));</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    program.addClause(std::unique_ptr&lt;AstClause&gt;(transitiveClause));</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    <span class="comment">// symmetric</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <span class="comment">// symmetric clause: A(x, y) :- A(y, x).</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    <span class="keyword">auto</span> symClause = <span class="keyword">new</span> AstClause();</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    <span class="keyword">auto</span> symClauseHead = <span class="keyword">new</span> AstAtom(rel.getQualifiedName());</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    symClauseHead-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    symClauseHead-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;y&quot;</span>));</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    <span class="keyword">auto</span> symClauseBody = <span class="keyword">new</span> AstAtom(rel.getQualifiedName());</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    symClauseBody-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;y&quot;</span>));</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    symClauseBody-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    symClause-&gt;setHead(std::unique_ptr&lt;AstAtom&gt;(symClauseHead));</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    symClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(symClauseBody));</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    program.addClause(std::unique_ptr&lt;AstClause&gt;(symClause));</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    <span class="comment">// reflexivity</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    <span class="comment">// reflexive clause: A(x, x) :- A(x, _).</span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <span class="keyword">auto</span> reflexiveClause = <span class="keyword">new</span> AstClause();</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    <span class="keyword">auto</span> reflexiveClauseHead = <span class="keyword">new</span> AstAtom(rel.getQualifiedName());</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    reflexiveClauseHead-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    reflexiveClauseHead-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="keyword">auto</span> reflexiveClauseBody = <span class="keyword">new</span> AstAtom(rel.getQualifiedName());</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    reflexiveClauseBody-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<span class="stringliteral">&quot;x&quot;</span>));</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    reflexiveClauseBody-&gt;addArgument(std::make_unique&lt;AstUnnamedVariable&gt;());</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    reflexiveClause-&gt;setHead(std::unique_ptr&lt;AstAtom&gt;(reflexiveClauseHead));</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    reflexiveClause-&gt;addToBody(std::unique_ptr&lt;AstLiteral&gt;(reflexiveClauseBody));</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    program.addClause(std::unique_ptr&lt;AstClause&gt;(reflexiveClause));</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a2e1142a31f92b96107d9603e86b13bdb_cgraph.png" border="0" usemap="#namespacesouffle_a2e1142a31f92b96107d9603e86b13bdb_cgraph" alt=""/></div>
<map name="namespacesouffle_a2e1142a31f92b96107d9603e86b13bdb_cgraph" id="namespacesouffle_a2e1142a31f92b96107d9603e86b13bdb_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a0c2e151bc853490e6210c33c8fd127be" title="add argument to the atom " alt="" coords="277,5,504,32"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_program.html#a776167026cb9e348e75a9e9caa02ef74" title="add a clause " alt="" coords="315,57,466,98"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_relation.html#a54bd8f26d113f3141d49e926a030b52d" title="Return the arity of this relation. " alt="" coords="317,122,465,163"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_relation.html#a5db8b505969c2f75286a54875c4aaed1" title="get qualified relation name " alt="" coords="317,187,465,229"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_relation.html#ad2025f014882934287fbf5bf05a9ced7" title="Get relation representation. " alt="" coords="316,253,465,294"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_relation.html#a74fee05e2281fd21dac19a2df839af21" title="Set relation representation. " alt="" coords="317,318,465,359"/>
</map>
</div>

</div>
</div>
<a id="a6b370fe6877c2777646f7fad4aad0cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b370fe6877c2777646f7fad4aad0cb2">&#9670;&nbsp;</a></span>unescape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::unescape </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>inputString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01318">1318</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_translator_8cpp_source.html#l00149">souffle::AstTranslator::getInputDirectives()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l00182">souffle::AstTranslator::getOutputDirectives()</a>.</p>
<div class="fragment"><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;                                                                                             {</div><div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;    std::string result = inputString;</div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;    <span class="keywordtype">size_t</span> pos = 0;</div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;    <span class="keywordflow">while</span> ((pos = result.find(needle, pos)) != std::string::npos) {</div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;        result = result.replace(pos, needle.length(), replacement);</div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;        pos += replacement.length();</div><div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;    }</div><div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;    <span class="keywordflow">return</span> result;</div><div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a20932ae365326d8c0d9bd06f6ea09781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20932ae365326d8c0d9bd06f6ea09781">&#9670;&nbsp;</a></span>unescape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::unescape </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>inputString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01329">1329</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;                                                        {</div><div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;    std::string unescaped = <a class="code" href="namespacesouffle.html#a20932ae365326d8c0d9bd06f6ea09781">unescape</a>(inputString, <span class="stringliteral">&quot;\\\&quot;&quot;</span>, <span class="stringliteral">&quot;\&quot;&quot;</span>);</div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;    unescaped = <a class="code" href="namespacesouffle.html#a20932ae365326d8c0d9bd06f6ea09781">unescape</a>(unescaped, <span class="stringliteral">&quot;\\t&quot;</span>, <span class="stringliteral">&quot;\t&quot;</span>);</div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;    unescaped = <a class="code" href="namespacesouffle.html#a20932ae365326d8c0d9bd06f6ea09781">unescape</a>(unescaped, <span class="stringliteral">&quot;\\r&quot;</span>, <span class="stringliteral">&quot;\r&quot;</span>);</div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;    unescaped = <a class="code" href="namespacesouffle.html#a20932ae365326d8c0d9bd06f6ea09781">unescape</a>(unescaped, <span class="stringliteral">&quot;\\n&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;    <span class="keywordflow">return</span> unescaped;</div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a20932ae365326d8c0d9bd06f6ea09781"><div class="ttname"><a href="namespacesouffle.html#a20932ae365326d8c0d9bd06f6ea09781">souffle::unescape</a></div><div class="ttdeci">std::string unescape(const std::string &amp;inputString)</div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01329">Util.h:1329</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab66c00257a9f4ce44653d82cee9c563d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66c00257a9f4ce44653d82cee9c563d">&#9670;&nbsp;</a></span>unifyAtoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsouffle_1_1_nullable_vector.html">NullableVector</a>&lt;std::pair&lt;<a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a>*, <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a>*&gt; &gt; souffle::unifyAtoms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsouffle_1_1_ast_atom.html">AstAtom</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nullable vector of substitutions needed to unify the two given atoms. </p>
<p>If unification is not successful, the returned vector is marked as invalid. Assumes that the atoms are both of the same relation. </p>

<p class="definition">Definition at line <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00255">255</a> of file <a class="el" href="_inline_relations_transformer_8cpp_source.html">InlineRelationsTransformer.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_literal_8h_source.html#l00078">souffle::AstAtom::getArguments()</a>, <a class="el" href="json11_8h_source.html#l00651">i</a>, and <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00193">reduceSubstitution()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00281">inlineBodyLiterals()</a>.</p>
<div class="fragment"><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                                                                                                {</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    std::vector&lt;std::pair&lt;AstArgument*, AstArgument*&gt;&gt; substitution;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    std::vector&lt;AstArgument*&gt; firstArgs = first-&gt;getArguments();</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    std::vector&lt;AstArgument*&gt; secondArgs = second-&gt;getArguments();</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    <span class="comment">// Create the initial unification equalities</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; firstArgs.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        substitution.push_back(std::make_pair(firstArgs[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>], secondArgs[i]));</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    }</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    <span class="comment">// Reduce the substitutions</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    <span class="keywordtype">bool</span> success = <a class="code" href="namespacesouffle.html#a659ae2c89cfab47908f27a660f82c147">reduceSubstitution</a>(substitution);</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    <span class="keywordflow">if</span> (success) {</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;std::pair&lt;AstArgument*, AstArgument*&gt;&gt;(substitution);</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;        <span class="comment">// Failed to unify the two atoms</span></div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        <span class="keywordflow">return</span> NullableVector&lt;std::pair&lt;AstArgument*, AstArgument*&gt;&gt;();</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    }</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;}</div><div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="namespacesouffle_html_a659ae2c89cfab47908f27a660f82c147"><div class="ttname"><a href="namespacesouffle.html#a659ae2c89cfab47908f27a660f82c147">souffle::reduceSubstitution</a></div><div class="ttdeci">bool reduceSubstitution(std::vector&lt; std::pair&lt; AstArgument *, AstArgument *&gt;&gt; &amp;sub)</div><div class="ttdoc">Reduces a vector of substitutions. </div><div class="ttdef"><b>Definition:</b> <a href="_inline_relations_transformer_8cpp_source.html#l00193">InlineRelationsTransformer.cpp:193</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_ab66c00257a9f4ce44653d82cee9c563d_cgraph.png" border="0" usemap="#namespacesouffle_ab66c00257a9f4ce44653d82cee9c563d_cgraph" alt=""/></div>
<map name="namespacesouffle_ab66c00257a9f4ce44653d82cee9c563d_cgraph" id="namespacesouffle_ab66c00257a9f4ce44653d82cee9c563d_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="203,5,433,32"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a659ae2c89cfab47908f27a660f82c147" title="Reduces a vector of substitutions. " alt="" coords="220,56,416,83"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="481,5,628,32"/>
<area shape="rect" id="node5" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828" title="A generic factory for constraints of the form. " alt="" coords="506,56,603,83"/>
</map>
</div>

</div>
</div>
<a id="aaf760ad1f1324f47eaf903e0c3ea18d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf760ad1f1324f47eaf903e0c3ea18d9">&#9670;&nbsp;</a></span>usesInvalidWitness()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::vector&lt;<a class="el" href="classsouffle_1_1_src_location.html">SrcLocation</a>&gt; souffle::usesInvalidWitness </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsouffle_1_1_ast_literal.html">AstLiteral</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>literals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::unique_ptr&lt; <a class="el" href="classsouffle_1_1_ast_argument.html">AstArgument</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>groundedArguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00985">985</a> of file <a class="el" href="_ast_semantic_checker_8cpp_source.html">AstSemanticChecker.cpp</a>.</p>

<p class="reference">References <a class="el" href="_ast_argument_8h_source.html#l00505">souffle::AstAggregator::getBodyLiterals()</a>, <a class="el" href="_ast_ground_analysis_8cpp_source.html#l00148">getGroundedTerms()</a>, <a class="el" href="json11_8h_source.html#l00651">i</a>, <a class="el" href="json11_8h_source.html#l00650">str</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_semantic_checker_8cpp_source.html#l01109">souffle::AstSemanticChecker::checkWitnessProblem()</a>.</p>
<div class="fragment"><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;                                                                     {</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;    <span class="comment">// Node-mapper that replaces aggregators with new (unique) variables</span></div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;    <span class="keyword">struct </span>M : <span class="keyword">public</span> AstNodeMapper {</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;        <span class="comment">// Variables introduced to replace aggregators</span></div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;        <span class="keyword">mutable</span> std::set&lt;std::string&gt; aggregatorVariables;</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;        <span class="keyword">const</span> std::set&lt;std::string&gt;&amp; getAggregatorVariables() {</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;            <span class="keywordflow">return</span> aggregatorVariables;</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;        }</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;        std::unique_ptr&lt;AstNode&gt; operator()(std::unique_ptr&lt;AstNode&gt; node)<span class="keyword"> const override </span>{</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">int</span> numReplaced = 0;</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;            <span class="keywordflow">if</span> (dynamic_cast&lt;AstAggregator*&gt;(node.get()) != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;                <span class="comment">// Replace the aggregator with a variable</span></div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;                std::stringstream newVariableName;</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;                newVariableName &lt;&lt; <span class="stringliteral">&quot;+aggr_var_&quot;</span> &lt;&lt; numReplaced++;</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;                <span class="comment">// Keep track of which variables are bound to aggregators</span></div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;                aggregatorVariables.insert(newVariableName.str());</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;                <span class="keywordflow">return</span> std::make_unique&lt;AstVariable&gt;(newVariableName.str());</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;            }</div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;            node-&gt;apply(*<span class="keyword">this</span>);</div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;            <span class="keywordflow">return</span> node;</div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;        }</div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;    };</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;    std::vector&lt;SrcLocation&gt; result;</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;    <span class="comment">// Create two versions of the original clause</span></div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;    <span class="comment">// Clause 1 - will remain equivalent to the original clause in terms of variable groundedness</span></div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;    <span class="keyword">auto</span> originalClause = std::make_unique&lt;AstClause&gt;();</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;    originalClause-&gt;setHead(std::make_unique&lt;AstAtom&gt;(<span class="stringliteral">&quot;*&quot;</span>));</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;    <span class="comment">// Clause 2 - will have aggregators replaced with intrinsically grounded variables</span></div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;    <span class="keyword">auto</span> aggregatorlessClause = std::make_unique&lt;AstClause&gt;();</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;    aggregatorlessClause-&gt;setHead(std::make_unique&lt;AstAtom&gt;(<span class="stringliteral">&quot;*&quot;</span>));</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;    <span class="comment">// Construct both clauses in the same manner to match the original clause</span></div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;    <span class="comment">// Must keep track of the subnode in Clause 1 that each subnode in Clause 2 matches to</span></div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;    std::map&lt;const AstArgument*, const AstArgument*&gt; identicalSubnodeMap;</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> AstLiteral* lit : literals) {</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;        <span class="keyword">auto</span> firstClone = std::unique_ptr&lt;AstLiteral&gt;(lit-&gt;clone());</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;        <span class="keyword">auto</span> secondClone = std::unique_ptr&lt;AstLiteral&gt;(lit-&gt;clone());</div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;</div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;        <span class="comment">// Construct the mapping between equivalent literal subnodes</span></div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;        std::vector&lt;const AstArgument*&gt; firstCloneArguments;</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;        <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(*firstClone, [&amp;](<span class="keyword">const</span> AstArgument&amp; arg) { firstCloneArguments.push_back(&amp;arg); });</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;        std::vector&lt;const AstArgument*&gt; secondCloneArguments;</div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;        <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(*secondClone, [&amp;](<span class="keyword">const</span> AstArgument&amp; arg) { secondCloneArguments.push_back(&amp;arg); });</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> = 0; <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a> &lt; firstCloneArguments.size(); <a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>++) {</div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;            identicalSubnodeMap[secondCloneArguments[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>]] = firstCloneArguments[<a class="code" href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a>];</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;        }</div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;        <span class="comment">// Actually add the literal clones to each clause</span></div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;        originalClause-&gt;addToBody(std::move(firstClone));</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;        aggregatorlessClause-&gt;addToBody(std::move(secondClone));</div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;    }</div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;</div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;    <span class="comment">// Replace the aggregators in Clause 2 with variables</span></div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;    M update;</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;    aggregatorlessClause-&gt;apply(update);</div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;</div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;    <span class="comment">// Create a dummy atom to force certain arguments to be grounded in the aggregatorlessClause</span></div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;    <span class="keyword">auto</span> groundingAtomAggregatorless = std::make_unique&lt;AstAtom&gt;(<span class="stringliteral">&quot;grounding_atom&quot;</span>);</div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;    <span class="keyword">auto</span> groundingAtomOriginal = std::make_unique&lt;AstAtom&gt;(<span class="stringliteral">&quot;grounding_atom&quot;</span>);</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;    <span class="comment">// Force the new aggregator variables to be grounded in the aggregatorless clause</span></div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;    <span class="keyword">const</span> std::set&lt;std::string&gt;&amp; aggregatorVariables = update.getAggregatorVariables();</div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::string&amp; <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a> : aggregatorVariables) {</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;        groundingAtomAggregatorless-&gt;addArgument(std::make_unique&lt;AstVariable&gt;(<a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a>));</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;    }</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;    <span class="comment">// Force the given grounded arguments to be grounded in both clauses</span></div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::unique_ptr&lt;AstArgument&gt;&amp; arg : groundedArguments) {</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;        groundingAtomAggregatorless-&gt;addArgument(std::unique_ptr&lt;AstArgument&gt;(arg-&gt;clone()));</div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;        groundingAtomOriginal-&gt;addArgument(std::unique_ptr&lt;AstArgument&gt;(arg-&gt;clone()));</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;    }</div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;</div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;    aggregatorlessClause-&gt;addToBody(std::move(groundingAtomAggregatorless));</div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;    originalClause-&gt;addToBody(std::move(groundingAtomOriginal));</div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;</div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;    <span class="comment">// Compare the grounded analysis of both generated clauses</span></div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;    <span class="comment">// All added arguments in Clause 2 were forced to be grounded, so if an ungrounded argument</span></div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;    <span class="comment">// appears in Clause 2, it must also appear in Clause 1. Consequently, have two cases:</span></div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;    <span class="comment">//   - The argument is also ungrounded in Clause 1 - handled by another check</span></div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;    <span class="comment">//   - The argument is grounded in Clause 1 =&gt; the argument was grounded in the</span></div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;    <span class="comment">//     first clause somewhere along the line by an aggregator-body - not allowed!</span></div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;    std::set&lt;std::unique_ptr&lt;AstArgument&gt;&gt; newlyGroundedArguments;</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;    std::map&lt;const AstArgument*, bool&gt; originalGrounded = <a class="code" href="namespacesouffle.html#a247fd46943465169ffe79f25628e5dad">getGroundedTerms</a>(*originalClause);</div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;    std::map&lt;const AstArgument*, bool&gt; aggregatorlessGrounded = <a class="code" href="namespacesouffle.html#a247fd46943465169ffe79f25628e5dad">getGroundedTerms</a>(*aggregatorlessClause);</div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> pair : aggregatorlessGrounded) {</div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;        <span class="keywordflow">if</span> (!pair.second &amp;&amp; originalGrounded[identicalSubnodeMap[pair.first]]) {</div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;            result.push_back(pair.first-&gt;getSrcLoc());</div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;        }</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;</div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;        <span class="comment">// Otherwise, it can now be considered grounded</span></div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;        newlyGroundedArguments.insert(std::unique_ptr&lt;AstArgument&gt;(pair.first-&gt;clone()));</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;    }</div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;</div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;    <span class="comment">// All previously grounded are still grounded</span></div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::unique_ptr&lt;AstArgument&gt;&amp; arg : groundedArguments) {</div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;        newlyGroundedArguments.insert(std::unique_ptr&lt;AstArgument&gt;(arg-&gt;clone()));</div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;    }</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;</div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;    <span class="comment">// Everything on this level is fine, check subaggregators of each literal</span></div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> AstLiteral* lit : literals) {</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;        <a class="code" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">visitDepthFirst</a>(*lit, [&amp;](<span class="keyword">const</span> AstAggregator&amp; aggr) {</div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;            <span class="comment">// Check recursively if an invalid witness is used</span></div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;            std::vector&lt;AstLiteral*&gt; aggrBodyLiterals = aggr.getBodyLiterals();</div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;            std::vector&lt;SrcLocation&gt; subresult = <a class="code" href="namespacesouffle.html#aaf760ad1f1324f47eaf903e0c3ea18d9">usesInvalidWitness</a>(aggrBodyLiterals, newlyGroundedArguments);</div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;            <span class="keywordflow">for</span> (SrcLocation argloc : subresult) {</div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;                result.push_back(argloc);</div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;            }</div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;        });</div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;    }</div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;    <span class="keywordflow">return</span> result;</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a247fd46943465169ffe79f25628e5dad"><div class="ttname"><a href="namespacesouffle.html#a247fd46943465169ffe79f25628e5dad">souffle::getGroundedTerms</a></div><div class="ttdeci">std::map&lt; const AstArgument *, bool &gt; getGroundedTerms(const AstClause &amp;clause)</div><div class="ttdoc">Analyse the given clause and computes for each contained argument whether it is a grounded value or n...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_ground_analysis_8cpp_source.html#l00148">AstGroundAnalysis.cpp:148</a></div></div>
<div class="ttc" id="namespacesouffle_html_a307bae61c898715dccb57c9732335000"><div class="ttname"><a href="namespacesouffle.html#a307bae61c898715dccb57c9732335000">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00233">AstVisitor.h:233</a></div></div>
<div class="ttc" id="json11_8h_html_ae46bd26d7133dfe98f8cec7c5ac5c7a1"><div class="ttname"><a href="json11_8h.html#ae46bd26d7133dfe98f8cec7c5ac5c7a1">i</a></div><div class="ttdeci">size_t i</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00651">json11.h:651</a></div></div>
<div class="ttc" id="json11_8h_html_a25fda444d34d64acade61be6f9d35367"><div class="ttname"><a href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a></div><div class="ttdeci">const std::string &amp; str</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00650">json11.h:650</a></div></div>
<div class="ttc" id="namespacesouffle_html_aaf760ad1f1324f47eaf903e0c3ea18d9"><div class="ttname"><a href="namespacesouffle.html#aaf760ad1f1324f47eaf903e0c3ea18d9">souffle::usesInvalidWitness</a></div><div class="ttdeci">static const std::vector&lt; SrcLocation &gt; usesInvalidWitness(const std::vector&lt; AstLiteral *&gt; &amp;literals, const std::set&lt; std::unique_ptr&lt; AstArgument &gt;&gt; &amp;groundedArguments)</div><div class="ttdef"><b>Definition:</b> <a href="_ast_semantic_checker_8cpp_source.html#l00985">AstSemanticChecker.cpp:985</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aaf760ad1f1324f47eaf903e0c3ea18d9_cgraph.png" border="0" usemap="#namespacesouffle_aaf760ad1f1324f47eaf903e0c3ea18d9_cgraph" alt=""/></div>
<map name="namespacesouffle_aaf760ad1f1324f47eaf903e0c3ea18d9_cgraph" id="namespacesouffle_aaf760ad1f1324f47eaf903e0c3ea18d9_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_aggregator.html#a52adcf6071c53f92114ac3f45307ca18" title="Get body literals. " alt="" coords="269,91,435,133"/>
<area shape="rect" id="node4" href="namespacesouffle.html#a247fd46943465169ffe79f25628e5dad" title="Analyse the given clause and computes for each contained argument whether it is a grounded value or n..." alt="" coords="253,273,451,300"/>
<area shape="rect" id="node14" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="268,455,436,481"/>
<area shape="rect" id="node3" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe" title="A utility function enabling the creation of a vector of pointers. " alt="" coords="799,33,946,60"/>
<area shape="rect" id="node5" href="classsouffle_1_1_ast_atom.html#a9c726c597d7921245dd97dcc72b8aeed" title="get arguments " alt="" coords="499,33,729,60"/>
<area shape="rect" id="node6" href="classsouffle_1_1_ast_term.html#a5bf9145afa6b327c21e3393123c292c3" title="get arguments " alt="" coords="501,84,727,111"/>
<area shape="rect" id="node7" href="classsouffle_1_1_ast_negation.html#a587c8d4fdcfc28f128cc3ff2cf97895c" title="get negated atom " alt="" coords="537,135,691,177"/>
<area shape="rect" id="node8" href="classsouffle_1_1_ast_clause.html#a5a29a4f9ba5d0e4aea869cf71a6efbbf" title="Return the atom that represents the head of the clause. " alt="" coords="545,201,683,242"/>
<area shape="rect" id="node9" href="classsouffle_1_1_ast_binary_constraint.html#a72b9e10473e1748d720bbf68a3e7f471" title="get LHS argument " alt="" coords="512,266,716,307"/>
<area shape="rect" id="node10" href="classsouffle_1_1_ast_binary_constraint.html#aec8d30b8684b3a2f5f715204999776a0" title="get binary operator " alt="" coords="512,331,716,373"/>
<area shape="rect" id="node11" href="classsouffle_1_1_ast_binary_constraint.html#a61055c91c04bcbe4d03873044c6bf4b8" title="get RHS argument " alt="" coords="512,397,716,438"/>
<area shape="rect" id="node12" href="classsouffle_1_1_ast_type_cast.html#a4fe729dc92cd0e38102249123acbc317" title="Get value. " alt="" coords="537,462,691,503"/>
<area shape="rect" id="node13" href="namespacesouffle.html#a6befeedfd76433e1bd51a1f6cd42afec" title="souffle::isEqConstraint" alt="" coords="530,528,698,555"/>
<area shape="rect" id="node15" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="530,579,698,621"/>
<area shape="rect" id="node16" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="777,579,968,621"/>
</map>
</div>

</div>
</div>
<a id="a307bae61c898715dccb57c9732335000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307bae61c898715dccb57c9732335000">&#9670;&nbsp;</a></span>visitDepthFirst() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Ps, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsouffle_1_1_ast_visitor.html">AstVisitor</a>&lt; R, Ps... &gt; &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first pre-order fashion applying the given visitor to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be visited </td></tr>
    <tr><td class="paramname">visitor</td><td>the visitor to be applied on each node </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00233">233</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p class="reference">References <a class="el" href="_ast_visitor_8h_source.html#l00195">visitDepthFirstPreOrder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_magic_set_8cpp_source.html#l00285">addAggregators()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00297">addBackwardDependencies()</a>, <a class="el" href="_magic_set_8h_source.html#l00148">souffle::BindingStore::addBinding()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00337">addForwardDependencies()</a>, <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00249">areBijectivelyEquivalent()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00509">souffle::AstSemanticChecker::checkAggregator()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00629">souffle::AstSemanticChecker::checkClause()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l01219">souffle::AstSemanticChecker::checkInlining()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00064">souffle::AstSemanticChecker::checkProgram()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00823">souffle::AstSemanticChecker::checkRecursiveUnionTypes()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l01109">souffle::AstSemanticChecker::checkWitnessProblem()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00105">souffle::CollapseFiltersTransformer::collapseFilters()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00164">containsAggregators()</a>, <a class="el" href="_inline_relations_transformer_8cpp_source.html#l00176">containsInlinedAtom()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l01447">souffle::FoldAnonymousRecords::containsValidRecordConstraint()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00493">souffle::IfConversionTransformer::convertIndexScans()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00587">souffle::ChoiceConversionTransformer::convertScans()</a>, <a class="el" href="_ast_type_analysis_8cpp_source.html#l00416">createAnnotatedClause()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l00575">souffle::AstTranslator::ClauseTranslator::createOperation()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00141">souffle::EliminateDuplicatesTransformer::eliminateDuplicates()</a>, <a class="el" href="_synthesiser_8cpp_source.html#l00172">souffle::Synthesiser::emitCode()</a>, <a class="el" href="_interpreter_engine_8cpp_source.html#l00151">souffle::InterpreterEngine::executeMain()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00037">souffle::ExpandFilterTransformer::expandFilters()</a>, <a class="el" href="_interpreter_generator_8h_source.html#l00568">souffle::NodeGenerator::findAllViews()</a>, <a class="el" href="_synthesiser_8cpp_source.html#l01730">souffle::Synthesiser::generateCode()</a>, <a class="el" href="_interpreter_generator_8h_source.html#l00048">souffle::NodeGenerator::generateTree()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00083">getBodyRelations()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00035">getRecords()</a>, <a class="el" href="_synthesiser_8cpp_source.html#l00154">souffle::Synthesiser::getReferencedRelations()</a>, <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00079">getSipsFunction()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00028">getVariables()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00129">hasClauseWithAggregatedRelation()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00647">souffle::HoistAggregateTransformer::hoistAggregate()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00173">souffle::HoistConditionsTransformer::hoistConditions()</a>, <a class="el" href="_interpreter_prog_interface_8h_source.html#l00193">souffle::InterpreterProgInterface::InterpreterProgInterface()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00484">souffle::AstSemanticChecker::isDependent()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00159">isFact()</a>, <a class="el" href="_ast_utils_8cpp_source.html#l00148">isRecursiveClause()</a>, <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00161">isValidPermutation()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00399">souffle::MakeIndexTransformer::makeIndex()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l01352">souffle::AstTranslator::makeNegationSubproofSubroutine()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00224">souffle::MaterializeAggregationQueriesTransformer::materializeAggregationQueries()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00378">souffle::MaterializeAggregationQueriesTransformer::needsMaterializedRelation()</a>, <a class="el" href="_reorder_literals_transformer_8cpp_source.html#l00049">numBoundArguments()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00730">souffle::ParallelTransformer::parallelizeOperations()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00406">souffle::RemoveEmptyRelationsTransformer::removeEmptyRelations()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00435">souffle::RemoveEmptyRelationsTransformer::removeEmptyRelationUses()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00079">souffle::RemoveRelationCopiesTransformer::removeRelationCopies()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00070">souffle::ReorderConditionsTransformer::reorderConditions()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00430">souffle::ReorderFilterBreak::reorderFilterBreak()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00613">souffle::TupleIdTransformer::reorderOperations()</a>, <a class="el" href="_resolve_aliases_transformer_8cpp_source.html#l00202">souffle::ResolveAliasesTransformer::resolveAliases()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00455">souffle::IfConversionTransformer::rewriteIndexScan()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00545">souffle::ChoiceConversionTransformer::rewriteIndexScan()</a>, <a class="el" href="_ram_transforms_8cpp_source.html#l00512">souffle::ChoiceConversionTransformer::rewriteScan()</a>, <a class="el" href="_ast_i_o_type_analysis_8cpp_source.html#l00025">souffle::IOType::run()</a>, <a class="el" href="_component_lookup_analysis_8cpp_source.html#l00026">souffle::ComponentLookup::run()</a>, <a class="el" href="_precedence_graph_8cpp_source.html#l00219">souffle::RecursiveClauses::run()</a>, <a class="el" href="_magic_set_8cpp_source.html#l00695">souffle::Adornment::run()</a>, <a class="el" href="_ram_index_analysis_8cpp_source.html#l00229">souffle::RamIndexAnalysis::run()</a>, <a class="el" href="_ast_pragma_checker_8cpp_source.html#l00026">souffle::AstPragmaChecker::transform()</a>, <a class="el" href="_resolve_aliases_transformer_8cpp_source.html#l00437">souffle::ResolveAliasesTransformer::transform()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00192">souffle::UniqueAggregationVariablesTransformer::transform()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00516">souffle::RemoveBooleanConstraintsTransformer::transform()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00627">souffle::PartitionBodyLiteralsTransformer::transform()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00822">souffle::ReduceExistentialsTransformer::transform()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00973">souffle::ReplaceSingletonVariablesTransformer::transform()</a>, <a class="el" href="_magic_set_8cpp_source.html#l01050">souffle::MagicSetTransformer::transform()</a>, <a class="el" href="_ast_translator_8cpp_source.html#l01518">souffle::AstTranslator::translateProgram()</a>, <a class="el" href="_ast_semantic_checker_8cpp_source.html#l00985">usesInvalidWitness()</a>, <a class="el" href="_ast_visitor_8h_source.html#l00303">visitDepthFirst()</a>, and <a class="el" href="_interpreter_generator_8h_source.html#l00406">souffle::NodeGenerator::visitQuery()</a>.</p>
<div class="fragment"><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;                                                                                        {</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    <a class="code" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6">visitDepthFirstPreOrder</a>(root, visitor, args...);</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a030c754119d60ea72cff8af5b62710e6"><div class="ttname"><a href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6">souffle::visitDepthFirstPreOrder</a></div><div class="ttdeci">void visitDepthFirstPreOrder(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00195">AstVisitor.h:195</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a307bae61c898715dccb57c9732335000_cgraph.png" border="0" usemap="#namespacesouffle_a307bae61c898715dccb57c9732335000_cgraph" alt=""/></div>
<map name="namespacesouffle_a307bae61c898715dccb57c9732335000_cgraph" id="namespacesouffle_a307bae61c898715dccb57c9732335000_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="221,5,389,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="437,5,628,47"/>
</map>
</div>

</div>
</div>
<a id="a59b49c5b71d674c041c04691f7556198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b49c5b71d674c041c04691f7556198">&#9670;&nbsp;</a></span>visitDepthFirst() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Ps, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ram_node.html">RamNode</a> &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsouffle_1_1_ram_visitor.html">RamVisitor</a>&lt; R, Ps... &gt; &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the RAM fragments rooted by the given node recursively in a depth-first pre-order fashion applying the given visitor to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the RAM fragments to be visited </td></tr>
    <tr><td class="paramname">visitor</td><td>the visitor to be applied on each node </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ram_visitor_8h_source.html#l00281">281</a> of file <a class="el" href="_ram_visitor_8h_source.html">RamVisitor.h</a>.</p>

<p class="reference">References <a class="el" href="_ast_visitor_8h_source.html#l00195">visitDepthFirstPreOrder()</a>.</p>
<div class="fragment"><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                                                                                        {</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    <a class="code" href="namespacesouffle.html#aa63199900991e5e4c5a08b3f0ecc28fc">visitDepthFirstPreOrder</a>(root, visitor, args...);</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_aa63199900991e5e4c5a08b3f0ecc28fc"><div class="ttname"><a href="namespacesouffle.html#aa63199900991e5e4c5a08b3f0ecc28fc">souffle::visitDepthFirstPreOrder</a></div><div class="ttdeci">void visitDepthFirstPreOrder(const RamNode &amp;root, RamVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in...</div><div class="ttdef"><b>Definition:</b> <a href="_ram_visitor_8h_source.html#l00262">RamVisitor.h:262</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a59b49c5b71d674c041c04691f7556198_cgraph.png" border="0" usemap="#namespacesouffle_a59b49c5b71d674c041c04691f7556198_cgraph" alt=""/></div>
<map name="namespacesouffle_a59b49c5b71d674c041c04691f7556198_cgraph" id="namespacesouffle_a59b49c5b71d674c041c04691f7556198_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="221,5,389,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="437,5,628,47"/>
</map>
</div>

</div>
</div>
<a id="aed08a0a4f3dee722039516cd22f4ae0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed08a0a4f3dee722039516cd22f4ae0b">&#9670;&nbsp;</a></span>visitDepthFirst() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; R(const N &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first pre-order fashion applying the given function to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be visited </td></tr>
    <tr><td class="paramname">fun</td><td>the function to be applied </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00287">287</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p class="reference">References <a class="el" href="_ast_visitor_8h_source.html#l00258">souffle::detail::makeLambdaAstVisitor()</a>.</p>
<div class="fragment"><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                                                                               {</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    <span class="keyword">auto</span> visitor = <a class="code" href="namespacesouffle_1_1detail.html#a618834ca4e4f896b9b2a1988c9bedfe4">detail::makeLambdaAstVisitor</a>(fun);</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    visitDepthFirst&lt;void&gt;(root, visitor);</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;}</div><div class="ttc" id="namespacesouffle_1_1detail_html_a618834ca4e4f896b9b2a1988c9bedfe4"><div class="ttname"><a href="namespacesouffle_1_1detail.html#a618834ca4e4f896b9b2a1988c9bedfe4">souffle::detail::makeLambdaAstVisitor</a></div><div class="ttdeci">LambdaAstVisitor&lt; R, N &gt; makeLambdaAstVisitor(const std::function&lt; R(const N &amp;)&gt; &amp;fun)</div><div class="ttdoc">A factory function for creating LambdaAstVisitor instances. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00258">AstVisitor.h:258</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aed08a0a4f3dee722039516cd22f4ae0b_cgraph.png" border="0" usemap="#namespacesouffle_aed08a0a4f3dee722039516cd22f4ae0b_cgraph" alt=""/></div>
<map name="namespacesouffle_aed08a0a4f3dee722039516cd22f4ae0b_cgraph" id="namespacesouffle_aed08a0a4f3dee722039516cd22f4ae0b_cgraph">
<area shape="rect" id="node2" href="namespacesouffle_1_1detail.html#a618834ca4e4f896b9b2a1988c9bedfe4" title="A factory function for creating LambdaAstVisitor instances. " alt="" coords="221,5,429,47"/>
</map>
</div>

</div>
</div>
<a id="a761efe11ed6dcdff18dce42b36bc9662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761efe11ed6dcdff18dce42b36bc9662">&#9670;&nbsp;</a></span>visitDepthFirst() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lambda , typename R  = typename lambda_traits&lt;Lambda&gt;::result_type, typename N  = typename lambda_traits&lt;Lambda&gt;::arg0_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structsouffle_1_1detail_1_1is__ast__visitor.html">detail::is_ast_visitor</a>&lt;Lambda&gt;::value, void&gt;::type souffle::visitDepthFirst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Lambda &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first pre-order fashion applying the given function to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be visited </td></tr>
    <tr><td class="paramname">fun</td><td>the function to be applied </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00303">303</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p class="reference">References <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>
<div class="fragment"><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                                                {</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <a class="code" href="namespacesouffle.html#a8e6b482457e03d290adeaf963dabd078">visitDepthFirst</a>(root, std::function&lt;R(<span class="keyword">const</span> N&amp;)&gt;(fun));</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a8e6b482457e03d290adeaf963dabd078"><div class="ttname"><a href="namespacesouffle.html#a8e6b482457e03d290adeaf963dabd078">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;list, const Lambda &amp;fun)</div><div class="ttdoc">A utility function visiting all nodes within a given list of AST root nodes recursively in a depth-fi...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00334">AstVisitor.h:334</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a761efe11ed6dcdff18dce42b36bc9662_cgraph.png" border="0" usemap="#namespacesouffle_a761efe11ed6dcdff18dce42b36bc9662_cgraph" alt=""/></div>
<map name="namespacesouffle_a761efe11ed6dcdff18dce42b36bc9662_cgraph" id="namespacesouffle_a761efe11ed6dcdff18dce42b36bc9662_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="221,13,389,39"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="437,5,605,47"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="653,5,844,47"/>
</map>
</div>

</div>
</div>
<a id="a56b5ea9dd05a947f514d4db711e026d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b5ea9dd05a947f514d4db711e026d0">&#9670;&nbsp;</a></span>visitDepthFirst() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirst </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Lambda &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within a given list of AST root nodes recursively in a depth-first pre-order fashion applying the given function to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list of roots of the ASTs to be visited </td></tr>
    <tr><td class="paramname">fun</td><td>the function to be applied </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00318">318</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p class="reference">References <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>
<div class="fragment"><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                                                                   {</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cur : list) {</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;        <a class="code" href="namespacesouffle.html#a8e6b482457e03d290adeaf963dabd078">visitDepthFirst</a>(*cur, fun);</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    }</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a8e6b482457e03d290adeaf963dabd078"><div class="ttname"><a href="namespacesouffle.html#a8e6b482457e03d290adeaf963dabd078">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;list, const Lambda &amp;fun)</div><div class="ttdoc">A utility function visiting all nodes within a given list of AST root nodes recursively in a depth-fi...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00334">AstVisitor.h:334</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a56b5ea9dd05a947f514d4db711e026d0_cgraph.png" border="0" usemap="#namespacesouffle_a56b5ea9dd05a947f514d4db711e026d0_cgraph" alt=""/></div>
<map name="namespacesouffle_a56b5ea9dd05a947f514d4db711e026d0_cgraph" id="namespacesouffle_a56b5ea9dd05a947f514d4db711e026d0_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="221,13,389,39"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="437,5,605,47"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="653,5,844,47"/>
</map>
</div>

</div>
</div>
<a id="a8e6b482457e03d290adeaf963dabd078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6b482457e03d290adeaf963dabd078">&#9670;&nbsp;</a></span>visitDepthFirst() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Lambda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirst </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Lambda &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within a given list of AST root nodes recursively in a depth-first pre-order fashion applying the given function to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list of roots of the ASTs to be visited </td></tr>
    <tr><td class="paramname">fun</td><td>the function to be applied </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00334">334</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p class="reference">References <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>
<div class="fragment"><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                                                                                 {</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; cur : list) {</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        <a class="code" href="namespacesouffle.html#a8e6b482457e03d290adeaf963dabd078">visitDepthFirst</a>(*cur, fun);</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    }</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a8e6b482457e03d290adeaf963dabd078"><div class="ttname"><a href="namespacesouffle.html#a8e6b482457e03d290adeaf963dabd078">souffle::visitDepthFirst</a></div><div class="ttdeci">void visitDepthFirst(const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;list, const Lambda &amp;fun)</div><div class="ttdoc">A utility function visiting all nodes within a given list of AST root nodes recursively in a depth-fi...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00334">AstVisitor.h:334</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8e6b482457e03d290adeaf963dabd078_cgraph.png" border="0" usemap="#namespacesouffle_a8e6b482457e03d290adeaf963dabd078_cgraph" alt=""/></div>
<map name="namespacesouffle_a8e6b482457e03d290adeaf963dabd078_cgraph" id="namespacesouffle_a8e6b482457e03d290adeaf963dabd078_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="221,13,389,39"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="437,5,605,47"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="653,5,844,47"/>
</map>
</div>

</div>
</div>
<a id="a3f56d579f447fc1976686014c8b6fed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f56d579f447fc1976686014c8b6fed4">&#9670;&nbsp;</a></span>visitDepthFirst() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ram_node.html">RamNode</a> &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; R(const N &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in a depth-first pre-order fashion applying the given function to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the RAM fragment to be visited </td></tr>
    <tr><td class="paramname">fun</td><td>the function to be applied </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ram_visitor_8h_source.html#l00335">335</a> of file <a class="el" href="_ram_visitor_8h_source.html">RamVisitor.h</a>.</p>

<p class="reference">References <a class="el" href="_ram_visitor_8h_source.html#l00306">souffle::detail::makeLambdaRamVisitor()</a>.</p>
<div class="fragment"><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                                                                               {</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    <span class="keyword">auto</span> visitor = <a class="code" href="namespacesouffle_1_1detail.html#ac9160683411c6e5e09dd6a56645429e0">detail::makeLambdaRamVisitor</a>(fun);</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    visitDepthFirst&lt;void&gt;(root, visitor);</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;}</div><div class="ttc" id="namespacesouffle_1_1detail_html_ac9160683411c6e5e09dd6a56645429e0"><div class="ttname"><a href="namespacesouffle_1_1detail.html#ac9160683411c6e5e09dd6a56645429e0">souffle::detail::makeLambdaRamVisitor</a></div><div class="ttdeci">LambdaRamVisitor&lt; R, N &gt; makeLambdaRamVisitor(const std::function&lt; R(const N &amp;)&gt; &amp;fun)</div><div class="ttdoc">A factory function for creating LambdaRamVisitor instances. </div><div class="ttdef"><b>Definition:</b> <a href="_ram_visitor_8h_source.html#l00306">RamVisitor.h:306</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a3f56d579f447fc1976686014c8b6fed4_cgraph.png" border="0" usemap="#namespacesouffle_a3f56d579f447fc1976686014c8b6fed4_cgraph" alt=""/></div>
<map name="namespacesouffle_a3f56d579f447fc1976686014c8b6fed4_cgraph" id="namespacesouffle_a3f56d579f447fc1976686014c8b6fed4_cgraph">
<area shape="rect" id="node2" href="namespacesouffle_1_1detail.html#ac9160683411c6e5e09dd6a56645429e0" title="A factory function for creating LambdaRamVisitor instances. " alt="" coords="221,5,429,47"/>
</map>
</div>

</div>
</div>
<a id="a5f75835c6570547ab2d0c50376202dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f75835c6570547ab2d0c50376202dc7">&#9670;&nbsp;</a></span>visitDepthFirst() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lambda , typename R  = typename lambda_traits&lt;Lambda&gt;::result_type, typename N  = typename lambda_traits&lt;Lambda&gt;::arg0_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structsouffle_1_1detail_1_1is__ram__visitor.html">detail::is_ram_visitor</a>&lt;Lambda&gt;::value, void&gt;::type souffle::visitDepthFirst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ram_node.html">RamNode</a> &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Lambda &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in a depth-first pre-order fashion applying the given function to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the RAM fragment to be visited </td></tr>
    <tr><td class="paramname">fun</td><td>the function to be applied </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ram_visitor_8h_source.html#l00351">351</a> of file <a class="el" href="_ram_visitor_8h_source.html">RamVisitor.h</a>.</p>

<p class="reference">References <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>.</p>
<div class="fragment"><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                                                {</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    <a class="code" href="namespacesouffle.html#a5f75835c6570547ab2d0c50376202dc7">visitDepthFirst</a>(root, std::function&lt;R(<span class="keyword">const</span> N&amp;)&gt;(fun));</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a5f75835c6570547ab2d0c50376202dc7"><div class="ttname"><a href="namespacesouffle.html#a5f75835c6570547ab2d0c50376202dc7">souffle::visitDepthFirst</a></div><div class="ttdeci">std::enable_if&lt;!detail::is_ram_visitor&lt; Lambda &gt;::value, void &gt;::type visitDepthFirst(const RamNode &amp;root, const Lambda &amp;fun)</div><div class="ttdoc">A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in...</div><div class="ttdef"><b>Definition:</b> <a href="_ram_visitor_8h_source.html#l00351">RamVisitor.h:351</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a5f75835c6570547ab2d0c50376202dc7_cgraph.png" border="0" usemap="#namespacesouffle_a5f75835c6570547ab2d0c50376202dc7_cgraph" alt=""/></div>
<map name="namespacesouffle_a5f75835c6570547ab2d0c50376202dc7_cgraph" id="namespacesouffle_a5f75835c6570547ab2d0c50376202dc7_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a307bae61c898715dccb57c9732335000" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="221,13,389,39"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="437,5,605,47"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="653,5,844,47"/>
</map>
</div>

</div>
</div>
<a id="a8e603a0cbf511478333b3d6ef87d49c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e603a0cbf511478333b3d6ef87d49c5">&#9670;&nbsp;</a></span>visitDepthFirstPostOrder() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Ps, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirstPostOrder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsouffle_1_1_ast_visitor.html">AstVisitor</a>&lt; R, Ps... &gt; &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first post-order fashion applying the given visitor to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be visited </td></tr>
    <tr><td class="paramname">visitor</td><td>the visitor to be applied on each node </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00214">214</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p class="reference">References <a class="el" href="_ast_node_8h_source.html#l00081">souffle::AstNode::getChildNodes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_translator_8cpp_source.html#l00534">souffle::AstTranslator::ClauseTranslator::createValueIndex()</a>, <a class="el" href="_ast_transforms_8cpp_source.html#l00192">souffle::UniqueAggregationVariablesTransformer::transform()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00366">visitDepthFirstPostOrder()</a>.</p>
<div class="fragment"><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                                                                                                 {</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> AstNode* cur : root.getChildNodes()) {</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        <span class="keywordflow">if</span> (cur != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;            <a class="code" href="namespacesouffle.html#a1033c68a525f042c980bc63e96363062">visitDepthFirstPostOrder</a>(*cur, visitor, args...);</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        }</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    }</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    visitor(root, args...);</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a1033c68a525f042c980bc63e96363062"><div class="ttname"><a href="namespacesouffle.html#a1033c68a525f042c980bc63e96363062">souffle::visitDepthFirstPostOrder</a></div><div class="ttdeci">std::enable_if&lt;!detail::is_ast_visitor&lt; Lambda &gt;::value, void &gt;::type visitDepthFirstPostOrder(const AstNode &amp;root, const Lambda &amp;fun)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00366">AstVisitor.h:366</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8e603a0cbf511478333b3d6ef87d49c5_cgraph.png" border="0" usemap="#namespacesouffle_a8e603a0cbf511478333b3d6ef87d49c5_cgraph" alt=""/></div>
<map name="namespacesouffle_a8e603a0cbf511478333b3d6ef87d49c5_cgraph" id="namespacesouffle_a8e603a0cbf511478333b3d6ef87d49c5_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="221,5,412,47"/>
</map>
</div>

</div>
</div>
<a id="a8c81a4bc3ebe951bd58b9b323b451e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c81a4bc3ebe951bd58b9b323b451e3a">&#9670;&nbsp;</a></span>visitDepthFirstPostOrder() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirstPostOrder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; R(const N &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first post-order fashion applying the given function to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be visited </td></tr>
    <tr><td class="paramname">fun</td><td>the function to be applied </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00350">350</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p class="reference">References <a class="el" href="_ast_visitor_8h_source.html#l00258">souffle::detail::makeLambdaAstVisitor()</a>.</p>
<div class="fragment"><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;                                                                                        {</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    <span class="keyword">auto</span> visitor = <a class="code" href="namespacesouffle_1_1detail.html#a618834ca4e4f896b9b2a1988c9bedfe4">detail::makeLambdaAstVisitor</a>(fun);</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    visitDepthFirstPostOrder&lt;void&gt;(root, visitor);</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;}</div><div class="ttc" id="namespacesouffle_1_1detail_html_a618834ca4e4f896b9b2a1988c9bedfe4"><div class="ttname"><a href="namespacesouffle_1_1detail.html#a618834ca4e4f896b9b2a1988c9bedfe4">souffle::detail::makeLambdaAstVisitor</a></div><div class="ttdeci">LambdaAstVisitor&lt; R, N &gt; makeLambdaAstVisitor(const std::function&lt; R(const N &amp;)&gt; &amp;fun)</div><div class="ttdoc">A factory function for creating LambdaAstVisitor instances. </div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00258">AstVisitor.h:258</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a8c81a4bc3ebe951bd58b9b323b451e3a_cgraph.png" border="0" usemap="#namespacesouffle_a8c81a4bc3ebe951bd58b9b323b451e3a_cgraph" alt=""/></div>
<map name="namespacesouffle_a8c81a4bc3ebe951bd58b9b323b451e3a_cgraph" id="namespacesouffle_a8c81a4bc3ebe951bd58b9b323b451e3a_cgraph">
<area shape="rect" id="node2" href="namespacesouffle_1_1detail.html#a618834ca4e4f896b9b2a1988c9bedfe4" title="A factory function for creating LambdaAstVisitor instances. " alt="" coords="221,5,429,47"/>
</map>
</div>

</div>
</div>
<a id="a1033c68a525f042c980bc63e96363062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1033c68a525f042c980bc63e96363062">&#9670;&nbsp;</a></span>visitDepthFirstPostOrder() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lambda , typename R  = typename lambda_traits&lt;Lambda&gt;::result_type, typename N  = typename lambda_traits&lt;Lambda&gt;::arg0_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structsouffle_1_1detail_1_1is__ast__visitor.html">detail::is_ast_visitor</a>&lt;Lambda&gt;::value, void&gt;::type souffle::visitDepthFirstPostOrder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Lambda &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first post-order fashion applying the given function to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be visited </td></tr>
    <tr><td class="paramname">fun</td><td>the function to be applied </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00366">366</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p class="reference">References <a class="el" href="_ast_visitor_8h_source.html#l00214">visitDepthFirstPostOrder()</a>.</p>
<div class="fragment"><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                                                {</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    <a class="code" href="namespacesouffle.html#a1033c68a525f042c980bc63e96363062">visitDepthFirstPostOrder</a>(root, std::function&lt;R(<span class="keyword">const</span> N&amp;)&gt;(fun));</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a1033c68a525f042c980bc63e96363062"><div class="ttname"><a href="namespacesouffle.html#a1033c68a525f042c980bc63e96363062">souffle::visitDepthFirstPostOrder</a></div><div class="ttdeci">std::enable_if&lt;!detail::is_ast_visitor&lt; Lambda &gt;::value, void &gt;::type visitDepthFirstPostOrder(const AstNode &amp;root, const Lambda &amp;fun)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00366">AstVisitor.h:366</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a1033c68a525f042c980bc63e96363062_cgraph.png" border="0" usemap="#namespacesouffle_a1033c68a525f042c980bc63e96363062_cgraph" alt=""/></div>
<map name="namespacesouffle_a1033c68a525f042c980bc63e96363062_cgraph" id="namespacesouffle_a1033c68a525f042c980bc63e96363062_cgraph">
<area shape="rect" id="node2" href="namespacesouffle.html#a8e603a0cbf511478333b3d6ef87d49c5" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="221,5,389,47"/>
<area shape="rect" id="node3" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="437,5,628,47"/>
</map>
</div>

</div>
</div>
<a id="a030c754119d60ea72cff8af5b62710e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030c754119d60ea72cff8af5b62710e6">&#9670;&nbsp;</a></span>visitDepthFirstPreOrder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Ps, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirstPreOrder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ast_node.html">AstNode</a> &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsouffle_1_1_ast_visitor.html">AstVisitor</a>&lt; R, Ps... &gt; &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-first pre-order fashion applying the given visitor to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the AST to be visited </td></tr>
    <tr><td class="paramname">visitor</td><td>the visitor to be applied on each node </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ast_visitor_8h_source.html#l00195">195</a> of file <a class="el" href="_ast_visitor_8h_source.html">AstVisitor.h</a>.</p>

<p class="reference">References <a class="el" href="_ast_node_8h_source.html#l00081">souffle::AstNode::getChildNodes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_ast_visitor_8h_source.html#l00233">visitDepthFirst()</a>, and <a class="el" href="_ram_visitor_8h_source.html#l00262">visitDepthFirstPreOrder()</a>.</p>
<div class="fragment"><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                                                                                                {</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    visitor(root, args...);</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> AstNode* cur : root.getChildNodes()) {</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        <span class="keywordflow">if</span> (cur != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            <a class="code" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6">visitDepthFirstPreOrder</a>(*cur, visitor, args...);</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        }</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    }</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a030c754119d60ea72cff8af5b62710e6"><div class="ttname"><a href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6">souffle::visitDepthFirstPreOrder</a></div><div class="ttdeci">void visitDepthFirstPreOrder(const AstNode &amp;root, AstVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the ast rooted by the given node recursively in a depth-...</div><div class="ttdef"><b>Definition:</b> <a href="_ast_visitor_8h_source.html#l00195">AstVisitor.h:195</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_a030c754119d60ea72cff8af5b62710e6_cgraph.png" border="0" usemap="#namespacesouffle_a030c754119d60ea72cff8af5b62710e6_cgraph" alt=""/></div>
<map name="namespacesouffle_a030c754119d60ea72cff8af5b62710e6_cgraph" id="namespacesouffle_a030c754119d60ea72cff8af5b62710e6_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="221,5,412,47"/>
</map>
</div>

</div>
</div>
<a id="aa63199900991e5e4c5a08b3f0ecc28fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63199900991e5e4c5a08b3f0ecc28fc">&#9670;&nbsp;</a></span>visitDepthFirstPreOrder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Ps, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void souffle::visitDepthFirstPreOrder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsouffle_1_1_ram_node.html">RamNode</a> &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsouffle_1_1_ram_visitor.html">RamVisitor</a>&lt; R, Ps... &gt; &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in a depth-first pre-order fashion applying the given visitor to each encountered node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the RAM fragment to be visited </td></tr>
    <tr><td class="paramname">visitor</td><td>the visitor to be applied on each node </td></tr>
    <tr><td class="paramname">args</td><td>a list of extra parameters to be forwarded to the visitor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_ram_visitor_8h_source.html#l00262">262</a> of file <a class="el" href="_ram_visitor_8h_source.html">RamVisitor.h</a>.</p>

<p class="reference">References <a class="el" href="_ram_node_8h_source.html#l00147">souffle::RamNode::getChildNodes()</a>, and <a class="el" href="_ast_visitor_8h_source.html#l00195">visitDepthFirstPreOrder()</a>.</p>
<div class="fragment"><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;                                                                                                {</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    visitor(root, args...);</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> RamNode* cur : root.getChildNodes()) {</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        <span class="keywordflow">if</span> (cur != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            <a class="code" href="namespacesouffle.html#aa63199900991e5e4c5a08b3f0ecc28fc">visitDepthFirstPreOrder</a>(*cur, visitor, args...);</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        }</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    }</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_aa63199900991e5e4c5a08b3f0ecc28fc"><div class="ttname"><a href="namespacesouffle.html#aa63199900991e5e4c5a08b3f0ecc28fc">souffle::visitDepthFirstPreOrder</a></div><div class="ttdeci">void visitDepthFirstPreOrder(const RamNode &amp;root, RamVisitor&lt; R, Ps... &gt; &amp;visitor, Args &amp;... args)</div><div class="ttdoc">A utility function visiting all nodes within the RAM fragment rooted by the given node recursively in...</div><div class="ttdef"><b>Definition:</b> <a href="_ram_visitor_8h_source.html#l00262">RamVisitor.h:262</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesouffle_aa63199900991e5e4c5a08b3f0ecc28fc_cgraph.png" border="0" usemap="#namespacesouffle_aa63199900991e5e4c5a08b3f0ecc28fc_cgraph" alt=""/></div>
<map name="namespacesouffle_aa63199900991e5e4c5a08b3f0ecc28fc_cgraph" id="namespacesouffle_aa63199900991e5e4c5a08b3f0ecc28fc_cgraph">
<area shape="rect" id="node2" href="classsouffle_1_1_ram_node.html#a173ee99e69bee1a94ccee5430f549f62" title="Obtain list of all embedded child nodes. " alt="" coords="221,5,421,47"/>
<area shape="rect" id="node3" href="namespacesouffle.html#a030c754119d60ea72cff8af5b62710e6" title="A utility function visiting all nodes within the ast rooted by the given node recursively in a depth&#45;..." alt="" coords="237,71,405,112"/>
<area shape="rect" id="node4" href="classsouffle_1_1_ast_node.html#a07dd728cde93a2b1d72d987cf54cbd8e" title="Obtain a list of all embedded AST child nodes. " alt="" coords="469,71,660,112"/>
</map>
</div>

</div>
</div>
<a id="a6e9757564e85959db8b14a9be7d544e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9757564e85959db8b14a9be7d544e1">&#9670;&nbsp;</a></span>which()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string souffle::which </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple implementation of a which tool. </p>

<p class="definition">Definition at line <a class="el" href="_util_8h_source.html#l01091">1091</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="main_8cpp_source.html#l00124">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;                                              {</div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;    <span class="keywordtype">char</span> buf[PATH_MAX];</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;    <span class="keywordflow">if</span> ((::realpath(name.c_str(), buf) != <span class="keyword">nullptr</span>) &amp;&amp; <a class="code" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">isExecutable</a>(buf)) {</div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;        <span class="keywordflow">return</span> buf;</div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;    }</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">char</span>* syspath = ::getenv(<span class="stringliteral">&quot;PATH&quot;</span>);</div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;    <span class="keywordflow">if</span> (syspath == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;</div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;    }</div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;    std::stringstream sstr;</div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;    sstr &lt;&lt; syspath;</div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;    std::string <a class="code" href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">sub</a>;</div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;    <span class="keywordflow">while</span> (std::getline(sstr, sub, <span class="charliteral">&#39;:&#39;</span>)) {</div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;        std::string path = sub + <span class="stringliteral">&quot;/&quot;</span> + name;</div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">isExecutable</a>(path) &amp;&amp; (realpath(path.c_str(), buf) != <span class="keyword">nullptr</span>)) {</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;            <span class="keywordflow">return</span> buf;</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;        }</div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;    }</div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;    <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;</div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;}</div><div class="ttc" id="namespacesouffle_html_a7f93cdf21f1a24b593da6691dc892828"><div class="ttname"><a href="namespacesouffle.html#a7f93cdf21f1a24b593da6691dc892828">souffle::sub</a></div><div class="ttdeci">std::shared_ptr&lt; Constraint&lt; Var &gt; &gt; sub(const Var &amp;a, const Var &amp;b, const std::string &amp;symbol=&quot;⊑&quot;)</div><div class="ttdoc">A generic factory for constraints of the form. </div><div class="ttdef"><b>Definition:</b> <a href="_constraints_8h_source.html#l00221">Constraints.h:221</a></div></div>
<div class="ttc" id="namespacesouffle_html_a64753e143a37bb9414121fc75987cb14"><div class="ttname"><a href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">souffle::isExecutable</a></div><div class="ttdeci">bool isExecutable(const std::string &amp;name)</div><div class="ttdoc">Check whether a given file exists and it is an executable. </div><div class="ttdef"><b>Definition:</b> <a href="_util_8h_source.html#l01084">Util.h:1084</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0365b7f74600453cae13b5cc4a64cf29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0365b7f74600453cae13b5cc4a64cf29">&#9670;&nbsp;</a></span>else</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">souffle::else</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">            std::string <a class="code" href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a></div><div class="ttc" id="json11_8h_html_a25fda444d34d64acade61be6f9d35367"><div class="ttname"><a href="json11_8h.html#a25fda444d34d64acade61be6f9d35367">str</a></div><div class="ttdeci">const std::string &amp; str</div><div class="ttdef"><b>Definition:</b> <a href="json11_8h_source.html#l00650">json11.h:650</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_tui_8h_source.html#l00468">468</a> of file <a class="el" href="_tui_8h_source.html">Tui.h</a>.</p>

</div>
</div>
<a id="a30960f5b40f826ffdc4cd2fb12161fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30960f5b40f826ffdc4cd2fb12161fe2">&#9670;&nbsp;</a></span>getName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ss&lt;&lt; R&quot;_(&quot;usage&quot;: [)_&quot;; bool firstRow = true; Usage previousUsage = *usages.begin(); previousUsage.time = beginTime; for (auto usage : usages) { comma(firstRow); ss &lt;&lt; '['; ss &lt;&lt; (usage.time - beginTime).count() / 1000000.0 &lt;&lt; &quot;, &quot;; ss &lt;&lt; 100.0 * (usage.usertime - previousUsage.usertime) / (usage.time - previousUsage.time) &lt;&lt; &quot;, &quot;; ss &lt;&lt; 100.0 * (usage.systemtime - previousUsage.systemtime) / (usage.time - previousUsage.time) &lt;&lt; &quot;, &quot;; ss &lt;&lt; usage.maxRSS * 1024 &lt;&lt; &quot;, &quot;; ss &lt;&lt; '&quot;'; bool firstCol = true; for (auto&amp; cur : out.getProgramRun()-&gt;getRelationsAtTime(previousUsage.time, usage.time)) { comma(firstCol); ss &lt;&lt; cur-&gt; souffle::getName()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_tui_8h_source.html#l00501">501</a> of file <a class="el" href="_tui_8h_source.html">Tui.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_minimise_program_transformer_8cpp_source.html#l00161">isValidPermutation()</a>, and <a class="el" href="_ast_translator_8cpp_source.html#l01061">souffle::AstTranslator::translateRecursiveRelation()</a>.</p>

</div>
</div>
<a id="a16844ea6742671f3aed14d36267a103e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16844ea6742671f3aed14d36267a103e">&#9670;&nbsp;</a></span>isRamType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool souffle::isRamType</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= (std::is_same&lt;T, RamDomain&gt;::value || std::is_same&lt;T, RamSigned&gt;::value ||</div><div class="line">                            std::is_same&lt;T, RamUnsigned&gt;::value || std::is_same&lt;T, RamFloat&gt;::value)</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="_ram_types_8h_source.html#l00108">108</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

</div>
</div>
<a id="a8e34f8a0110d99825e6a1e3e1123f866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e34f8a0110d99825e6a1e3e1123f866">&#9670;&nbsp;</a></span>MAX_RAM_FLOAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacesouffle.html#a71ed4e379ed3ad06b9d02a4fc8470646">RamFloat</a> souffle::MAX_RAM_FLOAT = std::numeric_limits&lt;<a class="el" href="namespacesouffle.html#a71ed4e379ed3ad06b9d02a4fc8470646">RamFloat</a>&gt;::max()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ram_types_8h_source.html#l00139">139</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_interpreter_engine_8cpp_source.html#l01218">souffle::InterpreterEngine::executeAggregate()</a>.</p>

</div>
</div>
<a id="ac01cb9e9ef3b075f569709efcd0d8fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01cb9e9ef3b075f569709efcd0d8fc2">&#9670;&nbsp;</a></span>MAX_RAM_SIGNED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacesouffle.html#a506d6a56200708498577b6e4d3a83ae3">RamSigned</a> souffle::MAX_RAM_SIGNED = std::numeric_limits&lt;<a class="el" href="namespacesouffle.html#a506d6a56200708498577b6e4d3a83ae3">RamSigned</a>&gt;::max()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ram_types_8h_source.html#l00133">133</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_interpreter_engine_8cpp_source.html#l00220">souffle::InterpreterEngine::execute()</a>, and <a class="el" href="_interpreter_engine_8cpp_source.html#l01218">souffle::InterpreterEngine::executeAggregate()</a>.</p>

</div>
</div>
<a id="a73ca99d17975adee2f4dda8a8f00783e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ca99d17975adee2f4dda8a8f00783e">&#9670;&nbsp;</a></span>MAX_RAM_UNSIGNED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacesouffle.html#afaab74f4511cf7a2da6afe0e001be9c6">RamUnsigned</a> souffle::MAX_RAM_UNSIGNED = std::numeric_limits&lt;<a class="el" href="namespacesouffle.html#afaab74f4511cf7a2da6afe0e001be9c6">RamUnsigned</a>&gt;::max()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ram_types_8h_source.html#l00136">136</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_interpreter_engine_8cpp_source.html#l01218">souffle::InterpreterEngine::executeAggregate()</a>.</p>

</div>
</div>
<a id="a5dab3baf25a2525107df6666d6e9b40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dab3baf25a2525107df6666d6e9b40f">&#9670;&nbsp;</a></span>MIN_RAM_FLOAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacesouffle.html#a71ed4e379ed3ad06b9d02a4fc8470646">RamFloat</a> souffle::MIN_RAM_FLOAT = std::numeric_limits&lt;<a class="el" href="namespacesouffle.html#a71ed4e379ed3ad06b9d02a4fc8470646">RamFloat</a>&gt;::min()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ram_types_8h_source.html#l00138">138</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_interpreter_engine_8cpp_source.html#l01218">souffle::InterpreterEngine::executeAggregate()</a>.</p>

</div>
</div>
<a id="ab108e1ed3dc35638e9432fba35831c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab108e1ed3dc35638e9432fba35831c99">&#9670;&nbsp;</a></span>MIN_RAM_SIGNED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacesouffle.html#a506d6a56200708498577b6e4d3a83ae3">RamSigned</a> souffle::MIN_RAM_SIGNED = std::numeric_limits&lt;<a class="el" href="namespacesouffle.html#a506d6a56200708498577b6e4d3a83ae3">RamSigned</a>&gt;::min()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>lower and upper boundaries for the ram types </p>

<p class="definition">Definition at line <a class="el" href="_ram_types_8h_source.html#l00132">132</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_interpreter_engine_8cpp_source.html#l00220">souffle::InterpreterEngine::execute()</a>, <a class="el" href="_interpreter_engine_8cpp_source.html#l01218">souffle::InterpreterEngine::executeAggregate()</a>, and <a class="el" href="_equivalence_relation_8h_source.html#l00523">souffle::EquivalenceRelation&lt; t_tuple&lt; 2 &gt; &gt;::lower_bound()</a>.</p>

</div>
</div>
<a id="af83783b2554d58083585aed095a51349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83783b2554d58083585aed095a51349">&#9670;&nbsp;</a></span>MIN_RAM_UNSIGNED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacesouffle.html#afaab74f4511cf7a2da6afe0e001be9c6">RamUnsigned</a> souffle::MIN_RAM_UNSIGNED = std::numeric_limits&lt;<a class="el" href="namespacesouffle.html#afaab74f4511cf7a2da6afe0e001be9c6">RamUnsigned</a>&gt;::min()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_ram_types_8h_source.html#l00135">135</a> of file <a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_interpreter_engine_8cpp_source.html#l01218">souffle::InterpreterEngine::executeAggregate()</a>.</p>

</div>
</div>
<a id="a10ebbb9279d847e1780c7423a4adf030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ebbb9279d847e1780c7423a4adf030">&#9670;&nbsp;</a></span>rank_mask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacesouffle.html#a86f22adc58415a0ceecac60f7456f7d3">block_t</a> souffle::rank_mask = (1ul &lt;&lt; split_size) - 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_union_find_8h_source.html#l00047">47</a> of file <a class="el" href="_union_find_8h_source.html">UnionFind.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_union_find_8h_source.html#l00219">souffle::DisjointSet::b2r()</a>.</p>

</div>
</div>
<a id="ab6cae1829154de74317f872045c811c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cae1829154de74317f872045c811c2">&#9670;&nbsp;</a></span>split_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint8_t souffle::split_size = 8u</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_union_find_8h_source.html#l00042">42</a> of file <a class="el" href="_union_find_8h_source.html">UnionFind.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_union_find_8h_source.html#l00210">souffle::DisjointSet::b2p()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
